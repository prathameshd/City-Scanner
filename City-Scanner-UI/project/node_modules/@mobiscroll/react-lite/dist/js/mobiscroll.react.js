(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('react-dom'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['react', 'react-dom', 'prop-types'], factory) :
  (global.mobiscroll = factory(global.React,global.ReactDOM,global.PropTypes));
}(this, (function (React,ReactDOM,PropTypes) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;
  ReactDOM = ReactDOM && ReactDOM.hasOwnProperty('default') ? ReactDOM['default'] : ReactDOM;
  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

  var mobiscroll$3 = mobiscroll$3 || {};
  var util = {};

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };











  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();







  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };











  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var cssNumber = {
      'column-count': 1,
      'columns': 1,
      'font-weight': 1,
      'line-height': 1,
      'opacity': 1,
      'z-index': 1,
      'zoom': 1
  };
  var propMap = {
      'readonly': 'readOnly'
  };
  var emptyArray = [];
  var _slice = Array.prototype.slice;

  function isFunction(value) {
      return typeof value === "function";
  }

  function isObject(obj) {
      return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === "object";
  }

  function likeArray(obj) {
      return typeof obj.length == 'number';
  }

  function camelize(str) {
      return str.replace(/-+(.)?/g, function (match, chr) {
          return chr ? chr.toUpperCase() : '';
      });
  }

  function extend(target, source, deep) {
      for (var key in source) {
          if (deep && ($$1.isPlainObject(source[key]) || $$1.isArray(source[key]))) {
              if ($$1.isPlainObject(source[key]) && !$$1.isPlainObject(target[key]) || $$1.isArray(source[key]) && !$$1.isArray(target[key])) {
                  target[key] = {};
              }
              extend(target[key], source[key], deep);
          } else if (source[key] !== undefined) {
              target[key] = source[key];
          }
      }
  }

  function dasherize(str) {
      return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
  }

  function maybeAddPx(name, value) {
      return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
  }

  var Dom = function () {
      var Dom = function Dom(arr) {
          var _this = this,
              i = 0;
          // Create array-like object
          for (i = 0; i < arr.length; i++) {
              _this[i] = arr[i];
          }
          _this.length = arr.length;
          // Return collection with methods
          return $(this);
      };

      var $ = function $(selector, context) {
          var arr = [],
              i = 0;
          if (selector && !context) {
              if (selector instanceof Dom) {
                  return selector;
              }
          }

          if (isFunction(selector)) {
              return $(document).ready(selector);
          }

          if (selector) {
              // String
              if (typeof selector === 'string') {
                  var els, tempParent, html;
                  selector = html = selector.trim();
                  if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                      var toCreate = 'div';
                      if (html.indexOf('<li') === 0) {
                          toCreate = 'ul';
                      }
                      if (html.indexOf('<tr') === 0) {
                          toCreate = 'tbody';
                      }
                      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
                          toCreate = 'tr';
                      }
                      if (html.indexOf('<tbody') === 0) {
                          toCreate = 'table';
                      }
                      if (html.indexOf('<option') === 0) {
                          toCreate = 'select';
                      }
                      tempParent = document.createElement(toCreate);
                      tempParent.innerHTML = html;
                      for (i = 0; i < tempParent.childNodes.length; i++) {
                          arr.push(tempParent.childNodes[i]);
                      }
                  } else {
                      if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                          // Pure ID selector
                          els = [document.getElementById(selector.split('#')[1])];
                      } else {
                          if (context instanceof Dom) {
                              context = context[0];
                          }
                          // Other selectors
                          els = (context || document).querySelectorAll(selector);
                      }
                      for (i = 0; i < els.length; i++) {
                          if (els[i]) {
                              arr.push(els[i]);
                          }
                      }
                  }
              }
              // Node/element
              else if (selector.nodeType || selector === window || selector === document) {
                      arr.push(selector);
                  }
                  //Array of elements or instance of Dom
                  else if (selector.length > 0 && selector[0].nodeType) {
                          for (i = 0; i < selector.length; i++) {
                              arr.push(selector[i]);
                          }
                      } else if ($.isArray(selector)) {
                          arr = selector;
                      }
          }
          return new Dom(arr);
      };

      Dom.prototype = {
          ready: function ready(callback) {
              if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {
                  callback($);
              } else {
                  document.addEventListener('DOMContentLoaded', function () {
                      callback($);
                  }, false);
              }
              return this;
          },
          concat: emptyArray.concat,
          empty: function empty() {
              return this.each(function () {
                  this.innerHTML = '';
              });
          },
          map: function map(fn) {
              return $($.map(this, function (el, i) {
                  return fn.call(el, i, el);
              }));
          },
          slice: function slice() {
              return $(_slice.apply(this, arguments));
          },
          // Classes and attriutes
          // NOTE: element.classList attribure is not supported on android 2.3!!!
          addClass: function addClass(className) {
              if (typeof className === 'undefined') {
                  return this;
              }

              var classes = className.split(' ');

              for (var i = 0; i < classes.length; i++) {
                  for (var j = 0; j < this.length; j++) {
                      if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
                          this[j].classList.add(classes[i]);
                      }
                  }
              }
              return this;
          },
          removeClass: function removeClass(className) {
              if (typeof className === 'undefined') {
                  return this;
              }

              var classes = className.split(' ');
              for (var i = 0; i < classes.length; i++) {
                  for (var j = 0; j < this.length; j++) {
                      if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
                          this[j].classList.remove(classes[i]);
                      }
                  }
              }
              return this;
          },
          hasClass: function hasClass(className) {
              return this[0] ? this[0].classList.contains(className) : false;
          },
          toggleClass: function toggleClass(className) {
              var classes = className.split(' ');
              for (var i = 0; i < classes.length; i++) {
                  for (var j = 0; j < this.length; j++) {
                      if (typeof this[j].classList !== 'undefined') {
                          this[j].classList.toggle(classes[i]);
                      }
                  }
              }
              return this;
          },
          closest: function closest(selector, context) {
              var node = this[0],
                  collection = false;

              if (isObject(selector)) {
                  collection = $(selector);
              }
              while (node && !(collection ? collection.indexOf(node) >= 0 : $.matches(node, selector))) {
                  node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;
              }

              return $(node);
          },
          attr: function attr(attrs, value) {
              var attr;

              if (arguments.length === 1 && typeof attrs === 'string') {
                  // Get attr
                  if (this.length) {
                      attr = this[0].getAttribute(attrs);
                      return attr || attr === '' ? attr : undefined;
                  }
              } else {
                  // Set attrs
                  for (var i = 0; i < this.length; i++) {
                      if (arguments.length === 2) {
                          // String
                          this[i].setAttribute(attrs, value);
                      } else {
                          // Object
                          for (var attrName in attrs) {
                              this[i][attrName] = attrs[attrName];
                              this[i].setAttribute(attrName, attrs[attrName]);
                          }
                      }
                  }
                  return this;
              }
          },
          removeAttr: function removeAttr(attr) {
              for (var i = 0; i < this.length; i++) {
                  this[i].removeAttribute(attr);
              }
              return this;
          },
          prop: function prop(props, value) {
              props = propMap[props] || props;
              if (arguments.length === 1 && typeof props === 'string') {
                  // Get prop
                  return this[0] ? this[0][props] : undefined;
              } else {
                  // Set props
                  for (var i = 0; i < this.length; i++) {
                      this[i][props] = value;
                  }
                  return this;
              }
          },
          val: function val(value) {
              if (typeof value === 'undefined') {
                  if (this.length && this[0].multiple) {
                      return $.map(this.find('option:checked'), function (v) {
                          return v.value;
                      });
                  }
                  return this[0] ? this[0].value : undefined;
              }

              if (this.length && this[0].multiple) {
                  $.each(this[0].options, function () {
                      this.selected = value.indexOf(this.value) != -1;
                  });
              } else {
                  for (var i = 0; i < this.length; i++) {
                      this[i].value = value;
                  }
              }

              return this;
          },
          //Events
          on: function on(eventName, targetSelector, listener, capture) {
              var events = eventName.split(' '),
                  i,
                  j;

              function handleLiveEvent(e) {
                  var k,
                      parents,
                      target = e.target;

                  if ($(target).is(targetSelector)) {
                      listener.call(target, e);
                  } else {
                      parents = $(target).parents();
                      for (k = 0; k < parents.length; k++) {
                          if ($(parents[k]).is(targetSelector)) {
                              listener.call(parents[k], e);
                          }
                      }
                  }
              }

              function handleNamespaces(elm, name, listener, capture) {
                  var namespace = name.split('.');

                  if (!elm.DomNameSpaces) {
                      elm.DomNameSpaces = [];
                  }

                  elm.DomNameSpaces.push({
                      namespace: namespace[1],
                      event: namespace[0],
                      listener: listener,
                      capture: capture
                  });

                  elm.addEventListener(namespace[0], listener, capture);
              }

              for (i = 0; i < this.length; i++) {
                  if (isFunction(targetSelector) || targetSelector === false) {
                      // Usual events
                      if (isFunction(targetSelector)) {
                          capture = listener || false;
                          listener = targetSelector;
                      }
                      for (j = 0; j < events.length; j++) {
                          // check for namespaces
                          if (events[j].indexOf('.') != -1) {
                              handleNamespaces(this[i], events[j], listener, capture);
                          } else {
                              this[i].addEventListener(events[j], listener, capture);
                          }
                      }
                  } else {
                      // Live events
                      for (j = 0; j < events.length; j++) {
                          if (!this[i].DomLiveListeners) {
                              this[i].DomLiveListeners = [];
                          }

                          this[i].DomLiveListeners.push({
                              listener: listener,
                              liveListener: handleLiveEvent
                          });

                          if (events[j].indexOf('.') != -1) {
                              handleNamespaces(this[i], events[j], handleLiveEvent, capture);
                          } else {
                              this[i].addEventListener(events[j], handleLiveEvent, capture);
                          }
                      }
                  }
              }
              return this;
          },
          off: function off(eventName, targetSelector, listener, capture) {
              var events,
                  i,
                  j,
                  k,
                  that = this;

              function removeEvents(event) {
                  var i,
                      j,
                      item,
                      parts = event.split('.'),
                      name = parts[0],
                      ns = parts[1];

                  for (i = 0; i < that.length; ++i) {
                      if (that[i].DomNameSpaces) {
                          for (j = 0; j < that[i].DomNameSpaces.length; ++j) {
                              item = that[i].DomNameSpaces[j];

                              if (item.namespace == ns && (item.event == name || !name)) {
                                  that[i].removeEventListener(item.event, item.listener, item.capture);
                                  item.removed = true;
                              }
                          }
                          // remove the events from the DomNameSpaces array
                          for (j = that[i].DomNameSpaces.length - 1; j >= 0; --j) {
                              if (that[i].DomNameSpaces[j].removed) {
                                  that[i].DomNameSpaces.splice(j, 1);
                              }
                          }
                      }
                  }
              }

              events = eventName.split(' ');

              for (i = 0; i < events.length; i++) {
                  for (j = 0; j < this.length; j++) {
                      if (isFunction(targetSelector) || targetSelector === false) {
                          // Usual events
                          if (isFunction(targetSelector)) {
                              capture = listener || false;
                              listener = targetSelector;
                          }

                          if (events[i].indexOf('.') === 0) {
                              // remove namespace events
                              removeEvents(events[i].substr(1), listener, capture);
                          } else {
                              this[j].removeEventListener(events[i], listener, capture);
                          }
                      } else {
                          // Live event
                          if (this[j].DomLiveListeners) {
                              for (k = 0; k < this[j].DomLiveListeners.length; k++) {
                                  if (this[j].DomLiveListeners[k].listener === listener) {
                                      this[j].removeEventListener(events[i], this[j].DomLiveListeners[k].liveListener, capture);
                                  }
                              }
                          }
                          if (this[j].DomNameSpaces && this[j].DomNameSpaces.length && events[i]) {
                              removeEvents(events[i]);
                          }
                      }
                  }
              }

              return this;
          },
          trigger: function trigger(eventName, eventData) {
              var events = eventName.split(' ');
              for (var i = 0; i < events.length; i++) {
                  for (var j = 0; j < this.length; j++) {
                      var evt;
                      try {
                          evt = new CustomEvent(events[i], {
                              detail: eventData,
                              bubbles: true,
                              cancelable: true
                          });
                      } catch (e) {
                          evt = document.createEvent('Event');
                          evt.initEvent(events[i], true, true);
                          evt.detail = eventData;
                      }
                      this[j].dispatchEvent(evt);
                  }
              }
              return this;
          },
          // Sizing/Styles
          width: function width(dim) {
              if (dim !== undefined) {
                  return this.css('width', dim);
              }

              if (this[0] === window) {
                  return window.innerWidth;
              } else if (this[0] === document) {
                  return document.documentElement.scrollWidth;
              } else {
                  return this.length > 0 ? parseFloat(this.css('width')) : null;
              }
          },
          height: function height(dim) {
              if (dim !== undefined) {
                  return this.css('height', dim);
              }

              if (this[0] === window) {
                  return window.innerHeight;
              } else if (this[0] === document) {
                  var body = document.body,
                      html = document.documentElement;

                  return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
              } else {
                  return this.length > 0 ? parseFloat(this.css('height')) : null;
              }
          },
          innerWidth: function innerWidth() {
              var elm = this;
              if (this.length > 0) {
                  if (this[0].innerWidth) {
                      return this[0].innerWidth;
                  } else {
                      var size = this[0].offsetWidth,
                          sides = ['left', 'right'];

                      sides.forEach(function (side) {
                          size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
                      });
                      return size;
                  }
              }
          },
          innerHeight: function innerHeight() {
              var elm = this;
              if (this.length > 0) {
                  if (this[0].innerHeight) {
                      return this[0].innerHeight;
                  } else {
                      var size = this[0].offsetHeight,
                          sides = ['top', 'bottom'];

                      sides.forEach(function (side) {
                          size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
                      });

                      return size;
                  }
              }
          },
          offset: function offset() {
              if (this.length > 0) {
                  var el = this[0],
                      box = el.getBoundingClientRect(),
                      doc = document.documentElement;

                  return {
                      top: box.top + window.pageYOffset - doc.clientTop,
                      left: box.left + window.pageXOffset - doc.clientLeft
                  };
              }
          },
          hide: function hide() {
              for (var i = 0; i < this.length; i++) {
                  this[i].style.display = 'none';
              }
              return this;
          },
          show: function show() {
              for (var i = 0; i < this.length; i++) {
                  if (this[i].style.display == "none") {
                      this[i].style.display = '';
                  }

                  if (getComputedStyle(this[i], '').getPropertyValue("display") == "none") {
                      this[i].style.display = 'block';
                  }
              }

              return this;
          },
          clone: function clone() {
              return this.map(function () {
                  return this.cloneNode(true);
              });
          },
          styles: function styles() {
              return this[0] ? window.getComputedStyle(this[0], null) : undefined;
          },
          css: function css(property, value) {
              var i,
                  key,
                  element = this[0],
                  css = '';

              if (arguments.length < 2) {
                  if (!element) {
                      return;
                  }
                  if (typeof property === 'string') {
                      return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);
                  }
              }

              if (typeof property === 'string') {
                  if (!value && value !== 0) {
                      this.each(function () {
                          this.style.removeProperty(dasherize(property));
                      });
                  } else {
                      css = dasherize(property) + ":" + maybeAddPx(property, value);
                  }
              } else {
                  for (key in property) {
                      if (!property[key] && property[key] !== 0) {
                          for (i = 0; i < this.length; i++) {
                              this[i].style.removeProperty(dasherize(key));
                          }
                      } else {
                          css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
                      }
                  }
              }

              return this.each(function () {
                  this.style.cssText += ';' + css;
              });
          },
          each: function each(callback) {
              for (var i = 0; i < this.length; i++) {
                  if (callback.apply(this[i], [i, this[i]]) === false) {
                      break;
                  }
              }
              return this;
          },
          filter: function filter(callback) {
              var matchedItems = [];

              for (var i = 0; i < this.length; i++) {
                  if (isFunction(callback)) {
                      if (callback.call(this[i], i, this[i])) {
                          matchedItems.push(this[i]);
                      }
                  } else if ($.matches(this[i], callback)) {
                      matchedItems.push(this[i]);
                  }
              }

              return new Dom(matchedItems);
          },
          html: function html(_html) {
              if (typeof _html === 'undefined') {
                  return this[0] ? this[0].innerHTML : undefined;
              } else {
                  this.empty();
                  for (var i = 0; i < this.length; i++) {
                      this[i].innerHTML = _html;
                  }
                  return this;
              }
          },
          text: function text(_text) {
              if (typeof _text === 'undefined') {
                  return this[0] ? this[0].textContent.trim() : null;
              } else {
                  for (var i = 0; i < this.length; i++) {
                      this[i].textContent = _text;
                  }
                  return this;
              }
          },
          is: function is(selector) {
              return this.length > 0 && $.matches(this[0], selector);
          },
          not: function not(selector) {
              var nodes = [];
              if (isFunction(selector) && selector.call !== undefined) {
                  this.each(function (idx) {
                      if (!selector.call(this, idx)) {
                          nodes.push(this);
                      }
                  });
              } else {
                  var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);

                  if (isObject(excludes)) {
                      excludes = $.map(excludes, function (el) {
                          return el;
                      });
                  }

                  this.each(function (i, el) {
                      if (excludes.indexOf(el) < 0) {
                          nodes.push(el);
                      }
                  });
              }

              return $(nodes);
          },
          indexOf: function indexOf(el) {
              for (var i = 0; i < this.length; i++) {
                  if (this[i] === el) {
                      return i;
                  }
              }
          },
          index: function index(element) {
              return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
          },
          get: function get$$1(idx) {
              return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
          },
          eq: function eq(index) {
              if (typeof index === 'undefined') {
                  return this;
              }
              var length = this.length,
                  returnIndex;

              if (index > length - 1) {
                  return new Dom([]);
              }
              if (index < 0) {
                  returnIndex = length + index;
                  return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);
              }
              return new Dom([this[index]]);
          },
          append: function append(newChild) {
              var i, j;
              for (i = 0; i < this.length; i++) {
                  if (typeof newChild === 'string') {
                      var tempDiv = document.createElement('div');
                      tempDiv.innerHTML = newChild;
                      while (tempDiv.firstChild) {
                          this[i].appendChild(tempDiv.firstChild);
                      }
                  } else if (newChild instanceof Dom) {
                      for (j = 0; j < newChild.length; j++) {
                          this[i].appendChild(newChild[j]);
                      }
                  } else {
                      this[i].appendChild(newChild);
                  }
              }
              return this;
          },
          appendTo: function appendTo(parent) {
              $(parent).append(this);
              return this;
          },
          prepend: function prepend(newChild) {
              var i, j;
              for (i = 0; i < this.length; i++) {
                  if (typeof newChild === 'string') {
                      var tempDiv = document.createElement('div');
                      tempDiv.innerHTML = newChild;
                      for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
                          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                      }
                      // this[i].insertAdjacentHTML('afterbegin', newChild);
                  } else if (newChild instanceof Dom) {
                      for (j = 0; j < newChild.length; j++) {
                          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                      }
                  } else {
                      this[i].insertBefore(newChild, this[i].childNodes[0]);
                  }
              }
              return this;
          },
          prependTo: function prependTo(parent) {
              $(parent).prepend(this);
              return this;
          },
          insertBefore: function insertBefore(selector) {
              var before = $(selector);

              for (var i = 0; i < this.length; i++) {
                  if (before.length === 1) {
                      before[0].parentNode.insertBefore(this[i], before[0]);
                  } else if (before.length > 1) {
                      for (var j = 0; j < before.length; j++) {
                          before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
                      }
                  }
              }
              return this;
          },
          insertAfter: function insertAfter(selector) {
              var after = $(selector);
              for (var i = 0; i < this.length; i++) {
                  if (after.length === 1) {
                      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
                  } else if (after.length > 1) {
                      for (var j = 0; j < after.length; j++) {
                          after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
                      }
                  }
              }

              return this;
          },
          next: function next(selector) {
              if (this.length > 0) {
                  if (selector) {
                      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                          return new Dom([this[0].nextElementSibling]);
                      } else {
                          return new Dom([]);
                      }
                  } else {
                      if (this[0].nextElementSibling) {
                          return new Dom([this[0].nextElementSibling]);
                      } else {
                          return new Dom([]);
                      }
                  }
              } else {
                  return new Dom([]);
              }
          },
          nextAll: function nextAll(selector) {
              var nextEls = [],
                  el = this[0];

              if (!el) {
                  return new Dom([]);
              }
              while (el.nextElementSibling) {
                  var next = el.nextElementSibling;
                  if (selector) {
                      if ($(next).is(selector)) {
                          nextEls.push(next);
                      }
                  } else {
                      nextEls.push(next);
                  }
                  el = next;
              }
              return new Dom(nextEls);
          },
          prev: function prev(selector) {
              if (this.length > 0) {
                  if (selector) {
                      if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {
                          return new Dom([this[0].previousElementSibling]);
                      } else {
                          return new Dom([]);
                      }
                  } else {
                      if (this[0].previousElementSibling) {
                          return new Dom([this[0].previousElementSibling]);
                      } else {
                          return new Dom([]);
                      }
                  }
              } else {
                  return new Dom([]);
              }
          },
          prevAll: function prevAll(selector) {
              var prevEls = [];
              var el = this[0];
              if (!el) {
                  return new Dom([]);
              }
              while (el.previousElementSibling) {
                  var prev = el.previousElementSibling;
                  if (selector) {
                      if ($(prev).is(selector)) {
                          prevEls.push(prev);
                      }
                  } else {
                      prevEls.push(prev);
                  }
                  el = prev;
              }
              return new Dom(prevEls);
          },
          parent: function parent(selector) {
              var parents = [];
              for (var i = 0; i < this.length; i++) {
                  if (this[i].parentNode !== null) {
                      if (selector) {
                          if ($(this[i].parentNode).is(selector)) {
                              parents.push(this[i].parentNode);
                          }
                      } else {
                          parents.push(this[i].parentNode);
                      }
                  }
              }
              return $($.unique(parents));
          },
          parents: function parents(selector) {
              var parents = [];
              for (var i = 0; i < this.length; i++) {
                  var parent = this[i].parentNode;
                  while (parent) {
                      if (selector) {
                          if ($(parent).is(selector)) {
                              parents.push(parent);
                          }
                      } else {
                          parents.push(parent);
                      }
                      parent = parent.parentNode;
                  }
              }
              return $($.unique(parents));
          },
          find: function find(selector) {
              var foundElements = [];
              for (var i = 0; i < this.length; i++) {
                  var found = this[i].querySelectorAll(selector);
                  for (var j = 0; j < found.length; j++) {
                      foundElements.push(found[j]);
                  }
              }
              return new Dom(foundElements);
          },
          children: function children(selector) {
              var children = [];
              for (var i = 0; i < this.length; i++) {
                  var childNodes = this[i].childNodes;

                  for (var j = 0; j < childNodes.length; j++) {
                      if (!selector) {
                          if (childNodes[j].nodeType === 1) {
                              children.push(childNodes[j]);
                          }
                      } else {
                          if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
                              children.push(childNodes[j]);
                          }
                      }
                  }
              }

              return new Dom($.unique(children));
          },
          remove: function remove() {
              for (var i = 0; i < this.length; i++) {
                  if (this[i].parentNode) {
                      this[i].parentNode.removeChild(this[i]);
                  }
              }
              return this;
          },
          add: function add() {
              var dom = this;
              var i, j;
              for (i = 0; i < arguments.length; i++) {
                  var toAdd = $(arguments[i]);
                  for (j = 0; j < toAdd.length; j++) {
                      dom[dom.length] = toAdd[j];
                      dom.length++;
                  }
              }
              return dom;
          },
          before: function before(elm) {
              $(elm).insertBefore(this);
              return this;
          },
          after: function after(elm) {
              $(elm).insertAfter(this);
              return this;
          },
          scrollTop: function scrollTop(value) {
              if (!this.length) {
                  return;
              }
              var hasScrollTop = 'scrollTop' in this[0];

              if (value === undefined) {
                  return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
              }
              return this.each(hasScrollTop ? function () {
                  this.scrollTop = value;
              } : function () {
                  this.scrollTo(this.scrollX, value);
              });
          },
          scrollLeft: function scrollLeft(value) {
              if (!this.length) {
                  return;
              }
              var hasScrollLeft = 'scrollLeft' in this[0];

              if (value === undefined) {
                  return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
              }
              return this.each(hasScrollLeft ? function () {
                  this.scrollLeft = value;
              } : function () {
                  this.scrollTo(value, this.scrollY);
              });
          },
          contents: function contents() {
              return this.map(function (i, v) {
                  return _slice.call(v.childNodes);
              });
          },
          nextUntil: function nextUntil(selector) {
              var n = this,
                  array = [];

              while (n.length && !n.filter(selector).length) {
                  array.push(n[0]);
                  n = n.next();
              }

              return $(array);
          },
          prevUntil: function prevUntil(selector) {
              var n = this,
                  array = [];

              while (n.length && !$(n).filter(selector).length) {
                  array.push(n[0]);
                  n = n.prev();
              }

              return $(array);
          },
          detach: function detach() {
              return this.remove();
          }
      };

      // Link to prototype
      $.fn = Dom.prototype;

      return $;
  }();

  // Export to local scope
  var $$1 = Dom;

  // Export to mobiscroll
  mobiscroll$3.$ = Dom;

  // DOM Library Utilites
  $$1.inArray = function (elem, array, i) {
      return emptyArray.indexOf.call(array, elem, i);
  };

  $$1.extend = function (target) {
      var deep,
          args = _slice.call(arguments, 1);

      if (typeof target == 'boolean') {
          deep = target;
          target = args.shift();
      }

      target = target || {};

      args.forEach(function (arg) {
          extend(target, arg, deep);
      });

      return target;
  };

  $$1.isFunction = isFunction;

  $$1.isArray = function (arr) {
      return Object.prototype.toString.apply(arr) === '[object Array]';
  };

  $$1.isPlainObject = function (obj) {
      return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;
  };

  $$1.each = function (obj, callback) {
      var i, prop;

      if (!isObject(obj) || !callback) {
          return;
      }

      if ($$1.isArray(obj) || obj instanceof Dom) {
          // Array
          for (i = 0; i < obj.length; i++) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
              }
          }
      } else {
          // Object
          for (prop in obj) {
              if (obj.hasOwnProperty(prop) && prop !== 'length') {
                  if (callback.call(obj[prop], prop, obj[prop]) === false) {
                      break;
                  }
              }
          }
      }

      return this;
  };

  $$1.unique = function (arr) {
      var unique = [];
      for (var i = 0; i < arr.length; i++) {
          if (unique.indexOf(arr[i]) === -1) {
              unique.push(arr[i]);
          }
      }
      return unique;
  };

  $$1.map = function (elements, callback) {
      var value,
          values = [],
          i,
          key;
      if (likeArray(elements)) {
          for (i = 0; i < elements.length; i++) {
              value = callback(elements[i], i);
              if (value !== null) {
                  values.push(value);
              }
          }
      } else {
          for (key in elements) {
              value = callback(elements[key], key);
              if (value !== null) {
                  values.push(value);
              }
          }
      }

      return values.length > 0 ? $$1.fn.concat.apply([], values) : values;
  };

  $$1.matches = function (element, selector) {
      if (!selector || !element || element.nodeType !== 1) {
          return false;
      }

      var matchesSelector = element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;

      return matchesSelector.call(element, selector);
  };

  var os;
  var vers;
  var majorVersion;
  var minorVersion;
  var version = [];
  var isBrowser = typeof window !== 'undefined';
  var userAgent = isBrowser ? navigator.userAgent : '';
  var isSafari = /Safari/.test(userAgent);
  var device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i);
  var raf = isBrowser && window.requestAnimationFrame || function (func) {
      return setTimeout(func, 20);
  };
  var rafc = isBrowser && window.cancelAnimationFrame || function (id) {
      clearTimeout(id);
  };

  if (/Android/i.test(device)) {
      os = 'android';
      vers = userAgent.match(/Android\s+([\d\.]+)/i);
      if (vers) {
          version = vers[0].replace('Android ', '').split('.');
      }
  } else if (/iPhone|iPad|iPod/i.test(device)) {
      os = 'ios';
      vers = userAgent.match(/OS\s+([\d\_]+)/i);
      if (vers) {
          version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');
      }
  } else if (/Windows Phone/i.test(device)) {
      os = 'wp';
  } else if (/Windows|MSIE/i.test(device)) {
      os = 'windows';
  }

  majorVersion = version[0];
  minorVersion = version[1];

  function noop() {}

  function isString(s) {
      return typeof s === 'string';
  }

  function constrain(val, min, max) {
      return Math.max(min, Math.min(val, max));
  }

  function vibrate(time) {
      if ('vibrate' in navigator) {
          navigator.vibrate(time || 50);
      }
  }

  function getPercent(v, min, max) {
      return (v - min) * 100 / (max - min);
  }

  function getBoolAttr(attr, def, $elm) {
      var v = $elm.attr(attr);
      return v === undefined || v === '' ? def : v === 'true';
  }

  var tapped = 0;
  var allowQuick = void 0;

  function preventClick() {
      // Prevent ghost click
      tapped++;
      setTimeout(function () {
          tapped--;
      }, 500);
  }

  function triggerClick(ev, control) {
      // Prevent duplicate triggers on the same element
      // e.g. a form checkbox inside a listview item
      if (control.mbscClick) {
          return;
      }

      var touch = (ev.originalEvent || ev).changedTouches[0],
          evt = document.createEvent('MouseEvents');

      evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
      evt.isMbscTap = true;
      // Prevent ionic to bust our click
      // This works for Ionic 1 - 3, not sure about 4
      evt.isIonicTap = true;

      // This will allow a click fired together with this click
      // We need this, because clicking on a label will trigger a click
      // on the associated input as well, which should not be busted
      allowQuick = true;

      control.mbscChange = true;
      control.mbscClick = true;
      control.dispatchEvent(evt);

      allowQuick = false;

      // Prevent ghost click
      preventClick();

      setTimeout(function () {
          delete control.mbscClick;
      });
  }

  function getCoord(e, c, page) {
      var ev = e.originalEvent || e,
          prop = (page ? 'page' : 'client') + c;

      // Multi touch support
      if (ev.targetTouches && ev.targetTouches[0]) {
          return ev.targetTouches[0][prop];
      }

      if (ev.changedTouches && ev.changedTouches[0]) {
          return ev.changedTouches[0][prop];
      }

      return e[prop];
  }

  function getControlType($elm) {
      var attrs = ['switch', 'range', 'rating', 'segmented', 'stepper'];
      var elm = $elm[0];
      var role = $elm.attr('data-role');

      var type = $elm.attr('type') || elm.nodeName.toLowerCase();

      if (/(switch|range|rating|segmented|stepper|select)/.test(role)) {
          type = role;
      } else {
          for (var i = 0; i < attrs.length; i++) {
              if ($elm.is('[mbsc-' + attrs[i] + ']')) {
                  type = attrs[i];
              }
          }
      }

      return type;
  }

  function activateControl(control, type, ev) {
      control.focus();

      if (/(button|submit|checkbox|switch|radio)/.test(type)) {
          ev.preventDefault();
      }

      if (!/select/.test(type)) {
          triggerClick(ev, control);
      }
  }

  function tap(that, el, handler, prevent, tolerance, time) {
      var startX,
          startY,
          target,
          moved,
          startTime,
          $ = mobiscroll$3.$,
          $elm = $(el);

      tolerance = tolerance || 9;

      function onStart(ev) {
          if (!target) {
              // Can't always call preventDefault here, it kills page scroll
              if (prevent) {
                  ev.preventDefault();
              }
              target = this;
              startX = getCoord(ev, 'X');
              startY = getCoord(ev, 'Y');
              moved = false;
              startTime = new Date();
          }
      }

      function onMove(ev) {
          // If movement is more than 20px, don't fire the click event handler
          if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {
              moved = true;
          }
      }

      function onEnd(ev) {
          if (target) {
              if (time && new Date() - startTime < 100 || !moved) {
                  // ev.preventDefault();
                  // handler.call(target, ev, that);
                  triggerClick(ev, ev.target);
              } else {
                  preventClick();
              }

              target = false;
          }
      }

      function onCancel() {
          target = false;
      }

      if (that.settings.tap) {
          $elm.on('touchstart.mbsc', onStart).on('touchcancel.mbsc', onCancel).on('touchmove.mbsc', onMove).on('touchend.mbsc', onEnd);
      }

      $elm.on('click.mbsc', function (ev) {
          if (prevent) {
              ev.preventDefault();
          }
          // If handler was not called on touchend, call it on click;
          handler.call(this, ev, that);
      });
  }

  // Prevent standard behaviour on body click
  function bustClick(ev) {
      // Textarea needs the mousedown event
      if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {
          ev.stopPropagation();
          ev.preventDefault();
          return false;
      }
  }

  if (isBrowser) {
      ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {
          document.addEventListener(ev, bustClick, true);
      });

      if (os == 'android' && majorVersion < 5) {
          document.addEventListener('change', function (ev) {
              if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {
                  ev.stopPropagation();
                  ev.preventDefault();
              }
              delete ev.target.mbscChange;
          }, true);
      }
  }

  /*!
   * Mobiscroll v4.8.4
   * http://mobiscroll.com
   * 
   *
   * Copyright 2010-2018, Acid Media
   *
   */

  function autoInit(selector, Component, hasRefresh) {
      if (isBrowser) {
          $$2(function () {

              $$2(selector).each(function () {
                  new Component(this, {});
              });

              $$2(document).on('mbsc-enhance', function (ev, settings) {
                  if ($$2(ev.target).is(selector)) {
                      new Component(ev.target, settings || {});
                  } else {
                      $$2(selector, ev.target).each(function () {
                          new Component(this, settings || {});
                      });
                  }
              });

              if (hasRefresh) {
                  $$2(document).on('mbsc-refresh', function (ev) {
                      var inst;

                      if ($$2(ev.target).is(selector)) {
                          inst = instances[ev.target.id];
                          if (inst) {
                              inst.refresh();
                          }
                      } else {
                          $$2(selector, ev.target).each(function () {
                              inst = instances[this.id];
                              if (inst) {
                                  inst.refresh();
                              }
                          });
                      }
                  });
              }
          });
      }
  }

  var ms;
  var $$2 = mobiscroll$3.$;
  var id = +new Date();
  var instances = {};
  var classes = {};
  var breakpoints = {
      xsmall: 0,
      small: 576,
      medium: 768,
      large: 992,
      xlarge: 1200
  };
  var extend$1 = $$2.extend;

  extend$1(util, {
      getCoord: getCoord,
      preventClick: preventClick,
      vibrate: vibrate
  });

  ms = extend$1(mobiscroll$3, {
      $: $$2,
      version: '4.8.4',
      autoTheme: 'mobiscroll',
      themes: {
          form: {},
          page: {},
          frame: {},
          scroller: {},
          listview: {},
          navigation: {},
          progress: {},
          card: {}
      },
      platform: {
          name: os,
          majorVersion: majorVersion,
          minorVersion: minorVersion
      },
      i18n: {},
      instances: instances,
      classes: classes,
      util: util,
      settings: {},
      setDefaults: function setDefaults(o) {
          extend$1(this.settings, o);
      },
      customTheme: function customTheme(name, baseTheme) {
          var i,
              themes = mobiscroll$3.themes,
              comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];

          for (i = 0; i < comps.length; i++) {
              themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {
                  baseTheme: baseTheme
              });
          }
      }
  });

  var Base = function Base(el, settings) {
      var ctx,
          lang,
          preset,
          resp,
          s,
          theme,
          themeName,
          trigger,
          defaults$$1,
          that = this;

      that.settings = {};

      that.element = el;

      that._init = noop;

      that._destroy = noop;

      that._processSettings = noop;

      that._checkResp = function (width) {
          if (that && that._responsive) {
              var newResp = getResponsiveSettings(width);
              if (resp !== newResp) {
                  resp = newResp;
                  that.init({});
                  return true;
              }
          }
      };

      that.init = function (newSettings, newValue) {
          var key, value;

          // In case of settings update save the old value
          if (newSettings && that.getVal) {
              value = that.getVal();
          }

          // Reset settings object
          for (key in that.settings) {
              delete that.settings[key];
          }

          s = that.settings;

          // Update original user settings
          extend$1(settings, newSettings);

          // Load user defaults
          if (that._hasDef) {
              defaults$$1 = ms.settings;
          }

          // Create settings object
          extend$1(s, that._defaults, defaults$$1, settings);

          // Get theme defaults
          if (that._hasTheme) {

              themeName = s.theme;

              if (themeName == 'auto' || !themeName) {
                  themeName = ms.autoTheme;
              }

              if (themeName == 'default') {
                  themeName = 'mobiscroll';
              }

              settings.theme = themeName;

              theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};
          }

          // Get language defaults
          if (that._hasLang) {
              lang = ms.i18n[s.lang];
          }

          // Update settings object
          extend$1(s, theme, lang, defaults$$1, settings);

          ctx = $$2(s.context)[0];

          if (that._responsive) {
              if (!resp) {
                  resp = getResponsiveSettings();
              }
              extend$1(s, resp);
          }

          that._processSettings(resp || {});

          // Load preset settings
          if (that._presets) {

              preset = that._presets[s.preset];

              if (preset) {
                  preset = preset.call(el, that, settings);
                  extend$1(s, preset, settings, resp);
              }
          }

          that._init(newSettings);

          // In case of settings update reset the value.
          // This is needed to adapt the value for the updated settings
          // E.g. min/max, date format, etc.
          if (newSettings && that.setVal) {
              that.setVal(newValue === undefined ? value : newValue, true);
          }

          trigger('onInit');
      };

      that.destroy = function () {
          if (that) {
              that._destroy();
              trigger('onDestroy');

              // Delete scroller instance
              delete instances[el.id];

              that = null;
          }
      };

      /**
       * Attach tap event to the given element.
       */
      that.tap = function (el, handler, prevent, tolerance, time) {
          tap(that, el, handler, prevent, tolerance, time);
      };

      /**
       * Triggers an event
       */
      that.trigger = function (name, ev) {
          var ret,
              i,
              v,
              s = [defaults$$1, theme, preset, settings];

          for (i = 0; i < 4; i++) {
              v = s[i];
              if (v && v[name]) {
                  ret = v[name].call(el, ev || {}, that);
              }
          }

          return ret;
      };

      /**
       * Sets one ore more options.
       */
      that.option = function (opt, value, newValue) {
          var obj = {},

          // preserve settings that are possible to change runtime
          dynamic = ['data', 'invalid', 'valid', 'readonly'];

          if (/calendar|eventcalendar|range/.test(s.preset)) {
              dynamic.push('marked', 'labels', 'colors');
          }

          if ((typeof opt === 'undefined' ? 'undefined' : _typeof(opt)) === 'object') {
              obj = opt;
          } else {
              obj[opt] = value;
          }

          dynamic.forEach(function (v) {
              settings[v] = s[v];
          });

          that.init(obj, newValue);
      };

      /**
       * Returns the mobiscroll instance.
       */
      that.getInst = function () {
          return that;
      };

      settings = settings || {};
      trigger = that.trigger;

      function getResponsiveSettings(w) {
          var resp, width;

          if (s.responsive) {
              width = w || ctx.offsetWidth;
              $$2.each(s.responsive, function (key, value) {
                  if (width >= (value.breakpoint || breakpoints[key])) {
                      resp = value;
                  }
              });
          }
          return resp;
      }

      function construct() {
          $$2(el).addClass('mbsc-comp');

          // Autogenerate id
          if (!el.id) {
              el.id = 'mobiscroll' + ++id;
          } else if (instances[el.id]) {
              instances[el.id].destroy();
          }

          // Save instance
          instances[el.id] = that;
          that.__ready = true;
      }

      if (!that.__ready) {
          construct();
      }
  };

  var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
              }
          }
      }return target;
  };

  var _class;
  var _temp;
  var _class2;
  var _temp2;

  function _objectWithoutProperties(obj, keys) {
      var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
      }return target;
  }

  var boolType = PropTypes.bool;
  var stringType = PropTypes.string;
  var funcType = PropTypes.func;
  var numType = PropTypes.number;
  var objType = PropTypes.object;
  var dateType = PropTypes.oneOfType([objType, stringType]);
  var numOrArray = PropTypes.oneOfType([numType, PropTypes.arrayOf(numType)]);

  /** Mixin for enumerating the core PropTypes */
  var CorePropTypes = {
      theme: stringType,
      lang: stringType,
      rtl: boolType,
      responsive: objType,
      context: PropTypes.oneOfType([stringType, objType])
  };

  var FramePropTypes = {
      anchor: PropTypes.oneOfType([stringType, objType]),
      animate: PropTypes.oneOfType([boolType, PropTypes.oneOf(['fade', 'flip', 'pop', 'swing', 'slidevertical', 'slidehorizontal', 'slidedown', 'slideup'])]),
      buttons: PropTypes.array,
      closeOnOverlayTap: boolType,
      cssClass: stringType,
      disabled: boolType,
      display: PropTypes.oneOf(['top', 'bottom', 'bubble', 'inline', 'center']),
      focusOnClose: PropTypes.oneOfType([boolType, stringType, objType]),
      focusTrap: boolType,
      headerText: PropTypes.oneOfType([boolType, stringType, funcType]),
      layout: PropTypes.oneOf(['liquid', 'fixed']),
      scrollLock: boolType,
      showOnFocus: boolType,
      showOnTap: boolType,
      showOnOverlay: boolType,
      touchUi: boolType,
      onBeforeClose: funcType,
      onBeforeShow: funcType,
      onCancel: funcType,
      onClose: funcType,
      onDestroy: funcType,
      onMarkupReady: funcType,
      onPosition: funcType,
      onShow: funcType
  };

  var ScrollerPropTypes = {
      circular: PropTypes.oneOfType([boolType, PropTypes.arrayOf(boolType)]),
      height: numType,
      maxWidth: numOrArray,
      minWidth: numOrArray,
      multiline: numType,
      readOnly: PropTypes.oneOfType([boolType, PropTypes.arrayOf(boolType)]),
      rows: numType,
      showLabel: boolType,
      showScrollArrows: boolType,
      wheels: PropTypes.array,
      width: numType,
      onChange: funcType,
      validate: funcType,
      onSet: funcType,
      onItemTap: funcType,
      onClear: funcType,
      cancelText: stringType,
      clearText: stringType,
      selectedText: stringType,
      setText: stringType,
      formatValue: funcType,
      parseValue: funcType
  };

  var DatetimePropTypes = {
      defaultValue: dateType,
      invalid: PropTypes.array,
      max: dateType,
      min: dateType,
      returnFormat: PropTypes.oneOf(['iso8601', 'moment', 'locale', 'jsdate']),
      steps: PropTypes.shape({
          hour: numType,
          minute: numType,
          second: numType,
          zeroBased: boolType
      }),
      valid: PropTypes.array,
      calendarSystem: PropTypes.oneOf(['jalali', 'hijri', 'gregorian']),
      ampmText: stringType,
      amText: stringType,
      dateFormat: stringType,
      dateWheels: stringType,
      dayNames: PropTypes.arrayOf(stringType),
      dayNamesShort: PropTypes.arrayOf(stringType),
      dayText: stringType,
      hourText: stringType,
      minuteText: stringType,
      monthNames: PropTypes.arrayOf(stringType),
      monthNamesShort: PropTypes.arrayOf(stringType),
      monthSuffix: stringType,
      monthText: stringType,
      nowText: stringType,
      pmText: stringType,
      secText: stringType,
      timeFormat: stringType,
      timeWheels: stringType,
      yearSuffix: stringType,
      yearText: stringType
  };

  var CalbasePropTypes = {
      calendarHeight: numType,
      calendarScroll: PropTypes.oneOf(['horizontal', 'vertical']),
      calendarWidth: numType,
      counter: boolType,
      defaultValue: PropTypes.oneOfType([dateType, PropTypes.array]),
      events: PropTypes.arrayOf(PropTypes.shape({
          start: dateType,
          end: dateType,
          d: PropTypes.oneOfType([objType, numType, stringType]),
          text: stringType,
          color: stringType,
          background: stringType,
          cssClass: stringType
      })),
      labels: PropTypes.arrayOf(PropTypes.shape({
          start: dateType,
          end: dateType,
          d: PropTypes.oneOfType([objType, numType, stringType]),
          text: stringType,
          color: stringType,
          background: stringType,
          cssClass: stringType
      })),
      marked: PropTypes.arrayOf(PropTypes.oneOfType([objType, numType, stringType, PropTypes.shape({
          d: PropTypes.oneOfType([objType, stringType, numType]),
          color: stringType,
          background: stringType,
          cssClass: stringType
      })])),
      colors: PropTypes.arrayOf(PropTypes.shape({
          d: PropTypes.oneOfType([objType, stringType, numType]),
          background: stringType,
          cssClass: stringType
      })),
      months: numType,
      mousewheel: boolType,
      weeks: numType,
      outerMonthChange: boolType,
      showOuterDays: boolType,
      tabs: boolType,
      weekCounter: PropTypes.oneOf(['year', 'month']),
      weekDays: PropTypes.oneOf(['full', 'short', 'min']),
      yearChange: boolType,
      dateText: stringType,
      dayNames: PropTypes.arrayOf(stringType),
      dayNamesMin: PropTypes.arrayOf(stringType),
      firstDay: numType,
      timeText: stringType,
      moreEventsPluralText: stringType,
      moreEventsText: stringType,
      onTabChange: funcType,
      onDayChange: funcType,
      onLabelTap: funcType,
      onMonthChange: funcType,
      onMonthLoading: funcType,
      onMonthLoaded: funcType,
      onPageChange: funcType,
      onPageLoading: funcType,
      onPageLoaded: funcType,
      onSetDate: funcType
  };

  function updateCssClasses(currentClasses, nextClasses) {
      var node = ReactDOM.findDOMNode(this);
      var currentNormal = currentClasses.replace(/\s+/g, ' ').trim();
      var nextNormal = nextClasses.replace(/\s+/g, ' ').trim();
      if (currentNormal) {
          node.classList.remove.apply(node.classList, currentNormal.split(' '));
      }
      if (nextNormal) {
          node.classList.add.apply(node.classList, nextNormal.split(' '));
      }
  }

  function deepCompare(a, b) {
      var leftChain = [],
          rightChain = [];

      function compare2Objects(x, y, reactElement) {
          var p;

          // remember that NaN === NaN returns false
          // and isNaN(undefined) returns true
          if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {
              return true;
          }

          // Compare primitives and functions.     
          // Check if both arguments link to the same object.
          // Especially useful on step when comparing prototypes
          if (x === y) {
              return true;
          } else if (typeof x === 'function' && typeof y === 'function') {
              return false;
          }

          // Works in case when functions are created in constructor.
          // Comparing dates is a common scenario. Another built-ins?
          // We can even handle functions passed across iframes
          if (x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || x instanceof String && y instanceof String || x instanceof Number && y instanceof Number) {
              return x.toString() === y.toString();
          }

          // At last checking prototypes as good a we can
          if (!(x instanceof Object && y instanceof Object)) {
              return false;
          }

          if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {
              return false;
          }

          if (x.constructor !== y.constructor) {
              return false;
          }

          if (x.prototype !== y.prototype) {
              return false;
          }

          // Check for infinitive linking loops
          if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {
              return false;
          }

          // Quick checking of one object beeing a subset of another.
          // todo: cache the structure of arguments[0] for performance
          for (p in y) {
              if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                  return false;
              } else if (_typeof(y[p]) !== _typeof(x[p])) {
                  return false;
              }
          }

          var elementProps = {
              '$$typeof': 1,
              'key': 1,
              'props': 1,
              'ref': 1,
              'type': 1
          };
          var props = reactElement ? elementProps : x;
          for (p in props) {
              if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                  return false;
              } else if (_typeof(y[p]) !== _typeof(x[p])) {
                  return false;
              }

              switch (_typeof(x[p])) {
                  case 'object':
                  case 'function':
                      leftChain.push(x);
                      rightChain.push(y);

                      if (!compare2Objects(x[p], y[p], x[p] && x[p].$$typeof !== undefined)) {
                          return false;
                      }

                      leftChain.pop();
                      rightChain.pop();
                      break;

                  default:
                      if (x[p] !== y[p]) {
                          return false;
                      }
                      break;
              }
          }
          return true;
      }

      return compare2Objects(a, b);
  }

  var MbscInit = function (_React$Component) {
      inherits(MbscInit, _React$Component);

      function MbscInit(props) {
          classCallCheck(this, MbscInit);

          // the initial css class will not change this way, and wont trigger any re-render. We will handle the className changes in the componentWillReceive function
          // Note: every render function should use the this.initialCssClass instead of passing through the className prop 
          var _this = possibleConstructorReturn(this, (MbscInit.__proto__ || Object.getPrototypeOf(MbscInit)).call(this, props));

          _this.initialCssClass = _this.props.className || '';
          return _this;
      }

      // Dummy render function


      createClass(MbscInit, [{
          key: 'render',
          value: function render() {
              return null;
          }

          // generates the mobiscroll options object based on the props passed

      }, {
          key: 'getSettingsFromProps',
          value: function getSettingsFromProps(props, extra) {
              var optionObj = {};
              if (props !== undefined) {
                  // support individual properties and options object property for settings
                  // the value should not be part of the options object
                  // data should not be part of the options object 

                  /* eslint-disable no-unused-vars */
                  // justification: the variables 'value', 'data', 'children' and 'className' are declared due to object decomposition
                  var options = props.options,
                      children = props.children,
                      value = props.value,
                      checked = props.checked,
                      data = props.data,
                      className = props.className,
                      other = _objectWithoutProperties(props, ['options', 'children', 'value', 'checked', 'data', 'className']);

                  /* eslint-enable no-unused-vars */

                  var optionStr = options || '{}';
                  optionObj = options || {};
                  if (options !== undefined && typeof optionStr === 'string') {
                      // when options are passed as string we need to create an object from it
                      optionObj = new Function('return ' + optionStr + ';')();
                  }

                  // the priority of the options passed (later will have higher prio): 
                  // 1. options property
                  // 2. individual properties
                  optionObj = extend$1({}, optionObj, other, extra || {});
              }
              return optionObj;
          }

          // cleans up on unmount

      }, {
          key: 'componentWillUnmount',
          value: function componentWillUnmount() {
              this.instance.destroy();
              // Also need to delete reference to the instance
              delete this.instance;
          }
      }]);
      return MbscInit;
  }(React.Component);

  /** The base class for the mobiscroll components
   * Generates the Mobiscroll options object from the react component properties
   * Setting initial state 
   * Updating state based on new props 
   * Updating mobiscroll based on state */
  var MbscBase = function (_MbscInit) {
      inherits(MbscBase, _MbscInit);

      function MbscBase(props) {
          classCallCheck(this, MbscBase);

          var _this2 = possibleConstructorReturn(this, (MbscBase.__proto__ || Object.getPrototypeOf(MbscBase)).call(this, props));

          _this2.updateForIonInput = _this2.updateForIonInput.bind(_this2);
          return _this2;
      }

      createClass(MbscBase, [{
          key: 'updateForIonInput',
          value: function updateForIonInput() {
              if (this.valueState) {
                  this.optimizeUpdate = null;
                  this.forceUpdate();
              }
          }
      }, {
          key: 'isIonInput',
          value: function isIonInput(children) {
              return children && React.Children.count(children) == 1 && children.type && children.type.render && children.type.render.displayName === 'IonInput';
          }

          // updates mobiscroll with new options

      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              var settings = this.getSettingsFromProps(this.props);
              if (this.optimizeUpdate) {
                  if (this.optimizeUpdate.updateOptions) {
                      this.instance.option(settings);
                  }
                  if (this.optimizeUpdate.updateValue && this.props.value !== undefined && !deepCompare(this.props.value, this.instance.getVal())) {
                      this.instance.setVal(this.props.value, true);
                  }
                  this.updateForIonInput();
              } else if (this.optimizeUpdate !== null) {
                  this.instance.option(settings);
                  if (this.props.value !== undefined) {
                      this.instance.setVal(this.props.value, true);
                  }
              }
          }
      }]);
      return MbscBase;
  }(MbscInit);

  var MbscOptimized = function (_MbscBase) {
      inherits(MbscOptimized, _MbscBase);

      function MbscOptimized(props) {
          classCallCheck(this, MbscOptimized);
          return possibleConstructorReturn(this, (MbscOptimized.__proto__ || Object.getPrototypeOf(MbscOptimized)).call(this, props));
      }

      createClass(MbscOptimized, [{
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps) {
              var nextOptions = this.getSettingsFromProps(nextProps);
              var thisOptions = this.getSettingsFromProps(this.props);
              // check if the options or the value changed
              var updateOptions = !deepCompare(nextOptions, thisOptions),
                  updateValue = !deepCompare(nextProps.value, this.props.value),
                  updateChildren = !deepCompare(nextProps.children, this.props.children);
              // save what should be updated inside mobiscroll
              this.optimizeUpdate = {
                  updateOptions: updateOptions,
                  updateValue: updateValue,
                  updateChildren: updateChildren
              };
              // component should update if the options or the value changed
              var shouldUpdate = updateOptions || updateValue || updateChildren;
              return shouldUpdate;
          }
      }]);
      return MbscOptimized;
  }(MbscBase);

  /** Class for the generic mobiscroll components */
  var MbscInputBase = (_temp = _class = function (_MbscOptimized) {
      inherits(MbscInputBase, _MbscOptimized);

      function MbscInputBase() {
          classCallCheck(this, MbscInputBase);
          return possibleConstructorReturn(this, (MbscInputBase.__proto__ || Object.getPrototypeOf(MbscInputBase)).apply(this, arguments));
      }

      createClass(MbscInputBase, [{
          key: 'render',
          value: function render() {
              // passing through some of the element properties to its children
              var _props = this.props,
                  type = _props.type,
                  readOnly = _props.readOnly,
                  disabled = _props.disabled,
                  placeholder = _props.placeholder,
                  children = _props.children;

              // default input type if there are no children components

              type = type || "text";

              if (this.isIonInput(children)) {
                  this.valueState = true;
                  var val = this.instance ? this.instance._value : '';
                  return React.cloneElement(children, _extends({ value: val }, children.props));
              }

              // default to input if there are no childrens
              if (children) {
                  return this.props.children;
              } else {
                  return React.createElement('input', { className: this.initialCssClass, type: type, readOnly: readOnly, disabled: disabled, placeholder: placeholder });
              }
          }
      }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
              // get settings from state
              var settings = this.getSettingsFromProps(this.props, this.mbscInit);
              // initialize the mobiscroll
              var element = ReactDOM.findDOMNode(this);
              var input = $$2(element).find('input');
              if (input.length) {
                  element = input[0];
              }

              this.instance = new classes[this.mbscInit.component || 'Scroller'](element, settings);
              if (this.props.value !== undefined) {
                  this.instance.setVal(this.props.value, true);
                  this.updateForIonInput();
              }
          }
      }]);
      return MbscInputBase;
  }(MbscOptimized), _class.propTypes = _extends({}, CorePropTypes, FramePropTypes, {
      type: PropTypes.string,
      placeholder: PropTypes.string
  }), _temp);

  /** Class for the list based mobiscroll components */
  var MbscListsBase = (_temp2 = _class2 = function (_MbscOptimized2) {
      inherits(MbscListsBase, _MbscOptimized2);

      function MbscListsBase() {
          classCallCheck(this, MbscListsBase);
          return possibleConstructorReturn(this, (MbscListsBase.__proto__ || Object.getPrototypeOf(MbscListsBase)).apply(this, arguments));
      }

      createClass(MbscListsBase, [{
          key: 'render',
          value: function render() {
              return React.createElement('ul', { className: this.initialCssClass + ' mbsc-cloak' }, this.props.children);
          }
      }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
              // get settings from state
              var settings = this.getSettingsFromProps(this.props, this.mbscInit);
              // get the DOM node
              var DOMNode = ReactDOM.findDOMNode(this);

              // initialize the mobiscroll
              this.instance = new classes[this.mbscInit.component || 'Scroller'](DOMNode, settings);

              if (this.props.value !== undefined) {
                  this.instance.setVal(this.props.value, true);
              }

              // Stop Propagation of click events to avoid the same data-reactid js error when inline mode
              // the _markup does not exist for components that are not derived from Mobiscroll Frame (listview, menustrip, forms)
              // we can use the original dom node for these non-frame components, because they dont clone the markup
              (this.instance._markup || $$2(DOMNode)).on('click', function (event) {
                  event.stopPropagation();
              });
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              if (!this.optimizeUpdate.updateOptions && this.optimizeUpdate.updateChildren) {
                  this.instance.option(this.getSettingsFromProps(this.props)); // the option needs to be called because of the children changes - the list components might need a refresh method
              }

              // Stop Propagation of click events to avoid the same data-reactid js error when inline mode
              // the _markup does not exist for components that are not derived from Mobiscroll Frame (listview, menustrip, forms)
              // we can use the original dom node for these non-frame components, because they dont clone the markup
              var DOMNode = ReactDOM.findDOMNode(this);
              (this.instance._markup || $$2(DOMNode)).on('click', function (event) {
                  event.stopPropagation();
              });
          }
      }]);
      return MbscListsBase;
  }(MbscOptimized), _class2.propTypes = _extends({}, CorePropTypes, FramePropTypes, ScrollerPropTypes), _temp2);

  function testProps(props) {
      var i;
      for (i in props) {
          if (mod[props[i]] !== undefined) {
              return true;
          }
      }
      return false;
  }

  function testPrefix() {
      var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
          p;

      for (p in prefixes) {
          if (testProps([prefixes[p] + 'Transform'])) {
              return '-' + prefixes[p].toLowerCase() + '-';
          }
      }
      return '';
  }

  function testTouch(e, elm) {
      if (e.type == 'touchstart') {
          $$2(elm).attr('data-touch', '1');
      } else if ($$2(elm).attr('data-touch')) {
          $$2(elm).removeAttr('data-touch');
          return false;
      }
      return true;
  }

  var animEnd;
  var mod;
  var cssPrefix;
  var hasGhostClick;
  var hasTransition;
  var jsPrefix;

  if (isBrowser) {
      mod = document.createElement('modernizr').style;
      cssPrefix = testPrefix();
      jsPrefix = cssPrefix.replace(/^\-/, '').replace(/\-$/, '').replace('moz', 'Moz');
      animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';
      hasTransition = mod.transition !== undefined;
      // UIWebView on iOS still has the ghost click, 
      // and it does not have Safari in the userAgent string, 
      // seems like it's fixed from 12.2, where the tap focus does not work
      // (keyboard appears, but text is not entered)
      hasGhostClick = mod.touchAction === undefined || os == 'ios' && !isSafari && (majorVersion < 12 || majorVersion == 12 && minorVersion < 2);
  }

  var wrapClass = 'mbsc-input-wrap';
  var events$1 = ['touchstart', 'touchmove', 'touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];
  var defaults$1 = {
      tap: hasGhostClick
  };

  var $active = void 0;

  function addIcon($control, ic) {
      var icons = {},
          control = $control[0],
          $parent = $control.parent(),
          errorMsg = $parent.find('.mbsc-err-msg'),
          align = $control.attr('data-icon-align') || 'left',
          icon = $control.attr('data-icon');

      if ($parent.hasClass(wrapClass)) {
          $parent = $parent.parent();
      } else {
          // Wrap input
          $$2('<span class="' + wrapClass + '"></span>').insertAfter($control).append($control);
      }

      if (errorMsg) {
          $parent.find('.' + wrapClass).append(errorMsg);
      }

      if (icon) {
          if (icon.indexOf('{') !== -1) {
              icons = JSON.parse(icon);
          } else {
              icons[align] = icon;
          }
      }

      if (control.type == 'file') {
          // Set icon
          icons.right = $control.attr('data-icon-upload') || 'upload';
      }

      if (icon || ic) {
          extend$1(icons, ic);

          $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append('<span class="mbsc-input-fill"></span>').append(icons.left ? '<span class="mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '"></span>' : '').append(icons.right ? '<span class="mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '"></span>' : '');
      }
  }

  function addIconToggle(that, $parent, $control) {
      var icons = {},
          control = $control[0],
          toggle = $control.attr('data-password-toggle'),
          iconShow = $control.attr('data-icon-show') || 'eye',
          iconHide = $control.attr('data-icon-hide') || 'eye-blocked';

      if (toggle) {
          icons.right = control.type == 'password' ? iconShow : iconHide;
      }

      addIcon($control, icons);

      if (toggle) {
          tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {
              if (control.type == "text") {
                  control.type = "password";
                  $$2(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);
              } else {
                  control.type = "text";
                  $$2(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);
              }
          });
      }
  }

  function wrapLabel($parent, type, inputStyle, labelStyle, elm) {
      // Wrap non-empty text nodes in span with mbsc-label class
      if (type == 'segmented') {
          $parent.closest('.mbsc-segmented').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '');
      } else if (type != 'button' && type != 'submit') {
          $parent.addClass('mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').addClass(labelStyle == 'inline' ? 'mbsc-label-inline' : '').addClass(labelStyle == 'stacked' ? 'mbsc-label-stacked' : '').addClass(labelStyle == 'floating' ? 'mbsc-label-floating' : '').addClass(labelStyle == 'floating' && elm.value ? 'mbsc-label-floating-active' : '').find('label').addClass('mbsc-label').each(function (i, v) {
              $$2(v).attr('title', $$2(v).text());
          });

          $parent.contents().filter(function () {
              return this.nodeType == 3 && this.nodeValue && /\S/.test(this.nodeValue);
          }).each(function () {
              $$2('<span class="mbsc-label" title="' + this.textContent.trim() + '"></span>').insertAfter(this).append(this);
          });
      }
  }

  function getRipple(theme) {
      var ripple = mobiscroll$3.themes.form[theme];
      return ripple && ripple.addRipple ? ripple : null;
  }

  function getAttr($elm, attr, def) {
      var v = $elm.attr(attr);
      return v === undefined || v === '' ? def : v;
  }

  function getCssClass(s) {
      s.baseTheme = mobiscroll$3.themes.form[s.theme].baseTheme;
      return 'mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
  }

  var FormControl = function () {
      function FormControl(elm, settings) {
          var _this = this;

          classCallCheck(this, FormControl);

          var s = extend$1({}, defaults$1, mobiscroll$3.settings, settings);
          var $elm = $$2(elm);
          var $p = $elm.parent();
          var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p;
          // Check for inline mobiscroll components
          var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;
          var type = getControlType($elm);
          var inputStyle = getAttr($elm, 'data-input-style', s.inputStyle);
          var labelStyle = getAttr($elm, 'data-label-style', s.labelStyle);

          if (elm.mbscInst) {
              elm.mbscInst.destroy();
          }

          if ($frame) {
              $frame.insertAfter($parent);
          }

          var themeName;

          themeName = s.theme;

          if (themeName == 'auto' || !themeName) {
              themeName = mobiscroll$3.autoTheme;
          }

          s.theme = themeName;

          if (s.rtl === undefined && s.lang && mobiscroll$3.i18n[s.lang]) {
              s.rtl = mobiscroll$3.i18n[s.lang].rtl;
          }

          wrapLabel($parent, type, inputStyle, labelStyle, elm);

          $elm.addClass('mbsc-control');

          // Attach events
          this._handle = this._handle.bind(this);
          // Prevent 300ms click latency
          events$1.forEach(function (ev) {
              $elm.on(ev, _this._handle);
          });

          this.settings = s;

          this._type = type;
          this._elm = elm;
          this._$elm = $elm;
          this._$parent = $parent;
          this._$frame = $frame;
          this._ripple = getRipple(s.theme);
          this._isFloating = labelStyle == 'floating' || $parent.hasClass('mbsc-label-floating');

          this.cssClass = getCssClass(s);
          this.getClassElm().addClass(this.cssClass);

          elm.mbscInst = this;
      }

      createClass(FormControl, [{
          key: 'getClassElm',
          value: function getClassElm() {
              return this._$parent;
          }
      }, {
          key: 'destroy',
          value: function destroy() {
              var _this2 = this;

              this._$elm.removeClass('mbsc-control');
              this.getClassElm().removeClass(this.cssClass);
              events$1.forEach(function (ev) {
                  _this2._$elm.off(ev, _this2._handle);
              });
              delete this._elm.mbscInst;
          }
      }, {
          key: 'option',
          value: function option(s) {
              extend$1(this.settings, s);

              var classElm = this.getClassElm();

              if (this.cssClass) {
                  classElm.removeClass(this.cssClass);
              }

              this.cssClass = getCssClass(this.settings);
              classElm.addClass(this.cssClass);
              this._ripple = getRipple(this.settings.theme);
          }
      }, {
          key: '_handle',
          value: function _handle(ev) {
              switch (ev.type) {
                  case 'touchstart':
                  case 'mousedown':
                      this._onStart(ev);
                      break;
                  case 'touchmove':
                  case 'mousemove':
                      this._onMove(ev);
                      break;
                  case 'touchend':
                  case 'touchcancel':
                  case 'mouseup':
                  case 'mouseleave':
                      this._onEnd(ev);
                      break;
              }
          }
      }, {
          key: '_addRipple',
          value: function _addRipple(ev) {
              if (this._ripple && this._$rippleElm) {
                  this._ripple.addRipple(this._$rippleElm, ev);
              }
          }
      }, {
          key: '_removeRipple',
          value: function _removeRipple() {
              if (this._ripple && this._$rippleElm) {
                  this._ripple.removeRipple();
              }
          }
      }, {
          key: '_onStart',
          value: function _onStart(ev) {
              var elm = this._elm;

              if (testTouch(ev, elm)) {
                  this._startX = getCoord(ev, 'X');
                  this._startY = getCoord(ev, 'Y');

                  if ($active) {
                      $active.removeClass('mbsc-active');
                  }

                  if (!elm.disabled) {
                      this._isActive = true;
                      $active = this._$elm;
                      $active.addClass('mbsc-active');
                      this._addRipple(ev);
                  }
              }

              if (ev.type == 'touchstart') {
                  this._$elm.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
              }
          }
      }, {
          key: '_onMove',
          value: function _onMove(ev) {
              // If movement is more than 9px, don't fire the click event handler
              if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {
                  this._$elm.removeClass('mbsc-active');
                  this._removeRipple();
                  this._isActive = false;
              }
          }
      }, {
          key: '_onEnd',
          value: function _onEnd(ev) {
              var _this3 = this;

              var control = this._elm;
              var type = this._type;

              if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {
                  activateControl(control, type, ev);
              }

              if (this._isActive) {
                  setTimeout(function () {
                      _this3._$elm.removeClass('mbsc-active');
                      _this3._removeRipple();
                  }, 100);
              }

              this._isActive = false;

              $active = null;
          }
      }]);
      return FormControl;
  }();

  mobiscroll$3.themes.form.mobiscroll = {};

  var events = ['focus', 'change', 'blur', 'animationstart'];

  var Input = function (_FormControl) {
      inherits(Input, _FormControl);

      function Input(elm, settings) {
          classCallCheck(this, Input);

          var _this = possibleConstructorReturn(this, (Input.__proto__ || Object.getPrototypeOf(Input)).call(this, elm, settings));

          var $elm = _this._$elm;
          var $parent = _this._$parent;
          var $dummy = $parent.find('.mbsc-select-input, .mbsc-color-input');

          addIconToggle(_this, $parent, $elm);

          _this._checkLabel = _this._checkLabel.bind(_this);
          _this._mouseDown = _this._mouseDown.bind(_this);
          _this._setText = _this._setText.bind(_this);

          if (elm.type == 'file') {
              // Copy attributes and create dummy input
              var $existing = $parent.find('.mbsc-file-input');
              _this._$input = $existing.length ? $existing : $$2('<input type="text" class="' + ($elm.attr('class') || '') + ' mbsc-file-input" placeholder="' + ($elm.attr('placeholder') || '') + '"/>').insertAfter($elm);

              // Copy value on file upload
              $elm.on('change', _this._setText);
          }

          $parent.addClass('mbsc-input').on('mousedown', _this._mouseDown);

          // Attach events
          events.forEach(function (ev) {
              $elm.on(ev, _this._checkLabel);
          });

          // Move the dummy input after the element for correct styling
          if ($dummy.length) {
              $elm.after($dummy);
              if ($dummy.hasClass('mbsc-select-input')) {
                  _this._delm = $dummy[0];
                  _this.refresh();
              }
          }
          return _this;
      }

      createClass(Input, [{
          key: '_setText',
          value: function _setText(ev) {
              var files = ev.target.files;
              var names = [];

              for (var i = 0; i < files.length; ++i) {
                  names.push(files[i].name);
              }
              names.join(', ');
              this._$input.val(names);
          }
      }, {
          key: '_checkLabel',
          value: function _checkLabel(ev) {
              if (this._isFloating) {
                  // In case of select we need to check the dummy element
                  var elm = this._delm || this._elm;
                  // In case of autofill in webkit browsers the animationstart event will fire 
                  // due to the empty animation added in the css,
                  // because there's no other event in case of the initial autofill
                  if (elm.value || document.activeElement === elm || ev && (ev.type == 'focus' || ev.type == 'animationstart' && this._$elm.is('*:-webkit-autofill'))) {
                      this._$parent.addClass('mbsc-label-floating-active');
                  } else {
                      this._$parent.removeClass('mbsc-label-floating-active');
                  }
              }
          }
      }, {
          key: '_mouseDown',
          value: function _mouseDown(ev) {
              // Will prevent floating label animation when loosing focus only for a brief moment
              if (document.activeElement === this._elm && ev.target !== this._elm) {
                  ev.preventDefault();
              }
          }
      }, {
          key: 'refresh',
          value: function refresh() {
              this._checkLabel();
          }
      }, {
          key: 'destroy',
          value: function destroy() {
              var _this2 = this;

              get(Input.prototype.__proto__ || Object.getPrototypeOf(Input.prototype), 'destroy', this).call(this);
              this._$parent.off('mousedown', this._mouseDown).removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();

              this._$parent.find('.mbsc-input-fill').remove();

              events.forEach(function (ev) {
                  _this2._$elm.off(ev, _this2._checkLabel);
              });

              this._$elm.off('change', this._setText);
          }
      }]);
      return Input;
  }(FormControl);

  // Init mbsc-input elements on page load
  autoInit('[mbsc-input]', Input);

  var Button = function (_FormControl) {
      inherits(Button, _FormControl);

      function Button(elm, settings) {
          classCallCheck(this, Button);

          var _this = possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).call(this, elm, settings));

          var $elm = _this._$elm;
          var hasIcon = $elm.attr('data-icon');

          $elm.addClass('mbsc-btn mbsc-no-touch').find('.mbsc-btn-ic').remove();

          if (hasIcon) {
              $elm.prepend('<span class="mbsc-btn-ic mbsc-ic mbsc-ic-' + hasIcon + '"></span>');
              if ($elm.text() === "") {
                  $elm.addClass('mbsc-btn-icon-only');
              }
          }

          _this._$rippleElm = $elm;
          return _this;
      }

      createClass(Button, [{
          key: 'getClassElm',
          value: function getClassElm() {
              return this._$elm;
          }
      }]);
      return Button;
  }(FormControl);

  // Init mbsc-button elements on page load
  autoInit('[mbsc-button]', Button);

  var CheckBox = function (_FormControl) {
      inherits(CheckBox, _FormControl);

      function CheckBox(elm, settings) {
          classCallCheck(this, CheckBox);

          var _this = possibleConstructorReturn(this, (CheckBox.__proto__ || Object.getPrototypeOf(CheckBox)).call(this, elm, settings));

          _this._$parent.prepend(_this._$elm).addClass('mbsc-checkbox mbsc-control-w').find('.mbsc-checkbox-box').remove();

          _this._$elm.after('<span class="mbsc-checkbox-box"></span>');
          return _this;
      }

      return CheckBox;
  }(FormControl);

  // Init mbsc-checkbox elements on page load
  autoInit('[mbsc-checkbox]', CheckBox);

  var Radio = function (_FormControl) {
      inherits(Radio, _FormControl);

      function Radio(elm, settings) {
          classCallCheck(this, Radio);

          var _this = possibleConstructorReturn(this, (Radio.__proto__ || Object.getPrototypeOf(Radio)).call(this, elm, settings));

          _this._$parent.addClass('mbsc-radio mbsc-control-w').find('.mbsc-radio-box').remove();

          _this._$elm.after('<span class="mbsc-radio-box"><span></span></span>');
          return _this;
      }

      return Radio;
  }(FormControl);

  // Init mbsc-radio elements on page load
  autoInit('[mbsc-radio]', Radio);

  var Select = function (_Input) {
      inherits(Select, _Input);

      function Select(elm, settings) {
          classCallCheck(this, Select);

          var _this = possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, elm, settings));

          var $elm = _this._$elm;
          var $parent = _this._$parent;
          var $existing = $parent.find('.mbsc-select-input');
          var $input = $existing.length ? $existing : $$2('<input tabindex="-1" class="mbsc-select-input mbsc-control" readonly>');

          _this._$input = $input;
          _this._delm = $input[0];
          _this._setText = _this._setText.bind(_this);

          $parent.addClass('mbsc-select' + (_this._$frame ? ' mbsc-select-inline' : ''));

          $elm.after($input);

          $input.after('<span class="mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5"></span>');

          // Update dummy input text on change
          $elm.on('change', _this._setText);
          _this._setText();
          return _this;
      }

      createClass(Select, [{
          key: 'destroy',
          value: function destroy() {
              get(Select.prototype.__proto__ || Object.getPrototypeOf(Select.prototype), 'destroy', this).call(this);
              this._$parent.find('.mbsc-select-ic').remove();
              this._$elm.off('change', this._setText);
          }
      }, {
          key: '_setText',
          value: function _setText() {
              var elm = this._elm;
              var $elm = $$2(elm);
              // Check if select and mobiscroll select was not initialized
              if ($elm.is('select') && !$elm.hasClass('mbsc-comp')) {
                  this._$input.val(elm.selectedIndex != -1 ? elm.options[elm.selectedIndex].text : '');
              }
              // Check floating label
              this.refresh();
          }
      }]);
      return Select;
  }(Input);

  // Init mbsc-select elements on page load
  autoInit('[mbsc-dropdown]', Select);

  var events$2 = ['change', 'keydown', 'input', 'scroll'];

  var sizeDebounce = void 0;

  function sizeTextAreas() {
      clearTimeout(sizeDebounce);
      sizeDebounce = setTimeout(function () {
          $$2('textarea.mbsc-control').each(function () {
              sizeTextArea(this);
          });
      }, 100);
  }

  function sizeTextArea(control) {
      var height = void 0,
          lineNr = void 0,
          line = void 0,
          rowNr = $$2(control).attr('rows') || 6;

      if (control.offsetHeight) {
          control.style.height = '';

          line = control.scrollHeight - control.offsetHeight;
          height = control.offsetHeight + (line > 0 ? line : 0);
          lineNr = Math.round(height / 24);

          if (lineNr > rowNr) {
              //control.scrollTop = height;
              height = 24 * rowNr + (height - lineNr * 24);
              $$2(control).addClass('mbsc-textarea-scroll');
          } else {
              $$2(control).removeClass('mbsc-textarea-scroll');
          }

          if (height) {
              control.style.height = height + 'px';
          }
      }
  }

  function scrollTextArea(elm) {
      var $elm = $$2(elm);

      if (!$elm.hasClass('mbsc-textarea-scroll')) {
          var line = elm.scrollHeight - elm.offsetHeight,
              height = elm.offsetHeight + line,
              lineNr = Math.round(height / 24),
              rowNr = $elm.attr('rows') || 6;

          if (lineNr <= rowNr) {
              elm.scrollTop = 0;
              elm.style.height = height + 'px';
          }
      }
  }

  if (isBrowser) {
      // Set height of textareas on viewport size changes
      $$2(window).on('resize orientationchange', sizeTextAreas);
  }

  var TextArea = function (_Input) {
      inherits(TextArea, _Input);

      function TextArea(elm, settings) {
          classCallCheck(this, TextArea);

          var _this = possibleConstructorReturn(this, (TextArea.__proto__ || Object.getPrototypeOf(TextArea)).call(this, elm, settings));

          _this._$parent.addClass('mbsc-textarea');

          events$2.forEach(function (ev) {
              _this._$elm.on(ev, _this._handle);
          });

          sizeTextArea(elm);
          return _this;
      }

      createClass(TextArea, [{
          key: 'destroy',
          value: function destroy() {
              var _this2 = this;

              get(TextArea.prototype.__proto__ || Object.getPrototypeOf(TextArea.prototype), 'destroy', this).call(this);
              events$2.forEach(function (ev) {
                  _this2._$elm.off(ev, _this2._handle);
              });
          }
      }, {
          key: 'refresh',
          value: function refresh() {
              get(TextArea.prototype.__proto__ || Object.getPrototypeOf(TextArea.prototype), 'refresh', this).call(this);
              clearTimeout(this._debounce);
              sizeTextArea(this._elm);
          }
      }, {
          key: '_handle',
          value: function _handle(ev) {
              get(TextArea.prototype.__proto__ || Object.getPrototypeOf(TextArea.prototype), '_handle', this).call(this, ev);

              switch (ev.type) {
                  case 'change':
                      sizeTextArea(this._elm);
                      break;
                  case 'keydown':
                  case 'input':
                      this._onInput(ev);
                      break;
                  case 'scroll':
                      scrollTextArea(this._elm);
              }
          }
      }, {
          key: '_onInput',
          value: function _onInput() {
              var _this3 = this;

              clearTimeout(this._debounce);
              this._debounce = setTimeout(function () {
                  sizeTextArea(_this3._elm);
              }, 100);
          }
      }]);
      return TextArea;
  }(Input);

  // Init mbsc-textarea elements on page load
  autoInit('[mbsc-textarea]', TextArea);

  var SegmentedItem = function (_FormControl) {
      inherits(SegmentedItem, _FormControl);

      function SegmentedItem(elm, settings) {
          classCallCheck(this, SegmentedItem);

          var _this = possibleConstructorReturn(this, (SegmentedItem.__proto__ || Object.getPrototypeOf(SegmentedItem)).call(this, elm, settings));

          var $segmentCont = void 0;
          var $segment = void 0;

          var $elm = _this._$elm;
          var $parent = _this._$parent;
          var s = _this.settings;

          if (!$parent.hasClass('mbsc-segmented-item-ready')) {
              $segmentCont = $$2('<div class="mbsc-segmented mbsc-no-touch"></div>');

              $parent.after($segmentCont);
              $parent.parent().find('input[name="' + $elm.attr('name') + '"]').each(function () {
                  var $input = $$2(this);

                  $segment = $input.parent().addClass('mbsc-segmented-item mbsc-segmented-item-ready');

                  $$2('<span class="mbsc-segmented-content">' + ($input.attr('data-icon') ? '<span class="mbsc-ic mbsc-ic-' + $input.attr('data-icon') + '"></span>' : '') + '</span>').append($segment.contents()).appendTo($segment);

                  $segment.prepend($input);

                  $segmentCont.append($segment);
              });
          }

          _this._$rippleElm = $elm.next();
          return _this;
      }

      createClass(SegmentedItem, [{
          key: 'getClassElm',
          value: function getClassElm() {
              return this._$elm.closest('.mbsc-segmented');
          }
      }]);
      return SegmentedItem;
  }(FormControl);

  // Init mbsc-segmented elements on page load
  autoInit('[mbsc-segmented]', SegmentedItem);

  function createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {
      var $btn,
          changed,
          index,
          running,
          source,
          startX,
          startY,
          step,
          timer,
          check = isReadOnly || noop;

      function onBtnStart(ev) {
          var proceed;

          $btn = $$2(this);

          step = +$btn.attr('data-step');
          index = +$btn.attr('data-index');
          changed = true;

          if (stopProp) {
              ev.stopPropagation();
          }

          if (ev.type == 'touchstart') {
              $btn.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
          }

          if (ev.type == 'mousedown') {
              // Prevent focus
              ev.preventDefault();
          }

          if (ev.type != 'keydown') {
              //e.preventDefault();
              startX = getCoord(ev, 'X');
              startY = getCoord(ev, 'Y');
              proceed = testTouch(ev, this);
          } else {
              proceed = ev.keyCode === 32;
          }

          if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {
              if (start(index, step, ev)) {
                  $btn.addClass('mbsc-active');
                  if (ripple) {
                      ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);
                  }
              }

              if (ev.type == 'mousedown') {
                  $$2(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);
              }
          }
      }

      function onBtnMove(ev) {
          if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {
              changed = true;
              stop();
          }
      }

      function onBtnEnd(ev) {
          if (ev.type == 'touchend') {
              // Prevents iOS scroll on double tap
              ev.preventDefault();
          }

          stop();

          if (ev.type == 'mouseup') {
              $$2(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);
          }
      }

      function stop() {
          running = false;
          clearInterval(timer);
          if ($btn) {
              $btn.removeClass('mbsc-active');
              if (ripple) {
                  setTimeout(function () {
                      ripple.removeRipple();
                  }, 100);
              }
          }
      }

      function start(i, st, ev) {
          if (!running && !check(i)) {
              index = i;
              step = st;
              source = ev;
              running = true;
              changed = false;
              setTimeout(tick, 100);
          }
          return running;
      }

      function tick() {
          if ($btn && $btn.hasClass('mbsc-disabled')) {
              stop();
              return;
          }
          if (running || !changed) {
              changed = true;
              action(index, step, source, tick);
          }
          if (running && delay) {
              clearInterval(timer);
              timer = setInterval(function () {
                  action(index, step, source);
              }, delay);
          }
      }

      function destroy() {
          $elm.off('touchstart mousedown keydown', onBtnStart).off('touchmove', onBtnMove).off('touchend touchcancel keyup', onBtnEnd);
      }

      $elm.on('touchstart mousedown keydown', onBtnStart).on('touchmove', onBtnMove).on('touchend touchcancel keyup', onBtnEnd);

      return {
          start: start,
          stop: stop,
          destroy: destroy
      };
  }

  var Stepper = function Stepper(control, settings) {
      var $btnPlus,
          $btnMinus,
          $controls,
          cssClass = '',
          displayValue,
          max,
          min,
          inputStyle,
          ripple,
          scale,
          step,
          stepper,
          s,
          theme,
          val,
          that = this,
          $control = $$2(control),
          ready,
          $parent,
          old = val;

      function onChange() {
          var v;

          if (!control.disabled) {
              v = parseFloat($$2(this).val());
              setValue(isNaN(v) ? val : v);
          }
      }

      function checkDisabled() {
          return control.disabled;
      }

      function stepValue(index, dir) {
          setValue(val + dir * step);
      }

      function setValue(v, fill, change) {

          old = val;

          if (fill === undefined) {
              fill = true;
          }

          if (change === undefined) {
              change = fill;
          }

          val = round(v);

          $controls.removeClass('mbsc-disabled');

          if (fill) {
              $control.val(val);
          }

          if (val == min) {
              $btnMinus.addClass('mbsc-disabled');
          } else if (val == max) {
              $btnPlus.addClass('mbsc-disabled');
          }

          if (val !== old && change) {
              $control.trigger('change');
          }
      }

      function getAttr(attr, def, str) {
          var v = $control.attr(attr);
          return v === undefined || v === '' ? def : str ? v : +v;
      }

      function round(v) {
          return +Math.min(max, Math.max(Math.round(v / step) * step, min)).toFixed(scale);
      }

      // Call the parent constructor
      Base.call(this, control, settings, true);

      /* TRIALFUNC */

      that.getVal = function () {
          var v = parseFloat($control.val());
          v = isNaN(v) ? val : v;
          return round(v);
      };

      that.setVal = function (v, fill, change) {
          v = parseFloat(v);
          setValue(isNaN(v) ? val : v, fill, change);
      };

      that._init = function () {
          ready = $control.parent().hasClass('mbsc-stepper');
          $parent = ready ? $control.closest('.mbsc-stepper-cont') : $control.parent();

          s = that.settings;

          min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
          max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
          step = settings.step === undefined ? getAttr('step', s.step) : settings.step;
          scale = Math.abs(step) < 1 ? (step + '').split('.')[1].length : 0;
          inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
          displayValue = $control.attr('data-val') || s.val;
          val = round(+control.value || 0);

          theme = mobiscroll$3.themes.form[s.theme];
          ripple = theme && theme.addRipple ? theme : null;

          if (!ready) {
              $parent.addClass('mbsc-stepper-cont mbsc-no-touch mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').append('<span class="mbsc-segmented mbsc-stepper' + '"></span>').find('.mbsc-stepper').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-minus ' + (val == min ? 'mbsc-disabled' : '') + '" data-step="-1" tabindex="0"><span class="mbsc-segmented-content"><span class="mbsc-ic mbsc-ic-minus"></span></span></span>').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-plus ' + (val == max ? 'mbsc-disabled' : '') + '"  data-step="1" tabindex="0"><span class="mbsc-segmented-content"> <span class="mbsc-ic mbsc-ic-plus"></span></span></span>').prepend($control);
          }

          if (cssClass) {
              $parent.removeClass(cssClass);
              $parent.find('.mbsc-segmented').removeClass(cssClass);
          }

          cssClass = 'mbsc-' + s.theme + (theme.baseTheme ? ' mbsc-' + theme.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');

          $parent.addClass(cssClass);
          $parent.find('.mbsc-segmented').addClass(cssClass);

          $btnMinus = $$2('.mbsc-stepper-minus', $parent);
          $btnPlus = $$2('.mbsc-stepper-plus', $parent);
          $controls = $$2('.mbsc-stepper-control', $parent);

          if (!ready) {
              if (displayValue == 'left') {
                  $parent.addClass('mbsc-stepper-val-left');
                  $control.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
              } else if (displayValue == 'right') {
                  $parent.addClass('mbsc-stepper-val-right');
                  $btnPlus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
              } else {
                  $btnMinus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content mbsc-stepper-val"></span></span>');
              }
          }

          if (!stepper) {
              $control.on('change', onChange);
              stepper = createStepper($controls, stepValue, 150, checkDisabled, false, ripple);
          }

          $control.val(val).attr('data-role', 'stepper').attr('min', min).attr('max', max).attr('step', step).addClass('mbsc-control');

          control.mbscInst = that;
      };

      that._destroy = function () {
          $control.removeClass('mbsc-control').off('change', onChange);
          stepper.destroy();
          delete control.mbscInst;
      };

      that.init();
  };

  Stepper.prototype = {
      _class: 'stepper',
      _hasDef: true,
      _hasTheme: true,
      _hasLang: true,
      _defaults: {
          min: 0,
          max: 100,
          step: 1
      }
  };

  classes.Stepper = Stepper;

  // Init mbsc-stepper elements on page load
  autoInit('[mbsc-stepper]', Stepper);

  var ProgressBase = function ProgressBase(elm, settings, inherit) {
          var $elm,
              $parent,
              cssClass,
              s,
              that = this;

          // Call the parent constructor
          Base.call(this, elm, settings, true);

          that.__init = noop;

          that.__destroy = noop;

          that._init = function () {

                  var wasInit;

                  s = that.settings;

                  $elm = $$2(elm);

                  // Check if the element was already initialized
                  wasInit = !!$parent;

                  $parent = $elm.parent();
                  $parent = $parent.hasClass('mbsc-input-wrap') ? $parent.parent() : $parent;

                  that._$parent = $parent;

                  if (cssClass) {
                          $parent.removeClass(cssClass);
                  }

                  cssClass = that._css + ' mbsc-progress-w mbsc-control-w ' + getCssClass(s);

                  $parent.addClass(cssClass);

                  $elm.addClass('mbsc-control');

                  that.__init();

                  if (!wasInit) {
                          that._attachChange();
                  }

                  // Show initial value
                  that.refresh();

                  elm.mbscInst = that;
          };

          that._destroy = function () {

                  that.__destroy();

                  $parent.removeClass(cssClass);

                  $elm.removeClass('mbsc-control');

                  delete elm.mbscInst;
          };

          if (!inherit) {
                  that.init();
          }
  };

  var SliderBase = function SliderBase(elm, settings, inherit) {
      var $elm,
          $handle,
          $handleCont,
          $handles,
          $listener,
          $parent,
          $track,
          action,
          base,
          changed,
          diffX,
          diffY,
          diff,
          endX,
          endY,
          handleIndex,
          isHover,
          isPressed,
          isRtl,
          live,
          max,
          min,
          moved,
          multiple,
          oldValue,
          step,
          s,
          scale,
          startX,
          startY,
          stepDecimal,
          timer,
          totalWidth,
          value,
          that = this,
          lastUpdate = new Date();

      function onStart(ev) {
          if (ev.type === 'mousedown') {
              ev.preventDefault();
          }

          if (testTouch(ev, this) && (!action || isHover) && !elm.disabled && !elm.readOnly /* TRIALCOND */) {
                  if (s.stopProp) {
                      ev.stopPropagation();
                  }

                  action = true;
                  moved = false;
                  changed = false;
                  startX = getCoord(ev, 'X');
                  startY = getCoord(ev, 'Y');
                  endX = startX;

                  $track.removeClass('mbsc-progress-anim');
                  $handle = multiple ? $$2('.mbsc-slider-handle', this) : $handles;

                  if ($handleCont) {
                      $handleCont.removeClass('mbsc-handle-curr');
                  }

                  $handleCont = $handle.parent().addClass('mbsc-active mbsc-handle-curr');
                  $elm.addClass('mbsc-active');

                  handleIndex = +$handle.attr('data-index');
                  totalWidth = $track[0].offsetWidth;
                  diff = $track[0].getBoundingClientRect().left;

                  if (ev.type === 'mousedown') {
                      isPressed = true;
                      $$2(document).on('mousemove', onMove).on('mouseup', onEnd);
                  }

                  if (ev.type === 'mouseenter') {
                      isHover = true;
                      $$2(document).on('mousemove', onMove);
                  }
              }
      }

      function onMove(ev) {
          if (action) {
              endX = getCoord(ev, 'X');
              endY = getCoord(ev, 'Y');
              diffX = endX - startX;
              diffY = endY - startY;

              if (Math.abs(diffX) > 5) {
                  moved = true;
              }

              if (moved || isPressed || isHover) {
                  if (Math.abs(lastUpdate - new Date()) > 50) {
                      lastUpdate = new Date();
                      updateSlider(endX, s.round, live && (!isHover || isPressed));
                  }
              }

              if (moved) {
                  ev.preventDefault();
              } else if (Math.abs(diffY) > 7 && ev.type == 'touchmove') {
                  cleanUp(ev);
              }
          }
      }

      function onEnd(ev) {
          if (action) {
              ev.preventDefault();

              if (!multiple) {
                  $track.addClass('mbsc-progress-anim');
              }

              if (isHover && !isPressed) {
                  updateValue(value[handleIndex], handleIndex, false, false, true);
              } else {
                  updateSlider(endX, true, true);
              }

              if (!moved && !changed) {

                  if (ev.type == 'touchend') {
                      // Prevent ghost click
                      preventClick();
                  }

                  that._onTap(value[handleIndex]);
              }

              if (ev.type == 'mouseup') {
                  isPressed = false;
              }

              if (ev.type == 'mouseleave') {
                  isHover = false;
              }

              if (!isHover) {
                  cleanUp();
              }
          }
      }

      function onCancel() {
          if (action) {
              cleanUp();
          }
      }

      function onChange() {
          var v = that._readValue($$2(this)),
              i = +$$2(this).attr('data-index');

          if (v !== value[i]) {
              value[i] = v;
              oldValue[i] = v;
              updateValue(v, i);
          }
      }

      function onClick(ev) {
          // Prevent propagating click to label
          ev.stopPropagation();
      }

      function onLabelClick(ev) {
          // Prevent change on label click for swithes
          ev.preventDefault();
      }

      function onKeyDown(ev) {
          var dir;

          if (!elm.disabled) {

              switch (ev.keyCode) {
                  case 38:
                  case 39:
                      dir = 1;
                      break;
                  case 40:
                  case 37:
                      dir = -1;
                      break;
              }

              if (dir) {
                  ev.preventDefault();

                  if (!timer) {

                      handleIndex = +$$2(this).attr('data-index');

                      updateValue(value[handleIndex] + step * dir, handleIndex, true);

                      timer = setInterval(function () {
                          updateValue(value[handleIndex] + step * dir, handleIndex, true);
                      }, 200);
                  }
              }
          }
      }

      function onKeyUp(ev) {
          ev.preventDefault();
          clearInterval(timer);
          timer = null;
      }

      function cleanUp() {
          action = false;
          $handleCont.removeClass('mbsc-active');
          $elm.removeClass('mbsc-active');

          // Detach document events
          $$2(document).off('mousemove', onMove).off('mouseup', onEnd);
      }

      function updateSlider(pos, round, fill) {
          var percent = round ? Math.min(Math[that._rounding || 'round'](Math.max((pos - diff) * 100 / totalWidth, 0) / scale / step) * step * 100 / (max - min + base), 100) : Math.max(0, Math.min((pos - diff) * 100 / totalWidth, 100));

          if (isRtl) {
              percent = 100 - percent;
          }

          updateValue(Math.round((min - base + percent / scale) * stepDecimal) / stepDecimal, handleIndex, fill, percent);
      }

      function updateValue(v, index, fill, percent, refresh, change) {
          var $handle = $handles.eq(index),
              $handleCont = $handle.parent();

          v = Math.min(max, Math.max(v, min));

          if (change === undefined) {
              change = fill;
          }

          if (that._update) {
              v = that._update(v, value, index, percent, multiple, refresh, $handleCont);
          } else {
              $handleCont.css({
                  left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
                  right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
              });
          }

          if (v > min) {
              $handleCont.removeClass('mbsc-slider-start');
          } else if (value[index] > min || refresh) {
              $handleCont.addClass('mbsc-slider-start');
          }

          // Store new value
          if (fill) {
              value[index] = v;
          }

          // Check if value changed
          if (fill && oldValue[index] != v) {
              changed = true;

              oldValue[index] = v;

              // Set new value to the input
              that._fillValue(v, index, change);
          }

          $handle.attr('aria-valuenow', v);
      }

      // Call the parent constructor
      ProgressBase.call(this, elm, settings, true);

      that._onTap = noop;

      that.___init = noop;

      that.___destroy = noop;

      that._attachChange = function () {
          $elm.on(s.changeEvent, onChange);
      };

      that.__init = function () {
          var wasInit;

          if ($handles) {
              wasInit = true;
              $handles.parent().remove();
          }

          that.___init();

          $parent = that._$parent;
          $track = that._$track;
          $elm = $parent.find('input');

          s = that.settings;
          min = that._min;
          max = that._max;
          base = that._base || 0;
          step = that._step;
          live = that._live;
          stepDecimal = step % 1 !== 0 ? 100 / (+(step % 1).toFixed(2) * 100) : 1;
          scale = 100 / (max - min + base) || 100;
          multiple = $elm.length > 1;
          isRtl = s.rtl;
          value = [];
          oldValue = [];

          // Read values
          $elm.each(function (i) {
              value[i] = that._readValue($$2(this));
              $$2(this).attr('data-index', i);
          });

          $handles = $parent.find('.mbsc-slider-handle');
          $listener = $parent.find(multiple ? '.mbsc-slider-handle-cont' : '.mbsc-progress-cont');

          // Attach events
          $handles.on('keydown', onKeyDown).on('keyup', onKeyUp).on('blur', onKeyUp);

          $listener.on('touchstart mousedown' + (s.hover ? ' mouseenter' : ''), onStart).on('touchmove', onMove).on('touchend touchcancel' + (s.hover ? ' mouseleave' : ''), onEnd).on('pointercancel', onCancel);

          if (!wasInit) {
              $elm.on('click', onClick);

              $parent.on('click', onLabelClick);
          }
      };

      that.__destroy = function () {
          $parent.off('click', onLabelClick);

          $elm.off(s.changeEvent, onChange).off('click', onClick);

          $handles.off('keydown', onKeyDown).off('keyup', onKeyUp).off('blur', onKeyUp);

          $listener.off('touchstart mousedown mouseenter', onStart).off('touchmove', onMove).off('touchend touchcancel mouseleave', onEnd).off('pointercancel', onCancel);

          that.___destroy();
      };

      that.refresh = function () {
          $elm.each(function (i) {
              updateValue(that._readValue($$2(this)), i, true, false, true, false);
          });
      };

      that.getVal = function () {
          return multiple ? value.slice(0) : value[0];
      };

      that.setVal = that._setVal = function (val, fill, change) {
          if (!$$2.isArray(val)) {
              val = [val];
          }

          $$2.each(val, function (i, v) {
              value[i] = v;
          });

          $$2.each(val, function (i, v) {
              updateValue(v, i, true, false, true, change);
          });
      };

      if (!inherit) {
          that.init();
      }
  };

  var Switch = function Switch(elm, settings) {
      var $elm,
          $parent,
          s,
          formControl,
          that = this;

      settings = settings || {};

      extend$1(settings, {
          changeEvent: 'click',
          round: false
      });

      // Call the parent constructor
      SliderBase.call(this, elm, settings, true);

      that._readValue = function () {
          return elm.checked ? 1 : 0;
      };

      that._fillValue = function (v, index, change) {
          $elm.prop('checked', !!v);

          if (change) {
              $elm.trigger('change');
          }
      };

      that._onTap = function (v) {
          that._setVal(v ? 0 : 1);
      };

      that.___init = function () {
          s = that.settings;
          $elm = $$2(elm);
          $parent = $elm.parent();

          $parent.find('.mbsc-switch-track').remove();
          $parent.prepend($elm);

          $elm.attr('data-role', 'switch').after('<span class="mbsc-progress-cont mbsc-switch-track">' + '<span class="mbsc-progress-track mbsc-progress-anim">' + '<span class="mbsc-slider-handle-cont">' + '<span class="mbsc-slider-handle mbsc-switch-handle" data-index="0">' + '<span class="mbsc-switch-txt-off">' + s.offText + '</span>' + '<span class="mbsc-switch-txt-on">' + s.onText + '</span>' + '</span></span></span></span>');

          if (formControl) {
              formControl.destroy();
          }

          formControl = new FormControl(elm, s);

          that._$track = $parent.find('.mbsc-progress-track');
          that._min = 0;
          that._max = 1;
          that._step = 1;
      };

      that.___destroy = function () {
          formControl.destroy();
      };

      that.getVal = function () {
          return elm.checked;
      };

      that.setVal = function (val, fill, change) {
          that._setVal(val ? 1 : 0, fill, change);
      };

      that.init();
  };

  Switch.prototype = {
      _class: 'switch',
      _css: 'mbsc-switch',
      _hasTheme: true,
      _hasLang: true,
      _hasDef: true,
      _defaults: {
          stopProp: true,
          offText: 'Off',
          onText: 'On'
      }
  };

  classes.Switch = Switch;

  // Init mbsc-switch elements on page load
  autoInit('[mbsc-switch]', Switch);

  /* eslint-disable no-unused-vars */
  /* eslint-enable no-unused-vars */
  var Progress = function Progress(elm, settings, inherit) {
      var $display,
          $elm,
          $parent,
          $progress,
          $target,
          $track,
          min,
          max,
          inputStyle,
          labelStyle,
          s,
          template,
          value,
          valueText,
          that = this;

      function onChange() {
          var v = getAttr('value', min);
          if (v !== value) {
              updateValue(v);
          }
      }

      function getAttr(attr, def, str) {
          var v = $elm.attr(attr);
          return v === undefined || v === '' ? def : str ? v : +v;
      }

      function updateValue(v, refresh, fill, change) {
          v = /* TRIALCONDREV */Math.min(max, Math.max(v, min));

          $progress.css('width', (v - min) * 100 / (max - min) + '%');

          if (fill === undefined) {
              fill = true;
          }

          if (change === undefined) {
              change = fill;
          }

          if (v !== value || refresh) {
              // Display value
              that._display(v);
          }

          if (v !== value) {
              // Set new value
              value = v;

              // Put new value in the progress element
              if (fill) {
                  $elm.attr('value', value);
              }

              // Trigger change on the element
              if (change) {
                  $elm.trigger('change');
              }
          }
      }

      // Call the parent constructor
      ProgressBase.call(this, elm, settings, true);

      that._display = function (v) {
          valueText = template && s.returnAffix ? template.replace(/\{value\}/, v).replace(/\{max\}/, max) : v;

          if ($target) {
              $target.html(valueText);
          }

          if ($display) {
              $display.html(valueText);
          }
      };

      that._attachChange = function () {
          $elm.on('change', onChange);
      };

      that.__init = function () {

          var displayValue, i, stepLabels, wasInit;

          s = that.settings;

          $elm = $$2(elm);

          // Check if the element was already initialized
          wasInit = !!$parent;

          $parent = that._$parent;

          // Read settings from data attributes or settings object
          min = that._min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
          max = that._max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
          inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
          labelStyle = settings.labelStyle === undefined ? getAttr('data-label-style', s.labelStyle, true) : settings.labelStyle;
          value = getAttr('value', min);
          displayValue = $elm.attr('data-val') || s.val;
          stepLabels = $elm.attr('data-step-labels');
          stepLabels = stepLabels ? JSON.parse(stepLabels) : s.stepLabels;
          template = $elm.attr('data-template') || (max == 100 && !s.template ? '{value}%' : s.template);

          if (!wasInit) {
              wrapLabel($parent, null, inputStyle, labelStyle, elm);

              addIcon($elm);

              // Generate track and progress
              $parent.find('.mbsc-input-wrap').append('<span class="mbsc-progress-cont"><span class="mbsc-progress-track mbsc-progress-anim"><span class="mbsc-progress-bar"></span></span></span>');

              $progress = that._$progress = $parent.find('.mbsc-progress-bar');
              $track = that._$track = $parent.find('.mbsc-progress-track');
          } else {
              if (displayValue) {
                  $display.remove();
                  $parent.removeClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left'));
              }

              if (stepLabels) {
                  $$2('.mbsc-progress-step-label', $track).remove();
              }
          }

          // Set attributes
          $elm.attr('min', min).attr('max', max);

          // Generate value container on left or right side
          if (displayValue) {
              $display = $$2('<span class="mbsc-progress-value"></span>');
              $parent.addClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left')).find('.mbsc-input-wrap').append($display);
          }

          // Generate step labels
          if (stepLabels) {
              for (i = 0; i < stepLabels.length; ++i) {
                  $track.append('<span class="mbsc-progress-step-label" style="' + (s.rtl ? 'right' : 'left') + ': ' + (stepLabels[i] - min) * 100 / (max - min) + '%" >' + stepLabels[i] + '</span>');
              }
          }

          $target = $$2($elm.attr('data-target') || s.target);
      };

      that.__destroy = function () {

          $parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-progress-cont').remove();

          $parent.find('.mbsc-input-ic').remove();

          $elm.off('change', onChange);
      };

      that.refresh = function () {
          updateValue(getAttr('value', min), true, false);
      };

      that.getVal = function () {
          return value;
      };

      that.setVal = function (v, fill, change) {
          updateValue(v, true, fill, change);
      };

      if (!inherit) {
          that.init();
      }
  };

  Progress.prototype = {
      _class: 'progress',
      _css: 'mbsc-progress',
      _hasTheme: true,
      _hasLang: true,
      _hasDef: true,
      _defaults: {
          min: 0,
          max: 100,
          returnAffix: true
      }
  };

  classes.Progress = Progress;

  // Init mbsc-progress elements on page load
  autoInit('[mbsc-progress]', Progress);

  var Slider = function Slider(elm, settings, inherit) {
      var $elm,
          $parent,
          $progress,
          $tooltips,
          $track,
          hasProgress,
          hasTooltip,
          isRange,
          isRtl,
          max,
          min,
          step,
          s,
          that = this;

      // Call the parent constructor
      Progress.call(this, elm, settings, true);

      var progressInit = that.__init,
          progressDestroy = that.__destroy;

      SliderBase.call(this, elm, settings, true);

      var sliderInit = that.__init,
          sliderDestroy = that.__destroy;

      // ---

      that.__init = function () {
          progressInit();
          sliderInit();
      };

      that.__destroy = function () {
          progressDestroy();
          sliderDestroy();
      };

      that._update = function (v, value, index, percent, multiple, refresh, $handleCont) {
          if (isRange) {
              if (index === 0) {
                  v = Math.min(v, value[1]);
                  $progress.css({
                      width: getPercent(value[1], min, max) - getPercent(v, min, max) + '%',
                      left: isRtl ? 'auto' : getPercent(v, min, max) + '%',
                      right: isRtl ? getPercent(v, min, max) + '%' : 'auto'
                  });
              } else {
                  v = Math.max(v, value[0]);
                  $progress.css({
                      width: getPercent(v, min, max) - getPercent(value[0], min, max) + '%'
                  });
              }
          } else if (multiple || !hasProgress) {
              $handleCont.css({
                  left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
                  right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
              });
          } else {
              $progress.css('width', (percent || getPercent(v, min, max)) + '%');
          }

          if (hasTooltip) {
              $tooltips.eq(index).html(v);
          }

          // Display value in the specified container(s)
          if (!multiple && (value[index] != v || refresh)) {
              that._display(v);
          }

          // Return validated value
          return v;
      };

      that._readValue = function ($elm) {
          return +$elm.val();
      };

      that._fillValue = function (v, index, change) {
          $elm.eq(index).val(v);

          if (change) {
              $elm.eq(index).trigger('change');
          }
      };

      that._markupReady = function () {
          var i, stepNr;

          if (hasTooltip) {
              $parent.addClass('mbsc-slider-has-tooltip');
          }

          // Generate step marks
          if (step != 1) {
              stepNr = (max - min) / step;
              for (i = 0; i <= stepNr; ++i) {
                  $track.append('<span class="mbsc-slider-step" style="' + (isRtl ? 'right' : 'left') + ':' + 100 / stepNr * i + '%"></span>');
              }
          }

          // Generate slider handles
          $elm.each(function (i) {
              if (this.type == 'range') {
                  // Set min / max / step properties for all inputs
                  $$2(this).attr('min', min).attr('max', max).attr('step', step);
              }

              (hasProgress ? $progress : $track).append('<span class="mbsc-slider-handle-cont' + (isRange && !i ? ' mbsc-slider-handle-left' : '') + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="' + i + '"></span>' + (hasTooltip ? '<span class="mbsc-slider-tooltip"></span>' : '') + '</span>');
          });

          $tooltips = $parent.find('.mbsc-slider-tooltip');
      };

      that.___init = function () {
          if ($parent) {
              $parent.removeClass('mbsc-slider-has-tooltip');
              if (step != 1) {
                  $$2('.mbsc-slider-step', $track).remove();
              }
          }

          $parent = that._$parent;
          $track = that._$track;
          $progress = that._$progress;
          $elm = $parent.find('input');

          s = that.settings;
          min = that._min;
          max = that._max;
          that._step = step = settings.step === undefined ? +$elm.attr('step') || s.step : settings.step;
          that._live = getBoolAttr('data-live', s.live, $elm);
          hasTooltip = getBoolAttr('data-tooltip', s.tooltip, $elm);
          hasProgress = getBoolAttr('data-highlight', s.highlight, $elm) && $elm.length < 3;
          isRange = hasProgress && $elm.length == 2;
          isRtl = s.rtl;

          that._markupReady();
      };

      if (!inherit) {
          that.init();
      }
  };

  Slider.prototype = {
      _class: 'progress',
      _css: 'mbsc-progress mbsc-slider',
      _hasTheme: true,
      _hasLang: true,
      _hasDef: true,
      _defaults: {
          changeEvent: 'change',
          stopProp: true,
          min: 0,
          max: 100,
          step: 1,
          live: true,
          highlight: true,
          round: true,
          returnAffix: true
      }
  };

  classes.Slider = Slider;

  // Init mbsc-slider elements on page load
  autoInit('[mbsc-slider]', Slider);

  var Rating = function Rating(elm, settings, inherit) {
      var $progress,
          $track,
          max,
          min,
          empty,
          filled,
          s,
          that = this,
          $elm = $$2(elm);

      // Call the parent constructor
      Slider.call(this, elm, settings, true);

      that._update = function (v, value, index, percent, multiple, refresh) {
          $progress.css('width', getPercent(v, 0, max) + '%');

          // Display value in the specified container(s)
          if (!multiple && (value[index] != v || refresh)) {
              that._display(v);
          }

          // Return validated value
          return v;
      };

      that._markupReady = function () {
          var i,
              emptyString = '',
              filledString = '';

          $track = that._$track;
          $progress = that._$progress;

          s = that.settings;
          min = that._min;
          max = that._max;
          that._base = min;
          that._rounding = s.rtl ? 'floor' : 'ceil';
          empty = $elm.attr('data-empty') || s.empty;
          filled = $elm.attr('data-filled') || s.filled;

          for (i = 0; i < max; ++i) {
              emptyString += '<span class="mbsc-ic mbsc-ic-' + empty + '"></span>';
              filledString += '<span class="mbsc-ic mbsc-ic-' + filled + '"></span>';
          }

          $track.html(emptyString);
          $track.append($progress);
          $progress.html(filledString);

          $track.append('<span class="mbsc-rating-handle-cont' + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="0"></span>' + '</span>');
      };

      if (!inherit) {
          that.init();
      }
  };

  Rating.prototype = {
      _class: 'progress',
      _css: 'mbsc-progress mbsc-rating',
      _hasTheme: true,
      _hasLang: true,
      _hasDef: true,
      _defaults: {
          changeEvent: 'change',
          stopProp: true,
          min: 1,
          max: 5,
          step: 1,
          live: true,
          round: true,
          hover: true,
          highlight: true,
          returnAffix: true,
          empty: 'star',
          filled: 'star3'
      }
  };

  classes.Rating = Rating;

  // Init mbsc-rating elements on page load
  autoInit('[mbsc-rating]', Rating);

  var nr = 1;

  var CollapsibleBase = function () {
      function CollapsibleBase(elm, settings) {
          var _this = this;

          classCallCheck(this, CollapsibleBase);

          var content = void 0;
          var $header = void 0;
          var $content = void 0;
          var $elm = $$2(elm);

          this.settings = settings;

          this._isOpen = settings.isOpen || false;

          $elm.addClass('mbsc-collapsible ' + (this._isOpen ? 'mbsc-collapsible-open' : ''));

          if ($elm.hasClass('mbsc-card')) {
              // card enhance
              $header = $elm.find('.mbsc-card-header').eq(0).addClass('mbsc-collapsible-header');
              $content = $elm.find('.mbsc-card-content').eq(0).addClass('mbsc-collapsible-content');
          } else if ($elm.hasClass('mbsc-form-group') || $elm.hasClass('mbsc-form-group-inset')) {
              // form group enhance
              $header = $elm.find('.mbsc-form-group-title').eq(0).addClass('mbsc-collapsible-header');
              $content = $elm.find('.mbsc-form-group-content').eq(0).addClass('mbsc-collapsible-content');
          } else {
              // if it is used independently
              $header = $elm.find('.mbsc-collapsible-header').eq(0);
              $content = $elm.find('.mbsc-collapsible-content').eq(0);
          }

          content = $content[0];

          if (content && !content.id) {
              content.id = 'mbsc-collapsible-' + nr++;
          }

          if ($header.length && content) {
              var $collapsibleIcon = $$2('<span class="mbsc-collapsible-icon mbsc-ic mbsc-ic-arrow-down5"></span>');

              tap(this, $header, function () {
                  _this.collapse();
              });

              $header.attr('role', 'button').attr('aria-expanded', this._isOpen).attr('aria-controls', content.id).attr('tabindex', '0').on('mousedown', function (ev) {
                  // prevent focus on mouse down
                  ev.preventDefault();
              }).on('keydown', function (ev) {
                  if (ev.which === 32 || ev.keyCode == 13) {
                      //space or enter 
                      ev.preventDefault();
                      _this.collapse();
                  }
              }).append($collapsibleIcon);
          }

          elm.mbscInst = this;

          this._$header = $header;
          this._$content = $content;
          this._$elm = $elm;
          this._$accordionParent = $elm.parent('[mbsc-accordion], mbsc-accordion, .mbsc-accordion');

          this.show = this.show.bind(this);
          this.hide = this.hide.bind(this);
          this.toggle = this.toggle.bind(this);
      }

      createClass(CollapsibleBase, [{
          key: 'collapse',
          value: function collapse(show) {
              var $elm = this._$elm;
              var $content = this._$content;
              var removeHeight = function removeHeight() {
                  $content.off('transitionend', removeHeight).css('height', '');
              };

              if (show === undefined) {
                  show = !this._isOpen;
              }

              if (show && this._isOpen || !show && !this._isOpen || !$content.length) {
                  return;
              }

              if (show) {
                  if (hasTransition) {
                      $content.on('transitionend', removeHeight).css('height', $content[0].scrollHeight);
                  }
                  $elm.addClass('mbsc-collapsible-open');
              } else {
                  if (hasTransition) {
                      $content.css('height', getComputedStyle($content[0]).height);
                  }
                  setTimeout(function () {
                      $content.css('height', 0);
                      $elm.removeClass('mbsc-collapsible-open');
                  });
              }

              if (show && this._$accordionParent) {
                  this._$accordionParent.find('.mbsc-collapsible-open').each(function () {
                      if (this !== $elm[0]) {
                          this.mbscInst.hide();
                      }
                  });
              }

              this._isOpen = show;
              this._$header.attr('aria-expanded', this._isOpen);
          }
      }, {
          key: 'show',
          value: function show() {
              this.collapse(true);
          }
      }, {
          key: 'hide',
          value: function hide() {
              this.collapse(false);
          }
      }, {
          key: 'toggle',
          value: function toggle() {
              this.collapse();
          }
      }, {
          key: 'destroy',
          value: function destroy() {
              this._$elm.removeClass('mbsc-collapsible mbsc-collapsible-open');
              this._$content.removeClass('mbsc-collapsible-content');
              this._$header.removeClass('mbsc-collapsible-header').find('.mbsc-collapsible-icon').remove();
          }
      }]);
      return CollapsibleBase;
  }();

  classes.CollapsibleBase = CollapsibleBase;

  var id$1 = 0;

  function initControls($ctx, controls, s, shallow) {
      $$2('input,select,textarea,progress,button', $ctx).each(function () {
          var control = this,
              $control = $$2(control),

          //$parent = $control.parent(),
          type = getControlType($control);

          // Skip elements with data-enhance="false"
          if ($control.attr('data-enhance') != 'false' /* TRIALCOND */) {

                  if ($control.hasClass('mbsc-control')) {
                      if (control.mbscInst) {
                          control.mbscInst.option({
                              theme: s.theme,
                              lang: s.lang,
                              rtl: s.rtl,
                              onText: s.onText,
                              offText: s.offText,
                              stopProp: s.stopProp
                          });
                      }
                  } else {

                      if (!control.id) {
                          control.id = 'mbsc-form-control-' + ++id$1;
                      }

                      switch (type) {
                          case 'button':
                          case 'submit':
                              controls[control.id] = new Button(control, {
                                  theme: s.theme,
                                  rtl: s.rtl,
                                  tap: s.tap
                              });
                              break;
                          case 'switch':
                              controls[control.id] = new Switch(control, {
                                  theme: s.theme,
                                  lang: s.lang,
                                  rtl: s.rtl,
                                  tap: s.tap,
                                  onText: s.onText,
                                  offText: s.offText,
                                  stopProp: s.stopProp
                              });
                              break;
                          case 'checkbox':
                              controls[control.id] = new CheckBox(control, {
                                  tap: s.tap,
                                  theme: s.theme,
                                  rtl: s.rtl
                              });
                              break;
                          case 'range':
                              if (!$$2(control).parent().hasClass('mbsc-slider')) {
                                  controls[control.id] = new Slider(control, {
                                      theme: s.theme,
                                      lang: s.lang,
                                      rtl: s.rtl,
                                      stopProp: s.stopProp,
                                      labelStyle: s.labelStyle
                                  });
                              }
                              break;
                          case 'rating':
                              controls[control.id] = new Rating(control, {
                                  theme: s.theme,
                                  lang: s.lang,
                                  rtl: s.rtl,
                                  stopProp: s.stopProp
                              });
                              break;
                          case 'progress':
                              controls[control.id] = new Progress(control, {
                                  theme: s.theme,
                                  lang: s.lang,
                                  rtl: s.rtl,
                                  labelStyle: s.labelStyle
                              });
                              break;
                          case 'radio':
                              controls[control.id] = new Radio(control, {
                                  tap: s.tap,
                                  theme: s.theme,
                                  rtl: s.rtl
                              });
                              break;
                          case 'select':
                          case 'select-one':
                          case 'select-multiple':
                              controls[control.id] = new Select(control, {
                                  tap: s.tap,
                                  inputStyle: s.inputStyle,
                                  labelStyle: s.labelStyle,
                                  theme: s.theme,
                                  rtl: s.rtl
                              });
                              break;
                          case 'textarea':
                              controls[control.id] = new TextArea(control, {
                                  tap: s.tap,
                                  inputStyle: s.inputStyle,
                                  labelStyle: s.labelStyle,
                                  theme: s.theme,
                                  rtl: s.rtl
                              });
                              break;
                          case 'segmented':
                              controls[control.id] = new SegmentedItem(control, {
                                  theme: s.theme,
                                  rtl: s.rtl,
                                  tap: s.tap,
                                  inputStyle: s.inputStyle
                              });
                              break;
                          case 'stepper':
                              controls[control.id] = new Stepper(control, {
                                  theme: s.theme,
                                  rtl: s.rtl
                              });
                              break;
                          case 'hidden':
                              return;
                          default:
                              controls[control.id] = new Input(control, {
                                  tap: s.tap,
                                  inputStyle: s.inputStyle,
                                  labelStyle: s.labelStyle,
                                  theme: s.theme,
                                  rtl: s.rtl
                              });
                              break;
                      }
                  }
              }
      });

      $$2('[data-collapsible]:not(.mbsc-collapsible)', $ctx).each(function () {
          var control = this,
              $control = $$2(control),
              isOpen = $control.attr('data-open');

          if (!control.id) {
              control.id = 'mbsc-form-control-' + ++id$1;
          }

          controls[control.id] = new CollapsibleBase(control, { isOpen: isOpen !== undefined && isOpen != 'false' });
          instances[control.id] = controls[control.id];
      });

      // Set initial height for textareas
      if (!shallow) {
          sizeTextAreas();
      }
  }

  var innerStyle = 'position:absolute;left:0;top:0;';
  var style = innerStyle + 'right:0;bottom:0;overflow:hidden;z-index:-1;';
  var markup = '<div style="' + style + '"><div style="' + innerStyle + '"></div></div>' + '<div style="' + style + '"><div style="' + innerStyle + 'width:200%;height:200%;"></div></div>';

  function resizeObserver(el, callback, zone) {

      function reset() {
          expandChild.style.width = '100000px';
          expandChild.style.height = '100000px';

          expand.scrollLeft = 100000;
          expand.scrollTop = 100000;

          shrink.scrollLeft = 100000;
          shrink.scrollTop = 100000;
      }

      function checkHidden() {
          var now = new Date();
          hiddenRafId = 0;
          if (!stopCheck) {
              if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {
                  lastCheck = now;
                  reset();
              }
              if (!hiddenRafId) {
                  hiddenRafId = raf(checkHidden);
              }
          }
      }

      function onScroll() {
          if (!rafId) {
              rafId = raf(onResize);
          }
      }

      function onResize() {
          rafId = 0;
          reset();
          callback();
      }

      var expand = void 0;
      var expandChild = void 0;
      var hiddenRafId = void 0;
      var rafId = void 0;
      var shrink = void 0;
      var stopCheck = void 0;
      var lastCheck = 0;
      //let isHidden = true;

      var helper = document.createElement('div');

      helper.innerHTML = markup;
      helper.dir = 'ltr'; // Need this to work in rtl as well;
      shrink = helper.childNodes[1];
      expand = helper.childNodes[0];
      expandChild = expand.childNodes[0];

      el.appendChild(helper);

      expand.addEventListener('scroll', onScroll);
      shrink.addEventListener('scroll', onScroll);

      if (zone) {
          zone.runOutsideAngular(function () {
              raf(checkHidden);
          });
      } else {
          raf(checkHidden);
      }

      return {
          detach: function detach() {
              el.removeChild(helper);
              stopCheck = true;
          }
      };
  }

  var $activeElm;
  var preventShow;
  var themes = mobiscroll$3.themes;
  var needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7;
  var isAndroid = os == 'android';
  var isIOS = os == 'ios';
  var isIOS8 = isIOS && majorVersion == 8;
  var halfBorder$1 = isIOS && majorVersion > 7;
  var prevdef = function prevdef(ev) {
      ev.preventDefault();
  };

  var EDITABLE = 'input,select,textarea,button';
  var ALLOW_ENTER = 'textarea,button,input[type="button"],input[type="submit"]';
  var FOCUSABLE = EDITABLE + ',[tabindex="0"]';

  var Frame = function Frame(el, settings, inherit) {
      var //$ariaDiv,
      $ctx,
          $header,
          $lock,
          $markup,
          $overlay,
          $persp,
          $popup,
          $wnd,
          $wrapper,
          buttons,
          btn,
          ctx,
          doAnim,
          hasContext,
          isModal,
          isInserted,
          isPointer,
          markup,
          modalWidth,
          modalHeight,
          needsDimensions,
          needsLock,
          observer,
          overlay,
          popup,
          posDebounce,
          prevInst,
          s,
          scrollLock,
          touched,
          trigger,
          wndWidth,
          wndHeight,
          that = this,
          $elm = $$2(el),
          elmList = [],
          lastFocus = new Date();

      function onBtnStart(ev) {
          // Can't call preventDefault here, it kills page scroll
          if (btn) {
              btn.removeClass('mbsc-active');
          }

          btn = $$2(this);

          // Active button
          if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {
              btn.addClass('mbsc-active');
          }

          if (ev.type === 'mousedown') {
              $$2(document).on('mouseup', onBtnEnd);
          } else if (ev.type === 'pointerdown') {
              $$2(document).on('pointerup', onBtnEnd);
          }
      }

      function onBtnEnd(ev) {
          if (btn) {
              btn.removeClass('mbsc-active');
              btn = null;
          }

          if (ev.type === 'mouseup') {
              $$2(document).off('mouseup', onBtnEnd);
          } else if (ev.type === 'pointerup') {
              $$2(document).off('pointerup', onBtnEnd);
          }
      }

      function onWndKeyDown(ev) {
          if (mobiscroll$3.activeInstance == that) {
              if (ev.keyCode == 13 && (!$$2(ev.target).is(ALLOW_ENTER) || ev.shiftKey)) {
                  that.select();
              } else if (ev.keyCode == 27) {
                  that.cancel();
              }
          }
      }

      function onShow(prevFocus) {
          if (!prevFocus && !isAndroid && that._activeElm) {
              //overlay.focus();
              lastFocus = new Date();
              that._activeElm.focus();
          }
          //that.ariaMessage(s.ariaMessage);
      }

      function onHide(prevAnim) {
          var $activeEl = $activeElm,
              focus = s.focusOnClose;

          that._markupRemove();

          $markup.remove();

          if (isModal) {
              ctx.mbscModals--;

              if (s.scrollLock) {
                  ctx.mbscLock--;
              }

              if (!ctx.mbscLock) {
                  $lock.removeClass('mbsc-fr-lock');
              }

              if (needsLock) {
                  ctx.mbscIOSLock--;
                  if (!ctx.mbscIOSLock) {
                      $lock.removeClass('mbsc-fr-lock-ios');
                      $ctx.css({ top: '', left: '' });
                      $wnd.scrollLeft(ctx.mbscScrollLeft);
                      $wnd.scrollTop(ctx.mbscScrollTop);
                  }
              }

              // The follwing should be done only if no other
              // instance was opened during the hide animation
              if (!ctx.mbscModals) {
                  $lock.removeClass('mbsc-fr-lock-ctx');
              }

              if (!ctx.mbscModals || prevInst) {
                  // Put focus back to the last active element
                  if (!prevAnim) {
                      if (!$activeEl) {
                          $activeEl = $elm;
                      }
                      setTimeout(function () {
                          if (focus === undefined || focus === true) {
                              preventShow = true;
                              $activeEl[0].focus();
                          } else if (focus) {
                              $$2(focus)[0].focus();
                          }
                      }, 200);
                  }
              }
          }

          prevInst = undefined;
          isInserted = false;

          trigger('onHide');
      }

      function onPosition() {
          clearTimeout(posDebounce);
          posDebounce = setTimeout(function () {
              if (that.position(true)) {
                  // Trigger reflow, needed on iOS safari, when orientation is changed
                  popup.style.visibility = 'hidden';
                  popup.offsetHeight;
                  popup.style.visibility = '';
              }
          }, 200);
      }

      function onFocus(ev) {
          if (mobiscroll$3.activeInstance == that && ev.target.nodeType && !overlay.contains(ev.target) && new Date() - lastFocus > 100) {
              lastFocus = new Date();
              that._activeElm.focus();
          }
      }

      function insertMarkup(prevAnim, prevFocus) {

          function onAnimEnd() {
              $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);
              onShow(prevFocus);
          }

          // Show
          if (isModal) {
              $markup.appendTo($ctx);
          } else if ($elm.is('div') && !that._hasContent) {
              // Insert inside the element on which was initialized
              $elm.empty().append($markup);
          } else {
              // Insert after the element
              if ($elm.hasClass('mbsc-control')) {
                  var $wrap = $elm.closest('.mbsc-control-w');
                  $markup.insertAfter($wrap);
                  if ($wrap.hasClass('mbsc-select')) {
                      $wrap.addClass('mbsc-select-inline');
                  }
              } else {
                  $markup.insertAfter($elm);
              }
          }

          isInserted = true;

          that._markupInserted($markup);

          trigger('onMarkupInserted', {
              target: markup
          });

          if (isModal && s.closeOnOverlayTap) {
              var moved, target, startX, startY;

              $overlay.on('touchstart mousedown', function (ev) {
                  if (!target && ev.target == overlay) {
                      target = true;
                      moved = false;
                      startX = getCoord(ev, 'X');
                      startY = getCoord(ev, 'Y');
                  }
              }).on('touchmove mousemove', function (ev) {
                  if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {
                      moved = true;
                  }
              }).on('touchcancel', function () {
                  target = false;
              }).on('touchend click', function (ev) {
                  if (target && !moved) {
                      that.cancel();
                      if (ev.type == 'touchend') {
                          preventClick();
                      }
                  }
                  target = false;
              });
          }

          $markup.on('mousedown', '.mbsc-btn-e,.mbsc-fr-btn-e', prevdef).on('touchstart mousedown', function (ev) {
              // Need this to prevent opening of sidemenus or similar
              if (s.stopProp) {
                  ev.stopPropagation();
              }
          }).on('keydown', '.mbsc-fr-btn-e', function (ev) {
              if (ev.keyCode == 32) {
                  // Space
                  ev.preventDefault();
                  ev.stopPropagation();
                  this.click();
              }
          }).on('keydown', function (ev) {
              // Trap focus inside modal
              if (ev.keyCode == 32 && !$$2(ev.target).is(EDITABLE)) {
                  // Prevent page scroll on space press
                  ev.preventDefault();
              } else if (ev.keyCode == 9 && isModal && s.focusTrap) {
                  // Tab
                  var $focusable = $markup.find(FOCUSABLE).filter(function () {
                      return this.offsetWidth > 0 || this.offsetHeight > 0;
                  }),
                      index = $focusable.index($$2(':focus', $markup)),
                      i = $focusable.length - 1,
                      target = 0;

                  if (ev.shiftKey) {
                      i = 0;
                      target = -1;
                  }

                  if (index === i) {
                      $focusable.eq(target)[0].focus();
                      ev.preventDefault();
                  }
              }
          }).on('touchstart mousedown pointerdown', '.mbsc-fr-btn-e', onBtnStart).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);

          // Need event capture for this
          markup.addEventListener('touchstart', function () {
              if (!touched) {
                  touched = true;
                  $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
              }
          }, true);

          // Init buttons
          $$2.each(buttons, function (i, b) {
              that.tap($$2('.mbsc-fr-btn' + i, $markup), function (ev) {
                  b = isString(b) ? that.buttons[b] : b;
                  (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);
              }, true);
          });

          that._attachEvents($markup);

          // Set position
          if (that.position() === false) {
              return;
          }

          if (isModal || that._checkSize) {
              observer = resizeObserver(markup, onPosition, s.zone);
          }

          if (isModal) {
              $markup.removeClass('mbsc-fr-pos');
              if (doAnim && !prevAnim) {
                  $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
              } else {
                  onShow(prevFocus);
              }
          }

          trigger('onShow', {
              target: markup,
              valueText: that._tempValue
          });
      }

      function show(beforeShow, $elm) {
          if (that._isVisible) {
              return;
          }

          if (beforeShow) {
              beforeShow();
          }

          if (that.show() !== false) {
              $activeElm = $elm;
          }
      }

      function set() {
          that._fillValue();
          trigger('onSet', {
              valueText: that._value
          });
      }

      function cancel() {
          trigger('onCancel', {
              valueText: that._value
          });
      }

      function clear() {
          that.setVal(null, true);
      }

      // Call the parent constructor
      Base.call(this, el, settings, true);

      /**
       * Positions the scroller on the screen.
       */
      that.position = function (check) {
          var anchor,
              anchorWidth,
              anchorHeight,
              anchorPos,
              anchorTop,
              anchorLeft,
              arrow,
              arrowWidth,
              arrowHeight,
              docHeight,
              docWidth,
              isWrapped,
              newHeight,
              newWidth,
              oldHeight,
              oldWidth,
              width,
              top,
              left,
              css = {},
              scrollLeft = 0,
              scrollTop = 0,
              minWidth = 0,
              totalWidth = 0;

          if (!isInserted) {
              return false;
          }

          oldWidth = wndWidth;
          oldHeight = wndHeight;
          newHeight = markup.offsetHeight;
          newWidth = markup.offsetWidth;

          if (!newWidth || !newHeight || wndWidth === newWidth && wndHeight === newHeight && check) {
              return;
          }

          if (that._checkResp(newWidth)) {
              return false;
          }

          wndWidth = newWidth;
          wndHeight = newHeight;

          if (that._isFullScreen || /top|bottom/.test(s.display)) {
              // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)
              $popup.width(newWidth);
          } else if (isModal) {
              // Reset width
              $wrapper.width('');
          }

          that._position($markup);

          // Call position for nested mobiscroll components
          // $('.mbsc-comp', $markup).each(function () {
          //     var inst = instances[this.id];
          //     if (inst && inst !== that && inst.position) {
          //         inst.position();
          //     }
          // });

          if (!that._isFullScreen && /center|bubble/.test(s.display)) {
              $$2('.mbsc-w-p', $markup).each(function () {
                  // Need fractional values here, so offsetWidth is not ok
                  width = this.getBoundingClientRect().width;
                  totalWidth += width;
                  minWidth = width > minWidth ? width : minWidth;
              });

              isWrapped = totalWidth > newWidth - 16 || s.tabs === true;

              $wrapper.css({
                  'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),
                  'white-space': isWrapped ? '' : 'nowrap'
              });
          }

          if (trigger('onPosition', {
              target: markup,
              popup: popup,
              hasTabs: isWrapped,
              oldWidth: oldWidth,
              oldHeight: oldHeight,
              windowWidth: newWidth,
              windowHeight: newHeight
          }) === false || !isModal) {
              return;
          }

          if (needsDimensions) {
              scrollLeft = $wnd.scrollLeft();
              scrollTop = $wnd.scrollTop();
              if (wndWidth) {
                  $persp.css({ width: '', height: '' });
              }
          }

          modalWidth = popup.offsetWidth;
          modalHeight = popup.offsetHeight;

          scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;

          if (s.display == 'center') {
              left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);
              top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);
          } else if (s.display == 'bubble') {
              anchor = s.anchor === undefined ? $elm : $$2(s.anchor);

              arrow = $$2('.mbsc-fr-arr-i', $markup)[0];
              anchorPos = anchor.offset();
              anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);
              anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);

              anchorWidth = anchor[0].offsetWidth;
              anchorHeight = anchor[0].offsetHeight;

              arrowWidth = arrow.offsetWidth;
              arrowHeight = arrow.offsetHeight;

              // Horizontal positioning
              left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3);

              // Vertical positioning
              // Below the input
              top = anchorTop + anchorHeight + arrowHeight / 2;
              if (top + modalHeight + 8 > scrollTop + newHeight && anchorTop - modalHeight - arrowHeight / 2 > scrollTop) {
                  $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top');
                  // Above the input
                  top = anchorTop - modalHeight - arrowHeight / 2;
              } else {
                  $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');
              }

              // Set arrow position
              $$2('.mbsc-fr-arr', $markup).css({
                  left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)
              });

              // Lock scroll only if popup is entirely in the viewport
              scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;
          } else {
              left = scrollLeft;
              top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);
          }

          if (needsDimensions) {
              // If top + modal height > doc height, increase doc height
              docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$2(document).height());
              docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$2(document).width());
              $persp.css({ width: docWidth, height: docHeight });

              // Check if scroll needed
              if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {
                  $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));
              }
          }

          css.top = Math.floor(top);
          css.left = Math.floor(left);

          $popup.css(css);

          return true;
      };

      /**
       * Show mobiscroll on focus and click event of the parameter.
       * @param {HTMLElement} elm - Events will be attached to this element.
       * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
       */
      that.attachShow = function (elm, beforeShow) {
          var $label,
              $elm = $$2(elm).off('.mbsc'),
              readOnly = $elm.prop('readonly');

          if (s.display !== 'inline') {
              if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {
                  $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {
                      // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
                      ev.preventDefault();
                  }).on('focus.mbsc', function () {
                      if (that._isVisible) {
                          // Don't allow input focus if mobiscroll is being opened
                          this.blur();
                      }
                  });

                  $label = $$2('label[for="' + $elm.attr('id') + '"]');

                  if (!$label.length) {
                      $label = $elm.closest('label');
                  }
              }

              if (!$elm.is('select')) {
                  if (s.showOnFocus) {
                      $elm.on('focus.mbsc', function () {
                          if (!preventShow) {
                              show(beforeShow, $elm);
                          } else {
                              preventShow = false;
                          }
                      });
                  }

                  if (s.showOnTap) {
                      $elm.on('keydown.mbsc', function (ev) {
                          if (ev.keyCode == 32 || ev.keyCode == 13) {
                              // Space or Enter
                              ev.preventDefault();
                              ev.stopPropagation();
                              show(beforeShow, $elm);
                          }
                      });

                      that.tap($elm, function (ev) {
                          if (ev.isMbscTap) {
                              touched = true;
                          }
                          show(beforeShow, $elm);
                      });

                      if ($label && $label.length) {
                          that.tap($label, function (ev) {
                              ev.preventDefault();
                              if (ev.target !== $elm[0]) {
                                  show(beforeShow, $elm);
                              }
                          });
                      }
                  }
              }

              elmList.push({
                  readOnly: readOnly,
                  el: $elm,
                  lbl: $label
              });
          }
      };

      /**
       * Set button handler.
       */
      that.select = function () {
          if (isModal) {
              that.hide(false, 'set', false, set);
          } else {
              set();
          }
      };

      /**
       * Cancel and hide the scroller instance.
       */
      that.cancel = function () {
          if (isModal) {
              that.hide(false, 'cancel', false, cancel);
          } else {
              cancel();
          }
      };

      /**
       * Clear button handler.
       */
      that.clear = function () {
          that._clearValue();
          trigger('onClear');
          if (isModal && that._isVisible && !that.live) {
              that.hide(false, 'clear', false, clear);
          } else {
              clear();
          }
      };

      /**
       * Enables the scroller and the associated input.
       */
      that.enable = function () {
          s.disabled = false;
          $$2.each(elmList, function (i, v) {
              if (v.el.is('input,select')) {
                  v.el[0].disabled = false;
              }
          });
      };

      /**
       * Disables the scroller and the associated input.
       */
      that.disable = function () {
          s.disabled = true;
          $$2.each(elmList, function (i, v) {
              if (v.el.is('input,select')) {
                  v.el[0].disabled = true;
              }
          });
      };

      /**
       * Shows the scroller instance.
       * @param {Boolean} prevAnim - Prevent animation if true
       * @param {Boolean} prevFocus - Prevent focusing if true
       */
      that.show = function (prevAnim, prevFocus) {
          var hasButtons, html, scrollLeft, scrollTop;

          if (s.disabled || that._isVisible) {
              return;
          }

          // Parse value from input
          that._readValue();

          if (trigger('onBeforeShow') === false) {
              return false;
          }

          $activeElm = null;

          doAnim = s.animate;
          buttons = s.buttons || [];

          needsDimensions = hasContext || s.display == 'bubble';
          needsLock = needsFixed && !needsDimensions && s.scrollLock;

          hasButtons = buttons.length > 0;

          //touched = false;

          if (doAnim !== false) {
              if (s.display == 'top') {
                  doAnim = doAnim || 'slidedown';
              } else if (s.display == 'bottom') {
                  doAnim = doAnim || 'slideup';
              } else if (s.display == 'center' || s.display == 'bubble') {
                  doAnim = doAnim || 'pop';
              }
          }

          if (isModal) {
              wndWidth = 0;
              wndHeight = 0;

              if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {
                  //$lock.scrollTop(0);
                  ctx.mbscScrollTop = scrollTop = Math.max(0, $wnd.scrollTop());
                  ctx.mbscScrollLeft = scrollLeft = Math.max(0, $wnd.scrollLeft());
                  $ctx.css({
                      top: -scrollTop + 'px',
                      left: -scrollLeft + 'px'
                  });
              }

              $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : ''));

              // Hide virtual keyboard
              if ($$2(document.activeElement).is('input,textarea')) {
                  document.activeElement.blur();
              }

              // Save active instance to previous
              prevInst = mobiscroll$3.activeInstance;

              // Set active instance
              mobiscroll$3.activeInstance = that;

              // Keep track of modals opened per context
              ctx.mbscModals = (ctx.mbscModals || 0) + 1;
              if (needsLock) {
                  ctx.mbscIOSLock = (ctx.mbscIOSLock || 0) + 1;
              }
              if (s.scrollLock) {
                  ctx.mbscLock = (ctx.mbscLock || 0) + 1;
              }
          }

          // Create wheels containers
          html = '<div lang="' + s.lang + '" class="mbsc-fr mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (isModal ? ' mbsc-fr-pos' + (s.showOverlay ? '' : ' mbsc-fr-no-overlay') : '') + (isPointer ? ' mbsc-fr-pointer' : '') + (halfBorder$1 ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + (needsLock ? ' mbsc-platform-ios' : '') + (hasButtons ? buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '' : ' mbsc-fr-nobtn') + '">' + (isModal ? '<div class="mbsc-fr-persp">' + (s.showOverlay ? '<div class="mbsc-fr-overlay"></div>' : '') + // Overlay
          '<div role="dialog" class="mbsc-fr-scroll">' : '') + '<div class="mbsc-fr-popup' + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '">' + ( // Popup
          s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + ( // Bubble arrow
          isModal ? '<div class="mbsc-fr-focus" tabindex="-1"></div>' : '') + '<div class="mbsc-fr-w">' + ( // Popup content
          //'<div aria-live="assertive" class="mbsc-fr-aria mbsc-fr-hdn"></div>' +
          s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
          '<div class="mbsc-fr-c">'; // Wheel group container

          html += that._generateContent();

          html += '</div>';

          if (hasButtons) {
              var b,
                  i,
                  j,
                  l = buttons.length;

              html += '<div class="mbsc-fr-btn-cont">';
              for (i = 0; i < buttons.length; i++) {
                  j = s.btnReverse ? l - i - 1 : i;
                  b = buttons[j];
                  b = isString(b) ? that.buttons[b] : b;

                  if (b.handler === 'set') {
                      b.parentClass = 'mbsc-fr-btn-s';
                  }

                  if (b.handler === 'cancel') {
                      b.parentClass = 'mbsc-fr-btn-c';
                  }

                  html += '<div' + (s.btnWidth ? ' style="width:' + 100 / buttons.length + '%"' : '') + ' class="mbsc-fr-btn-w ' + (b.parentClass || '') + '">' + '<div tabindex="0" role="button" class="mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' + (b.cssClass === undefined ? s.btnClass : b.cssClass) + (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '">' + (b.text || '') + '</div></div>';
              }
              html += '</div>';
          }
          html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');

          $markup = $$2(html);
          $persp = $$2('.mbsc-fr-persp', $markup);
          $overlay = $$2('.mbsc-fr-scroll', $markup);
          $wrapper = $$2('.mbsc-fr-w', $markup);
          $popup = $$2('.mbsc-fr-popup', $markup);
          $header = $$2('.mbsc-fr-hdr', $markup);
          //$ariaDiv = $('.mbsc-fr-aria', $markup);

          markup = $markup[0];
          overlay = $overlay[0];
          popup = $popup[0];

          that._activeElm = $$2('.mbsc-fr-focus', $markup)[0];
          that._markup = $markup;
          that._isVisible = true;
          that.markup = markup;

          that._markupReady($markup);

          trigger('onMarkupReady', {
              target: markup
          });

          // Attach events
          if (isModal) {
              // Enter / ESC
              $$2(window).on('keydown', onWndKeyDown);

              // Prevent scroll if not specified otherwise
              if (s.scrollLock) {
                  $markup.on('touchmove mousewheel wheel', function (ev) {
                      if (scrollLock) {
                          ev.preventDefault();
                      }
                  });
              }

              if (s.focusTrap) {
                  $wnd.on('focusin', onFocus);
              }
          }

          if (isModal) {
              // Wait for the toolbar and addressbar to appear on iOS
              setTimeout(function () {
                  insertMarkup(prevAnim, prevFocus);
              }, needsLock ? 100 : 0);
          } else {
              insertMarkup(prevAnim, prevFocus);
          }
      };

      /**
       * Hides the scroller instance.
       */
      that.hide = function (prevAnim, btn, force, callback) {

          function onAnimEnd() {
              $markup.off(animEnd, onAnimEnd);
              onHide(prevAnim);
          }

          // If onClose handler returns false, prevent hide
          if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {
              valueText: that._tempValue,
              button: btn
          }) === false) {
              return false;
          }

          that._isVisible = false;

          if (observer) {
              observer.detach();
              observer = null;
          }

          if (isModal) {
              if ($$2(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {
                  document.activeElement.blur();
              }
              if (mobiscroll$3.activeInstance == that) {
                  mobiscroll$3.activeInstance = prevInst;
              }
              $$2(window).off('keydown', onWndKeyDown);
              $wnd.off('focusin', onFocus);
          }

          // Hide wheels and overlay
          if ($markup) {
              if (isModal && doAnim && !prevAnim) {
                  $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
              } else {
                  onHide(prevAnim);
              }

              that._detachEvents($markup);
          }

          if (callback) {
              callback();
          }

          // For validation
          $elm.trigger('blur');

          trigger('onClose', {
              valueText: that._value
          });
      };

      // that.ariaMessage = function (txt) {
      //     $ariaDiv.html('');
      //     setTimeout(function () {
      //         $ariaDiv.html(txt);
      //     }, 100);
      // };

      /**
       * Return true if the scroller is currently visible.
       */
      that.isVisible = function () {
          return that._isVisible;
      };

      // Protected functions to override

      that.setVal = noop;

      that.getVal = noop;

      that._generateContent = noop;

      that._attachEvents = noop;

      that._detachEvents = noop;

      that._readValue = noop;

      that._clearValue = noop;

      that._fillValue = noop;

      that._markupReady = noop;

      that._markupInserted = noop;

      that._markupRemove = noop;

      that._position = noop;

      that.__processSettings = noop;

      that.__init = noop;

      that.__destroy = noop;

      // Generic frame functions

      /**
       * Destroys the mobiscroll instance.
       */
      that._destroy = function () {
          // Force hide without animation
          that.hide(true, false, true);

          $elm.off('.mbsc');

          // Remove all events from elements
          $$2.each(elmList, function (i, v) {
              v.el.off('.mbsc').prop('readonly', v.readOnly);
              if (v.lbl) {
                  v.lbl.off('.mbsc');
              }
          });

          that.__destroy();
      };

      that._updateHeader = function () {
          var t = s.headerText,
              txt = t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\{value\}/i, that._tempValue) : '';
          $header.html(txt || '&nbsp;');
      };

      that._processSettings = function (resp) {
          var b, i;

          that.__processSettings(resp);

          isPointer = !s.touchUi;

          if (isPointer) {
              s.display = resp.display || settings.display || 'bubble';
              s.buttons = resp.buttons || settings.buttons || [];
              s.showOverlay = resp.showOverlay || settings.showOverlay || false;
          }

          // Add default buttons
          s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []);

          // Hide header text in inline mode by default
          s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;

          buttons = s.buttons || [];
          isModal = s.display !== 'inline';
          hasContext = s.context != 'body';
          $ctx = $$2(s.context);
          $lock = hasContext ? $ctx : $$2('body,html');
          ctx = $ctx[0];

          that._$window = $wnd = $$2(hasContext ? s.context : window);
          that.live = true;

          // If no set button is found, live mode is activated
          for (i = 0; i < buttons.length; i++) {
              b = buttons[i];
              if (b == 'ok' || b == 'set' || b.handler == 'set') {
                  that.live = false;
              }
          }

          that.buttons.set = {
              text: s.setText,
              icon: s.setIcon,
              handler: 'set'
          };

          that.buttons.cancel = {
              text: s.cancelText,
              icon: s.cancelIcon,
              handler: 'cancel'
          };

          that.buttons.close = {
              text: s.closeText,
              icon: s.closeIcon,
              handler: 'cancel'
          };

          that.buttons.clear = {
              text: s.clearText,
              icon: s.clearIcon,
              handler: 'clear'
          };

          that._isInput = $elm.is('input');
      };

      /**
       * Scroller initialization.
       */
      that._init = function (newSettings) {
          var wasVisible = that._isVisible,
              wasReady = wasVisible && !$markup.hasClass('mbsc-fr-pos');

          if (wasVisible) {
              that.hide(true, false, true);
          }

          // Unbind all events (if re-init)
          $elm.off('.mbsc');

          that.__init(newSettings);

          that._isLiquid = s.layout == 'liquid';

          if (isModal) {
              that._readValue();
              if (!that._hasContent && !s.skipShow) {
                  that.attachShow($elm);
              }
              if (wasVisible) {
                  that.show(wasReady);
              }
          } else {
              that.show();
          }

          $elm.removeClass('mbsc-cloak').filter('input, select, textarea').on('change.mbsc', function () {
              if (!that._preventChange) {
                  that.setVal($elm.val(), true, false);
              }
              that._preventChange = false;
          });
      };

      that.buttons = {};
      that.handlers = {
          set: that.select,
          cancel: that.cancel,
          clear: that.clear
      };

      that._value = null;

      that._isValid = true;
      that._isVisible = false;

      // Constructor

      s = that.settings;
      trigger = that.trigger;

      if (!inherit) {
          that.init();
      }
  };

  Frame.prototype._defaults = {
      // Localization
      lang: 'en',
      setText: 'Set',
      selectedText: '{count} selected',
      closeText: 'Close',
      cancelText: 'Cancel',
      clearText: 'Clear',
      // Options
      context: 'body',
      maxPopupWidth: 600,
      disabled: false,
      closeOnOverlayTap: true,
      showOnFocus: isAndroid || isIOS, // Needed for ion-input
      showOnTap: true,
      display: 'center',
      scroll: true,
      scrollLock: true,
      showOverlay: true,
      tap: true,
      touchUi: true,
      btnClass: 'mbsc-fr-btn',
      btnWidth: true,
      focusTrap: true,
      focusOnClose: !isIOS8 // Temporary for iOS8
  };

  classes.Frame = Frame;

  themes.frame.mobiscroll = {
      headerText: false,
      btnWidth: false
  };

  themes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {
      rows: 5,
      showLabel: false,
      selectedLineBorder: 1,
      weekDays: 'min',
      checkIcon: 'ion-ios7-checkmark-empty',
      btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
      btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
      btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
      btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'
  });

  if (isBrowser) {
      // Prevent re-show on window focus
      $$2(window).on('focus', function () {
          if ($activeElm) {
              preventShow = true;
          }
      });
  }

  var Popup = function Popup(el, settings, inherit) {

      function addContent($m) {
          /* TRIAL */

          if (!$$2('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c') /* TRIALCOND */) {
                  $$2('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());

                  if (!$$2('.mbsc-w-p', $m).length) {
                      $$2('.mbsc-fr-c', $m).addClass('mbsc-w-p');
                  }
              }
      }

      var s,
          $prev,
          $elm = $$2(el),
          that = this;

      // Call the parent constructor
      Frame.call(this, el, settings, true);

      /* TRIALFUNC */

      that._generateContent = function () {
          return '';
      };

      that._markupReady = function ($m) {
          if (s.display != 'inline') {
              addContent($m);
          }
      };

      that._markupInserted = function ($m) {

          if (s.display == 'inline') {
              addContent($m);
          }

          $m.trigger('mbsc-enhance', [{
              theme: s.theme,
              lang: s.lang
          }]);
      };

      that._markupRemove = function () {
          $elm.hide();

          if ($prev && $prev.parent().length) {
              $prev.after($elm);
          }
      };

      that.__processSettings = function () {
          s = that.settings;

          that.buttons.ok = {
              text: s.okText,
              icon: s.okIcon,
              handler: 'set'
          };

          s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);

          if (!$prev && $elm.parent().length) {
              $prev = $$2(document.createComment('popup'));
              $elm.before($prev);
          }

          $elm.hide();
      };

      // Constructor
      if (!inherit) {
          that.init();
      }
  };

  Popup.prototype = {
      _hasDef: true,
      _hasTheme: true,
      _hasContent: true,
      _hasLang: true,
      _responsive: true,
      _class: 'popup',
      _defaults: extend$1({}, Frame.prototype._defaults, {
          compClass: 'mbsc-wdg',
          okText: 'OK',
          headerText: false
      })
  };

  classes.Popup = Popup;
  classes.Widget = Popup;



  mobiscroll$3.themes.popup = mobiscroll$3.themes.frame;

  var hasPromise = isBrowser && !!window.Promise;
  var popupQueue = [];
  var notificationQueue = [];
  var activeNotification = void 0;

  function showPopup(popup) {
      if (!popupQueue.length) {
          popup.show();
      }
      popupQueue.push(popup);
  }

  function showNotification(notification) {
      var isAny = notificationQueue.length;
      notificationQueue.push(notification);
      // Only show notification if no popup is visible
      // otherwise postpone it until popup is closed
      if (!popupQueue.length) {
          // If there's a visible notification, hide it.
          // The notification will be shown after hide animation is complete
          if (isAny) {
              notificationQueue[0].hide();
          } else {
              // Prevent focus on show for notifications
              notification.show(false, true);
          }
      }
  }

  function getSettings(queue, settings, resolve, more) {
      //const active = mobiscroll.activeInstance;
      return extend$1({
          display: settings.display || 'center',
          cssClass: 'mbsc-alert',
          okText: settings.okText,
          cancelText: settings.cancelText,
          context: settings.context,
          theme: settings.theme,
          closeOnOverlayTap: false,
          onBeforeClose: function onBeforeClose() {
              queue.shift();
          },
          onHide: function onHide(ev, inst) {
              //mobiscroll.activeInstance = active;
              if (resolve) {
                  resolve(inst._resolve);
              }
              if (settings.callback) {
                  settings.callback(inst._resolve);
              }
              if (inst) {
                  inst.destroy();
              }
              // Show next
              if (popupQueue.length) {
                  popupQueue[0].show();
              } else if (notificationQueue.length) {
                  // Prevent focus on show for notifications
                  notificationQueue[0].show(false, true);
              }
          }
      }, more);
  }

  function getMessage(settings) {
      return (settings.title ? '<h2>' + settings.title + '</h2>' : '') + '<p>' + (settings.message || '') + '</p>';
  }

  function showAlert(popup, settings, resolve) {
      var inst = new Popup(popup, getSettings(popupQueue, settings, resolve));
      showPopup(inst);
  }

  function showConfirm(popup, settings, resolve) {
      var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
          buttons: ['cancel', 'ok'],
          onSet: function onSet() {
              inst._resolve = true;
          }
      }));
      inst._resolve = false;
      showPopup(inst);
  }

  function showPrompt(popup, settings, resolve) {
      var input = void 0,
          label = void 0;
      var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
          buttons: ['cancel', 'ok'],
          onMarkupReady: function onMarkupReady(event, inst) {
              var s = inst.settings;
              label = inst._markup.find('label');
              label.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
              input = inst._markup.find('input')[0];
              setTimeout(function () {
                  input.focus();
                  input.setSelectionRange(0, input.value.length);
              }, 300);
          },
          onSet: function onSet() {
              inst._resolve = input.value;
          }
      }));
      inst._resolve = null;
      showPopup(inst);
  }

  function showSnackbar(popup, settings, resolve, cssClass, animation) {
      var notificationTimer = void 0;
      var inst = new Popup(popup, getSettings(notificationQueue, settings, resolve, {
          display: settings.display || 'bottom',
          animate: animation,
          cssClass: (cssClass || 'mbsc-snackbar') + (settings.color ? ' mbsc-' + settings.color : ''),
          scrollLock: false,
          focusTrap: false,
          buttons: [],
          onMarkupReady: function onMarkupReady(event, inst) {
              var s = inst.settings;
              var button = inst._markup.find('button');
              button.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
          },
          onShow: function onShow(ev, inst) {
              activeNotification = inst;
              if (settings.duration !== false) {
                  notificationTimer = setTimeout(function () {
                      if (inst) {
                          inst.hide();
                      }
                  }, settings.duration || 3000);
              }
              if (settings.button) {
                  inst.tap($$2('.mbsc-snackbar-btn', ev.target), function () {
                      inst.hide();
                      if (settings.button.action) {
                          settings.button.action.call(this);
                      }
                  });
              }
          },
          onClose: function onClose() {
              activeNotification = null;
              clearTimeout(notificationTimer);
          }
      }));
      showNotification(inst);
  }

  function showToast(popup, settings, resolve) {
      showSnackbar(popup, settings, resolve, 'mbsc-toast', 'fade');
  }

  function show(func, popup, settings) {
      var p = void 0;
      if (hasPromise) {
          p = new Promise(function (resolve) {
              func(popup, settings, resolve);
          });
      } else {
          func(popup, settings);
      }
      return p;
  }

  mobiscroll$3.alert = function (settings) {
      var popup = document.createElement('div');
      popup.innerHTML = getMessage(settings);
      return show(showAlert, popup, settings);
  };

  mobiscroll$3.confirm = function (settings) {
      var popup = document.createElement('div');
      popup.innerHTML = getMessage(settings);
      return show(showConfirm, popup, settings);
  };

  mobiscroll$3.prompt = function (settings) {
      var popup = document.createElement('div');
      popup.innerHTML = getMessage(settings) + '<label class="mbsc-input">' + (settings.label ? '<span class="mbsc-label">' + settings.label + '</span>' : '') + '<input tabindex="0" type="' + (settings.inputType || 'text') + '" placeholder="' + (settings.placeholder || '') + '" value="' + (settings.value || '') + '">' + '</label>';
      return show(showPrompt, popup, settings);
  };

  mobiscroll$3.snackbar = function (settings) {
      var popup = document.createElement('div'),
          btn = settings.button;
      popup.innerHTML = '<div class="mbsc-snackbar-cont"><div class="mbsc-snackbar-msg">' + (settings.message || '') + '</div>' + (btn ? '<button class="mbsc-snackbar-btn mbsc-btn mbsc-btn-flat">' + (btn.icon ? '<span class="mbsc-ic ' + (btn.text ? 'mbsc-btn-ic ' : '') + 'mbsc-ic-' + btn.icon + '"></span>' : '') + (btn.text || '') + '</button>' : '') + '</div>';
      return show(showSnackbar, popup, settings);
  };

  mobiscroll$3.toast = function (settings) {
      var popup = document.createElement('div');
      popup.innerHTML = '<div class="mbsc-toast-msg">' + (settings.message || '') + '</div>';
      return show(showToast, popup, settings);
  };

  mobiscroll$3.notification = {
      dismiss: function dismiss() {
          if (activeNotification) {
              activeNotification.hide();
          }
      }
  };

  var halfBorder = os == 'ios' && majorVersion > 7;

  var Form = function Form(el, settings) {

      var s,
          cssClass = '',
          $ctx = $$2(el),
          controls = {},
          that = this;

      function touched() {
          $ctx.removeClass('mbsc-no-touch');
      }

      // Call the parent constructor
      Base.call(this, el, settings, true);

      that.refresh = function (shallow) {
          if (s.enhance) {
              initControls($ctx, controls, s, shallow);
          }
      };

      /**
       * Form initialization.
       */
      that._init = function () {
          if (!mobiscroll$3.themes.form[s.theme]) {
              s.theme = 'mobiscroll';
          }

          if (!$ctx.hasClass('mbsc-form')) {
              $ctx.on('touchstart', touched).show();
          }

          if (cssClass) {
              $ctx.removeClass(cssClass);
          }

          // --- TRIAL SERVER CODE START ---
          cssClass = 'mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.inputStyle == 'box' ? ' mbsc-form-box' : '') + (s.inputStyle == 'outline' ? ' mbsc-form-outline' : '');
          // --- TRIAL SERVER CODE END ---

          $ctx.addClass(cssClass).removeClass('mbsc-cloak');

          that.refresh();
      };

      /**
       * Destroys the mobiscroll instance.
       */
      that._destroy = function () {
          $ctx.removeClass(cssClass).off('touchstart', touched);

          for (var id in controls) {
              controls[id].destroy();
          }
      };

      /**
       * Object with the underlying form control instances
       * keys are the element id's
       */
      that.controls = controls;

      // Constructor

      s = that.settings;

      that.init();
  };

  // Extend defaults
  Form.prototype = {
      _hasDef: true,
      _hasTheme: true,
      _hasLang: true,
      _class: 'form',
      _defaults: {
          tap: hasGhostClick,
          stopProp: true,
          rtl: false,
          enhance: true
      }
  };

  classes.Form = Form;

  // Init mbsc-form elements on page load
  autoInit('[mbsc-enhance],[mbsc-form]', Form, true);

  // Page
  // ---

  var Page = function Page(el, settings) {
      var cssClass = '',
          $elm = $$2(el),
          that = this,
          s = that.settings;

      // Call the parent constructor
      Base.call(this, el, settings, true);

      /**
       * Page initialization.
       */
      that._init = function () {
          var ctx = s.context,
              $ctx = $$2(ctx),
              $topMenu = $ctx.find('.mbsc-ms-top .mbsc-ms'),
              $bottomMenu = $ctx.find('.mbsc-ms-bottom .mbsc-ms'),
              css = {};

          if (ctx == 'body') {
              $$2('body,html').addClass('mbsc-page-ctx');
          } else {
              $ctx.addClass('mbsc-page-ctx');
          }

          if (cssClass) {
              $elm.removeClass(cssClass);
          }

          if ($topMenu.length) {
              css.paddingTop = $topMenu[0].offsetHeight;
          }

          if ($bottomMenu.length) {
              css.paddingBottom = $bottomMenu[0].offsetHeight;
          }

          cssClass = 'mbsc-page mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');

          $elm.addClass(cssClass).removeClass('mbsc-cloak').css(css);
      };

      /**
       * Destroys the mobiscroll instance.
       */
      that._destroy = function () {
          $elm.removeClass(cssClass);
      };

      // Constructor

      s = that.settings;

      that.init();
  };

  // Extend defaults
  Page.prototype = {
      _hasDef: true,
      _hasTheme: true,
      _hasLang: true,
      _class: 'page',
      _defaults: {
          context: 'body'
      }
  };

  classes.Page = Page;

  mobiscroll$3.themes.page.mobiscroll = {};

  // ---
  // Page end

  // Init mbsc-page elements on page load or when mbsc-enhance event is triggeres
  autoInit('[mbsc-page]', Page);

  var _class$2;
  var _temp$2;

  var _extends$3 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
              }
          }
      }return target;
  };

  var MbscPage = function (_MbscBase) {
      inherits(MbscPage, _MbscBase);

      function MbscPage(props) {
          classCallCheck(this, MbscPage);
          return possibleConstructorReturn(this, (MbscPage.__proto__ || Object.getPrototypeOf(MbscPage)).call(this, props));
      }

      createClass(MbscPage, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              // get settings from state
              var settings = this.getSettingsFromProps(this.props);
              // initialize the mobiscroll
              this.instance = new Page(ReactDOM.findDOMNode(this), settings);
          }
      }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps) {
              var thisOptions = this.getSettingsFromProps(this.props);
              var nextOptions = this.getSettingsFromProps(nextProps);
              // check if the options or the value changed
              var updateOptions = !deepCompare(thisOptions, nextOptions);

              // save what should be updated inside mobiscroll
              this.optimizeUpdate = {
                  updateOptions: updateOptions
              };
              // component should update always, since it's a wrapper component, and it should not block any context
              return true;
          }
      }, {
          key: 'render',
          value: function render() {
              return React.createElement('div', { className: this.initialCssClass }, this.props.children);
          }
      }]);
      return MbscPage;
  }(MbscBase);

  MbscPage.propTypes = _extends$3({}, MbscPage.propTypes, CorePropTypes, {
      onInit: PropTypes.func
  });

  var MbscNote = (_temp$2 = _class$2 = function (_React$Component) {
      inherits(MbscNote, _React$Component);

      function MbscNote(props) {
          classCallCheck(this, MbscNote);
          return possibleConstructorReturn(this, (MbscNote.__proto__ || Object.getPrototypeOf(MbscNote)).call(this, props));
      }

      createClass(MbscNote, [{
          key: 'render',
          value: function render() {
              var className = 'mbsc-note mbsc-note-' + this.props.color;
              return React.createElement('div', { className: className }, this.props.children);
          }
      }]);
      return MbscNote;
  }(React.Component), _class$2.propTypes = {
      color: PropTypes.string
  }, _class$2.defaultProps = {
      color: 'primary'
  }, _temp$2);
  var MbscAvatar = function (_React$Component2) {
      inherits(MbscAvatar, _React$Component2);

      function MbscAvatar(props) {
          classCallCheck(this, MbscAvatar);
          return possibleConstructorReturn(this, (MbscAvatar.__proto__ || Object.getPrototypeOf(MbscAvatar)).call(this, props));
      }

      createClass(MbscAvatar, [{
          key: 'render',
          value: function render() {
              return React.createElement('img', { className: 'mbsc-avatar', src: this.props.src, alt: this.props.alt });
          }
      }]);
      return MbscAvatar;
  }(React.Component);

  mobiscroll$3.Page = MbscPage;
  mobiscroll$3.Note = MbscNote;
  mobiscroll$3.Avatar = MbscAvatar;

  var _extends$2 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
              }
          }
      }return target;
  };

  var _class$1;
  var _temp$1;
  var _class2$1;
  var _temp2$1;
  var _class3;
  var _temp3;
  var _class4;
  var _temp4;
  var _class5;
  var _temp5;
  var _class6;
  var _temp6;
  var _class7;
  var _temp7;
  var _class8;
  var _temp8;
  var _class9;
  var _temp9;
  var _class10;
  var _temp10;
  var _class11;
  var _temp11;
  var _class12;
  var _temp12;
  var _class13;
  var _temp13;
  var _class14;
  var _temp14;

  function _objectWithoutProperties$1(obj, keys) {
      var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
      }return target;
  }

  var reactNumber = PropTypes.number;
  var reactString = PropTypes.string;
  var reactFunc = PropTypes.func;
  var reactBool = PropTypes.bool;

  /** PropTypes for Form components */
  var StepperPropTypes = {
      onInit: reactFunc,
      onChange: reactFunc,
      value: reactNumber,
      disabled: reactBool,
      min: reactNumber,
      max: reactNumber,
      step: reactNumber,
      val: PropTypes.oneOf(['left', 'right'])
  };

  var SwitchPropTypes = {
      onInit: reactFunc,
      onChange: reactFunc,
      checked: reactBool,
      disabled: reactBool,
      value: reactBool
  };

  var MbscForm = (_temp$1 = _class$1 = function (_MbscOptimized) {
      inherits(MbscForm, _MbscOptimized);

      function MbscForm(props) {
          classCallCheck(this, MbscForm);
          return possibleConstructorReturn(this, (MbscForm.__proto__ || Object.getPrototypeOf(MbscForm)).call(this, props));
      }

      createClass(MbscForm, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              // get settings from state
              var settings = this.getSettingsFromProps(this.props);
              // initialize the mobiscroll
              this.instance = new Form(ReactDOM.findDOMNode(this), settings);
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              if (!this.optimizeUpdate.updateOptions && this.optimizeUpdate.updateChildren) {
                  this.instance.refresh(true);
              } else if (this.optimizeUpdate.updateOptions) {
                  var settings = this.getSettingsFromProps(this.props);
                  this.instance.option(settings);
              }
          }
      }, {
          key: 'checkFormWrapper',
          value: function checkFormWrapper(component) {
              if (React.Children.count(component.props.children) == 1) {
                  return component.props.children.type == 'form';
              }
              return false;
          }
      }, {
          key: 'render',
          value: function render() {
              // passing through some of the element properties to its children
              var _props = this.props,
                  action = _props.action,
                  method = _props.method,
                  noValidate = _props.noValidate,
                  renderForm = _props.renderForm,
                  name = _props.name,
                  target = _props.target,
                  autoComplete = _props.autoComplete,
                  onSubmit = _props.onSubmit;

              if (this.checkFormWrapper(this) || !renderForm) {
                  return this.props.children;
              } else {
                  return React.createElement('form', { className: this.initialCssClass, action: action, name: name, target: target, method: method, autoComplete: autoComplete, noValidate: noValidate, onSubmit: onSubmit }, this.props.children);
              }
          }
      }]);
      return MbscForm;
  }(MbscOptimized), _class$1.defaultProps = {
      renderForm: true
  }, _class$1.propTypes = _extends$2({}, CorePropTypes, {
      enhance: reactBool,
      labelStyle: reactString,
      inputStyle: reactString,
      onInit: reactFunc
  }), _temp$1);

  mobiscroll$3.Form = MbscForm;

  var MbscLabel = (_temp2$1 = _class2$1 = function (_React$Component) {
      inherits(MbscLabel, _React$Component);

      function MbscLabel(props) {
          classCallCheck(this, MbscLabel);

          var _this2 = possibleConstructorReturn(this, (MbscLabel.__proto__ || Object.getPrototypeOf(MbscLabel)).call(this, props));

          _this2.render = function () {
              /* eslint-disable no-unused-vars */
              // justification: variable 'valid' and 'className' is declared due to object decomposition
              var _props2 = _this2.props,
                  valid = _props2.valid,
                  className = _props2.className,
                  color = _props2.color,
                  children = _props2.children,
                  presetName = _props2.presetName,
                  inputStyle = _props2.inputStyle,
                  labelStyle = _props2.labelStyle,
                  other = _objectWithoutProperties$1(_props2, ['valid', 'className', 'color', 'children', 'presetName', 'inputStyle', 'labelStyle']);

              /* eslint-enable */

              return React.createElement('label', other, children);
          };
          return _this2;
      }

      createClass(MbscLabel, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              updateCssClasses.call(this, '', this.getClasses(this.props));
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              if (this.cssClassUpdate) {
                  updateCssClasses.call(this, this.cssClassUpdate.prev, this.cssClassUpdate.next);
              }
          }
      }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps) {
              var nextClasses = this.getClasses(nextProps);
              var thisClasses = this.getClasses(this.props);
              if (thisClasses !== nextClasses) {
                  this.cssClassUpdate = {
                      prev: thisClasses,
                      next: nextClasses
                  };
              } else {
                  this.cssClassUpdate = null;
              }
              var update = !deepCompare(this.props, nextProps);
              return update;
          }
      }, {
          key: 'getClasses',
          value: function getClasses(props) {
              /* eslint-disable no-unused-vars */
              // justification: variable 'valid' and 'className' is declared due to object decomposition
              var valid = props.valid,
                  className = props.className,
                  color = props.color,
                  presetName = props.presetName,
                  inputStyle = props.inputStyle,
                  labelStyle = props.labelStyle;

              /* eslint-enable */

              var cssClasses = [];

              if (color) {
                  cssClasses.push('mbsc-' + presetName + '-' + color);
              }
              if (className) {
                  cssClasses.push(className);
              }
              if (inputStyle) {
                  cssClasses.push('mbsc-input-' + inputStyle);
              }
              if (labelStyle) {
                  cssClasses.push('mbsc-label-' + labelStyle);
              }
              if (valid !== undefined && !valid) {
                  cssClasses.push('mbsc-err');
              }
              var cssClass = '';
              if (cssClasses.length) {
                  cssClass = cssClasses.reduce(function (pv, cv) {
                      return pv + ' ' + cv;
                  }).replace(/\s+/g, ' ').trim();
              }
              return cssClass;
          }
      }]);
      return MbscLabel;
  }(React.Component), _class2$1.propTypes = {
      valid: PropTypes.bool,
      color: PropTypes.string,
      presetName: PropTypes.string,
      inputStyle: PropTypes.string,
      labelStyle: PropTypes.string
  }, _temp2$1);

  mobiscroll$3.Form.Label = MbscLabel; // for backward compatibilty
  mobiscroll$3.Label = MbscLabel;

  var MbscInput = (_temp3 = _class3 = function (_MbscInit) {
      inherits(MbscInput, _MbscInit);

      function MbscInput(props) {
          classCallCheck(this, MbscInput);

          var _this3 = possibleConstructorReturn(this, (MbscInput.__proto__ || Object.getPrototypeOf(MbscInput)).call(this, props));

          _this3.inputMounted = _this3.inputMounted.bind(_this3);
          return _this3;
      }

      createClass(MbscInput, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var settings = this.getSettingsFromProps(this.props);
              this.instance = new Input(this.inputNode, settings);
          }
      }, {
          key: 'inputMounted',
          value: function inputMounted(input) {
              this.inputNode = input;
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              var _props3 = this.props,
                  valid = _props3.valid,
                  errorMessage = _props3.errorMessage,
                  type = _props3.type,
                  icon = _props3.icon,
                  iconAlign = _props3.iconAlign,
                  passwordToggle = _props3.passwordToggle,
                  iconShow = _props3.iconShow,
                  iconHide = _props3.iconHide,
                  iconUpload = _props3.iconUpload,
                  inputStyle = _props3.inputStyle,
                  labelStyle = _props3.labelStyle,
                  children = _props3.children,
                  dropdown = _props3.dropdown,
                  other = _objectWithoutProperties$1(_props3, ['valid', 'errorMessage', 'type', 'icon', 'iconAlign', 'passwordToggle', 'iconShow', 'iconHide', 'iconUpload', 'inputStyle', 'labelStyle', 'children', 'dropdown']);
              /* eslint-enable */

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              }
              var drop = null;
              if (dropdown) {
                  drop = React.createElement('span', { className: 'mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5' });
              }

              type = type || 'text';

              return React.createElement(MbscLabel, { valid: valid, inputStyle: inputStyle, labelStyle: labelStyle, className: dropdown ? 'mbsc-select' : '' }, children, React.createElement('span', { className: 'mbsc-input-wrap' }, React.createElement('input', _extends$2({ ref: this.inputMounted, type: type, 'data-icon': icon, 'data-icon-align': iconAlign, 'data-password-toggle': passwordToggle, 'data-icon-show': iconShow, 'data-icon-hide': iconHide, 'data-icon-upload': iconUpload }, other)), drop, error));
          }
      }]);
      return MbscInput;
  }(MbscInit), _class3.propTypes = {
      disabled: PropTypes.bool,
      valid: PropTypes.bool,
      errorMessage: PropTypes.string,
      type: PropTypes.string,
      icon: PropTypes.string,
      iconAlign: PropTypes.string,
      passwordToggle: PropTypes.bool,
      iconShow: PropTypes.string,
      iconHide: PropTypes.string,
      iconUpload: PropTypes.string,
      name: PropTypes.string,
      dropdown: PropTypes.bool,
      inputStyle: PropTypes.string,
      labelStyle: PropTypes.string
  }, _temp3);

  mobiscroll$3.Input = MbscInput;

  var MbscTextArea = (_temp4 = _class4 = function (_MbscOptimized2) {
      inherits(MbscTextArea, _MbscOptimized2);

      function MbscTextArea(props) {
          classCallCheck(this, MbscTextArea);

          var _this4 = possibleConstructorReturn(this, (MbscTextArea.__proto__ || Object.getPrototypeOf(MbscTextArea)).call(this, props));

          _this4.textMounted = _this4.textMounted.bind(_this4);
          return _this4;
      }

      /**
       * Override
       */


      createClass(MbscTextArea, [{
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              var settings = this.getSettingsFromProps(this.props);
              if (this.optimizeUpdate) {
                  if (this.optimizeUpdate.updateOptions) {
                      this.instance.option(settings);
                  }
                  if (this.optimizeUpdate.updateValue) {
                      this.instance.refresh();
                  }
              } else {
                  this.instance.option(settings);
                  if (this.props.value !== undefined) {
                      this.instance.refresh();
                  }
              }
          }
      }, {
          key: 'componentDidMount',
          value: function componentDidMount() {
              var settings = this.getSettingsFromProps(this.props);
              this.instance = new TextArea(this.inputNode, settings);
          }
      }, {
          key: 'textMounted',
          value: function textMounted(input) {
              this.inputNode = input;
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              var _props4 = this.props,
                  valid = _props4.valid,
                  errorMessage = _props4.errorMessage,
                  icon = _props4.icon,
                  iconAlign = _props4.iconAlign,
                  inputStyle = _props4.inputStyle,
                  labelStyle = _props4.labelStyle,
                  children = _props4.children,
                  other = _objectWithoutProperties$1(_props4, ['valid', 'errorMessage', 'icon', 'iconAlign', 'inputStyle', 'labelStyle', 'children']);
              /* eslint-enable */

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              }

              return React.createElement(MbscLabel, { valid: valid }, children, React.createElement('span', { className: 'mbsc-input-wrap' }, React.createElement('textarea', _extends$2({ ref: this.textMounted, 'data-icon': icon, 'data-icon-align': iconAlign }, other)), error));
          }
      }]);
      return MbscTextArea;
  }(MbscOptimized), _class4.propTypes = {
      disabled: PropTypes.bool,
      valid: PropTypes.bool,
      errorMessage: PropTypes.string,
      icon: PropTypes.string,
      iconAlign: PropTypes.string,
      name: PropTypes.string,
      inputStyle: PropTypes.string,
      labelStyle: PropTypes.string }, _temp4);

  mobiscroll$3.Textarea = MbscTextArea;

  var MbscDropdown = (_temp5 = _class5 = function (_MbscInit2) {
      inherits(MbscDropdown, _MbscInit2);

      function MbscDropdown(props) {
          classCallCheck(this, MbscDropdown);

          var _this5 = possibleConstructorReturn(this, (MbscDropdown.__proto__ || Object.getPrototypeOf(MbscDropdown)).call(this, props));

          _this5.selectMounted = _this5.selectMounted.bind(_this5);
          return _this5;
      }

      createClass(MbscDropdown, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var settings = this.getSettingsFromProps(this.props);
              this.instance = new Select(this.selectNode, settings);
          }
      }, {
          key: 'selectMounted',
          value: function selectMounted(select) {
              this.selectNode = select;
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              this.instance._setText();
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              var _props5 = this.props,
                  label = _props5.label,
                  valid = _props5.valid,
                  errorMessage = _props5.errorMessage,
                  icon = _props5.icon,
                  iconAlign = _props5.iconAlign,
                  inputStyle = _props5.inputStyle,
                  labelStyle = _props5.labelStyle,
                  children = _props5.children,
                  other = _objectWithoutProperties$1(_props5, ['label', 'valid', 'errorMessage', 'icon', 'iconAlign', 'inputStyle', 'labelStyle', 'children']);
              /* eslint-enable */

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              } else {
                  error = React.createElement('span', null);
              }

              return React.createElement(MbscLabel, { valid: valid }, label, React.createElement('span', { className: 'mbsc-input-wrap' }, React.createElement('select', _extends$2({ ref: this.selectMounted, 'data-icon': icon, 'data-icon-align': iconAlign }, other), children), error));
          }
      }]);
      return MbscDropdown;
  }(MbscInit), _class5.propTypes = {
      label: PropTypes.string,
      disabled: PropTypes.bool,
      valid: PropTypes.bool,
      errorMessage: PropTypes.string,
      icon: PropTypes.string,
      iconAlign: PropTypes.string,
      name: PropTypes.string,
      inputStyle: PropTypes.string,
      labelStyle: PropTypes.string
  }, _temp5);

  mobiscroll$3.Dropdown = MbscDropdown;

  var MbscButton = (_temp6 = _class6 = function (_MbscInit3) {
      inherits(MbscButton, _MbscInit3);

      function MbscButton(props) {
          classCallCheck(this, MbscButton);

          var _this6 = possibleConstructorReturn(this, (MbscButton.__proto__ || Object.getPrototypeOf(MbscButton)).call(this, props));

          _this6.btnMounted = _this6.btnMounted.bind(_this6);
          return _this6;
      }

      createClass(MbscButton, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var settings = this.getSettingsFromProps(this.props);
              this.instance = new Button(this.btnNode, settings);
              updateCssClasses.call(this, '', this.getCssClasses(this.props));
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              if (this.cssClassUpdate) {
                  updateCssClasses.call(this, this.cssClassUpdate.prev, this.cssClassUpdate.next);
              }
          }
      }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps) {
              var nextClasses = this.getCssClasses(nextProps);
              var thisClasses = this.getCssClasses(this.props);
              if (thisClasses !== nextClasses) {
                  this.cssClassUpdate = {
                      prev: thisClasses,
                      next: nextClasses
                  };
              } else {
                  this.cssClassUpdate = null;
              }
              return true;
          }
      }, {
          key: 'btnMounted',
          value: function btnMounted(btn) {
              this.btnNode = btn;
          }
      }, {
          key: 'getCssClasses',
          value: function getCssClasses(props) {
              var className = props.className,
                  color = props.color,
                  flat = props.flat,
                  block = props.block,
                  outline = props.outline;

              var cssClasses = [];

              if (flat) {
                  cssClasses.push('mbsc-btn-flat');
              }
              if (block) {
                  cssClasses.push('mbsc-btn-block');
              }
              if (outline) {
                  cssClasses.push('mbsc-btn-outline');
              }
              if (color) {
                  cssClasses.push('mbsc-btn-' + color);
              }
              if (className) {
                  cssClasses.push(className);
              }
              var cssClass = '';
              if (cssClasses.length) {
                  cssClass = cssClasses.reduce(function (pv, cv) {
                      return pv + ' ' + cv;
                  }).replace(/\s+/g, ' ').trim();
              }
              return cssClass;
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              // justification: variables 'className', 'color', 'flat', 'block', 'outline' are declared due to object decomposition
              var _props6 = this.props,
                  type = _props6.type,
                  children = _props6.children,
                  className = _props6.className,
                  color = _props6.color,
                  flat = _props6.flat,
                  block = _props6.block,
                  outline = _props6.outline,
                  icon = _props6.icon,
                  other = _objectWithoutProperties$1(_props6, ['type', 'children', 'className', 'color', 'flat', 'block', 'outline', 'icon']);
              /* eslint-enable */

              type = type || 'button';

              return React.createElement('button', _extends$2({ ref: this.btnMounted, type: type, 'data-icon': icon }, other), children);
          }
      }]);
      return MbscButton;
  }(MbscInit), _class6.propTypes = {
      type: PropTypes.string,
      color: PropTypes.string,
      flat: PropTypes.bool,
      block: PropTypes.bool,
      outline: PropTypes.bool,
      icon: PropTypes.string,
      disabled: PropTypes.bool,
      name: PropTypes.string
  }, _temp6);

  mobiscroll$3.Button = MbscButton;

  var MbscCheckbox = (_temp7 = _class7 = function (_MbscInit4) {
      inherits(MbscCheckbox, _MbscInit4);

      function MbscCheckbox(props) {
          classCallCheck(this, MbscCheckbox);

          var _this7 = possibleConstructorReturn(this, (MbscCheckbox.__proto__ || Object.getPrototypeOf(MbscCheckbox)).call(this, props));

          _this7.inputMounted = _this7.inputMounted.bind(_this7);
          return _this7;
      }

      createClass(MbscCheckbox, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var settings = this.getSettingsFromProps(this.props);
              this.instance = new CheckBox(this.inputNode, settings);
          }
      }, {
          key: 'inputMounted',
          value: function inputMounted(inp) {
              this.inputNode = inp;
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              var _props7 = this.props,
                  color = _props7.color,
                  children = _props7.children,
                  errorMessage = _props7.errorMessage,
                  inputStyle = _props7.inputStyle,
                  valid = _props7.valid,
                  other = _objectWithoutProperties$1(_props7, ['color', 'children', 'errorMessage', 'inputStyle', 'valid']);
              /* eslint-enable */

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              }
              return React.createElement(MbscLabel, { valid: valid, color: color, presetName: 'checkbox' }, React.createElement('input', _extends$2({ ref: this.inputMounted, type: 'checkbox' }, other)), children, error);
          }
      }]);
      return MbscCheckbox;
  }(MbscInit), _class7.propTypes = {
      color: PropTypes.string,
      disabled: PropTypes.bool,
      valid: PropTypes.bool,
      errorMessage: PropTypes.string,
      name: PropTypes.string,
      inputStyle: PropTypes.string
  }, _temp7);

  mobiscroll$3.Checkbox = MbscCheckbox;

  var MbscRadio = (_temp8 = _class8 = function (_MbscInit5) {
      inherits(MbscRadio, _MbscInit5);

      function MbscRadio(props) {
          classCallCheck(this, MbscRadio);

          var _this8 = possibleConstructorReturn(this, (MbscRadio.__proto__ || Object.getPrototypeOf(MbscRadio)).call(this, props));

          _this8.inputMounted = _this8.inputMounted.bind(_this8);
          return _this8;
      }

      createClass(MbscRadio, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var settings = this.getSettingsFromProps(this.props);
              this.instance = new Radio(this.inputNode, settings);
          }
      }, {
          key: 'inputMounted',
          value: function inputMounted(inp) {
              this.inputNode = inp;
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              var _props8 = this.props,
                  color = _props8.color,
                  children = _props8.children,
                  inputStyle = _props8.inputStyle,
                  valid = _props8.valid,
                  errorMessage = _props8.errorMessage,
                  other = _objectWithoutProperties$1(_props8, ['color', 'children', 'inputStyle', 'valid', 'errorMessage']);
              /* eslint-enable */

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              }
              return React.createElement(MbscLabel, { valid: valid, color: color, presetName: 'radio' }, React.createElement('input', _extends$2({ ref: this.inputMounted, type: 'radio' }, other)), children, error);
          }
      }]);
      return MbscRadio;
  }(MbscInit), _class8.propTypes = {
      color: PropTypes.string,
      name: PropTypes.string,
      disabled: PropTypes.bool,
      inputStyle: PropTypes.string,
      valid: PropTypes.bool,
      errorMessage: PropTypes.string
  }, _temp8);

  mobiscroll$3.Radio = MbscRadio;

  var MbscSegmented = (_temp9 = _class9 = function (_MbscInit6) {
      inherits(MbscSegmented, _MbscInit6);

      function MbscSegmented(props) {
          classCallCheck(this, MbscSegmented);

          var _this9 = possibleConstructorReturn(this, (MbscSegmented.__proto__ || Object.getPrototypeOf(MbscSegmented)).call(this, props));

          _this9.inputMounted = _this9.inputMounted.bind(_this9);
          return _this9;
      }

      createClass(MbscSegmented, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var settings = this.getSettingsFromProps(this.props);
              this.instance = new SegmentedItem(this.inputNode, settings);
          }
      }, {
          key: 'inputMounted',
          value: function inputMounted(inp) {
              this.inputNode = inp;
          }
      }, {
          key: 'render',
          value: function render() {
              var _props9 = this.props,
                  color = _props9.color,
                  children = _props9.children,
                  multiSelect = _props9.multiSelect,
                  icon = _props9.icon,
                  other = _objectWithoutProperties$1(_props9, ['color', 'children', 'multiSelect', 'icon']);

              var type = multiSelect ? 'checkbox' : 'radio';
              return React.createElement(MbscLabel, { color: color, presetName: 'segmented' }, React.createElement('input', _extends$2({ ref: this.inputMounted, type: type, 'data-icon': icon, 'data-role': 'segmented' }, other)), children);
          }
      }]);
      return MbscSegmented;
  }(MbscInit), _class9.propTypes = {
      color: PropTypes.string,
      name: PropTypes.string,
      disabled: PropTypes.bool,
      multiSelect: PropTypes.bool,
      icon: PropTypes.string
  }, _temp9);

  mobiscroll$3.Segmented = MbscSegmented;

  var MbscFormBase = (_temp10 = _class10 = function (_MbscOptimized3) {
      inherits(MbscFormBase, _MbscOptimized3);

      function MbscFormBase(props, presetName) {
          classCallCheck(this, MbscFormBase);

          var _this10 = possibleConstructorReturn(this, (MbscFormBase.__proto__ || Object.getPrototypeOf(MbscFormBase)).call(this, props));

          _this10.presetName = presetName;
          _this10.inputMounted = _this10.inputMounted.bind(_this10);
          return _this10;
      }

      createClass(MbscFormBase, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              // get settings from state
              var settings = this.getSettingsFromProps(this.props, this.mbscInit);

              // initialize the mobiscroll
              this.instance = new classes[this.mbscInit.component || 'Scroller'](this.inputNode, settings);

              // Add change event listener if handler is passed
              $$2(this.inputNode).on('change', this.props.onChange || function () {});

              // sets the initial css classes on the element
              updateCssClasses.call(this, '', this.getCssClasses(this.props));
          }
      }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps) {
              var nextClasses = this.getCssClasses(nextProps);
              var thisClasses = this.getCssClasses(this.props);
              if (thisClasses !== nextClasses) {
                  this.cssClassUpdate = {
                      prev: thisClasses,
                      next: nextClasses
                  };
              } else {
                  this.cssClassUpdate = null;
              }
              return get(MbscFormBase.prototype.__proto__ || Object.getPrototypeOf(MbscFormBase.prototype), 'shouldComponentUpdate', this).call(this, nextProps) || this.cssClassUpdate;
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              if (this.cssClassUpdate) {
                  updateCssClasses.call(this, this.cssClassUpdate.prev, this.cssClassUpdate.next);
              }
              if (this.optimizeUpdate.updateOptions) {
                  var settings = this.getSettingsFromProps(this.props);
                  this.instance.option(settings);
              }
          }
      }, {
          key: 'inputMounted',
          value: function inputMounted(input) {
              this.inputNode = input;
          }
      }, {
          key: 'getCssClasses',
          value: function getCssClasses(props) {
              var className = props.className,
                  color = props.color,
                  cssClasses = [];

              if (color) {
                  cssClasses.push('mbsc-' + this.presetName + '-' + color);
              }
              if (className) {
                  cssClasses.push(className);
              }
              if (cssClasses.length) {
                  return cssClasses.reduce(function (pv, cv) {
                      return pv + ' ' + cv;
                  }).replace(/\s+/g, ' ').trim();
              } else {
                  return '';
              }
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              // justification: variables 'value', 'checked', 'onChange' and 'className' are declared due to object decomposition
              var _props10 = this.props,
                  className = _props10.className,
                  children = _props10.children,
                  value = _props10.value,
                  valid = _props10.valid,
                  errorMessage = _props10.errorMessage,
                  checked = _props10.checked,
                  onChange = _props10.onChange,
                  name = _props10.name,
                  color = _props10.color,
                  labelStyle = _props10.labelStyle,
                  inputStyle = _props10.inputStyle,
                  other = _objectWithoutProperties$1(_props10, ['className', 'children', 'value', 'valid', 'errorMessage', 'checked', 'onChange', 'name', 'color', 'labelStyle', 'inputStyle']);

              /* eslint-enable no-unused-vars */

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              }

              var type = this.inputType || 'text';
              return React.createElement(MbscLabel, { valid: valid, inputStyle: inputStyle, labelStyle: labelStyle }, children, React.createElement('input', _extends$2({ ref: this.inputMounted, type: type, 'data-role': name, 'data-enhance': 'false' }, other)), error);
          }
      }]);
      return MbscFormBase;
  }(MbscOptimized), _class10.propTypes = _extends$2({}, CorePropTypes, {
      color: reactString,
      labelStyle: reactString,
      inputStyle: reactString
  }), _temp10);
  var MbscSwitch = function (_MbscFormBase) {
      inherits(MbscSwitch, _MbscFormBase);

      function MbscSwitch(props) {
          classCallCheck(this, MbscSwitch);

          var _this11 = possibleConstructorReturn(this, (MbscSwitch.__proto__ || Object.getPrototypeOf(MbscSwitch)).call(this, props, 'switch'));

          _this11.mbscInit = {
              component: 'Switch'
          };
          _this11.inputType = 'checkbox';
          return _this11;
      }

      createClass(MbscSwitch, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              get(MbscSwitch.prototype.__proto__ || Object.getPrototypeOf(MbscSwitch.prototype), 'componentDidMount', this).call(this);
              if (this.props.checked !== undefined) {
                  this.instance.setVal(this.props.checked, true, false);
              }
          }
      }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps) {
              var otherChange = get(MbscSwitch.prototype.__proto__ || Object.getPrototypeOf(MbscSwitch.prototype), 'shouldComponentUpdate', this).call(this, nextProps);
              var checkedChange = this.optimizeUpdate.updateChecked = !deepCompare(nextProps.checked, this.props.checked);
              return otherChange || checkedChange;
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              get(MbscSwitch.prototype.__proto__ || Object.getPrototypeOf(MbscSwitch.prototype), 'componentDidUpdate', this).call(this);
              if (this.optimizeUpdate.updateChecked && !deepCompare(this.instance.getVal(), this.props.checked)) {
                  this.instance.setVal(this.props.checked);
              }
          }
      }]);
      return MbscSwitch;
  }(MbscFormBase);

  MbscSwitch.propTypes = _extends$2({}, MbscSwitch.propTypes, SwitchPropTypes);

  mobiscroll$3.Switch = MbscSwitch;

  var MbscStepper = function (_MbscFormBase2) {
      inherits(MbscStepper, _MbscFormBase2);

      function MbscStepper(props) {
          classCallCheck(this, MbscStepper);

          var _this12 = possibleConstructorReturn(this, (MbscStepper.__proto__ || Object.getPrototypeOf(MbscStepper)).call(this, props, 'stepper'));

          _this12.mbscInit = {
              component: 'Stepper'
          };
          return _this12;
      }

      createClass(MbscStepper, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              get(MbscStepper.prototype.__proto__ || Object.getPrototypeOf(MbscStepper.prototype), 'componentDidMount', this).call(this);
              if (this.props.value !== undefined) {
                  this.instance.setVal(this.props.value, true, false);
              }
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              get(MbscStepper.prototype.__proto__ || Object.getPrototypeOf(MbscStepper.prototype), 'componentDidUpdate', this).call(this);
              if (this.optimizeUpdate.updateValue && !deepCompare(this.props.value, this.instance.getVal())) {
                  this.instance.setVal(this.props.value);
              }
          }
      }]);
      return MbscStepper;
  }(MbscFormBase);

  MbscStepper.propTypes = _extends$2({}, MbscStepper.propTypes, StepperPropTypes);

  mobiscroll$3.Stepper = MbscStepper;

  // progress

  var MbscColored = function (_MbscOptimized4) {
      inherits(MbscColored, _MbscOptimized4);

      function MbscColored(props) {
          classCallCheck(this, MbscColored);
          return possibleConstructorReturn(this, (MbscColored.__proto__ || Object.getPrototypeOf(MbscColored)).call(this, props));
      }

      createClass(MbscColored, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              updateCssClasses.call(this, '', this.getCssClasses(this.props));
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate() {
              get(MbscColored.prototype.__proto__ || Object.getPrototypeOf(MbscColored.prototype), 'componentDidUpdate', this).call(this);
              if (this.cssClassUpdate) {
                  updateCssClasses.call(this, this.cssClassUpdate.prev, this.cssClassUpdate.next);
              }
          }
      }, {
          key: 'shouldComponentUpdate',
          value: function shouldComponentUpdate(nextProps) {
              var nextClasses = this.getCssClasses(nextProps);
              var thisClasses = this.getCssClasses(this.props);
              if (thisClasses !== nextClasses) {
                  this.cssClassUpdate = {
                      prev: thisClasses,
                      next: nextClasses
                  };
              } else {
                  this.cssClassUpdate = null;
              }
              return get(MbscColored.prototype.__proto__ || Object.getPrototypeOf(MbscColored.prototype), 'shouldComponentUpdate', this).call(this, nextProps) || this.cssClassUpdate;
          }
      }, {
          key: 'getCssClasses',
          value: function getCssClasses(props) {
              var className = props.className,
                  color = props.color;

              var cssClasses = [];

              if (color) {
                  cssClasses.push('mbsc-' + this.presetName + '-' + color);
              }

              if (className) {
                  cssClasses.push(className);
              }

              if (cssClasses.length) {
                  return cssClasses.reduce(function (pv, cv) {
                      return pv + ' ' + cv;
                  }).replace(/\s+/g, ' ').trim();
              } else {
                  return '';
              }
          }
      }]);
      return MbscColored;
  }(MbscOptimized);
  var MbscProgress = (_temp11 = _class11 = function (_MbscColored) {
      inherits(MbscProgress, _MbscColored);

      function MbscProgress(props) {
          classCallCheck(this, MbscProgress);

          var _this14 = possibleConstructorReturn(this, (MbscProgress.__proto__ || Object.getPrototypeOf(MbscProgress)).call(this, props));

          _this14.presetName = 'progress';
          _this14.progressMounted = _this14.progressMounted.bind(_this14);
          return _this14;
      }

      createClass(MbscProgress, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              // get settings from state
              var settings = this.getSettingsFromProps(this.props);
              // initialize the mobiscroll
              this.instance = new Progress(this.progressNode, settings);
              if (this.props.value !== undefined) {
                  this.instance.setVal(this.props.value, true);
              }
              get(MbscProgress.prototype.__proto__ || Object.getPrototypeOf(MbscProgress.prototype), 'componentDidMount', this).call(this);
          }
      }, {
          key: 'progressMounted',
          value: function progressMounted(progress) {
              this.progressNode = progress;
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              // justification: variable 'value' and 'className' is defined due to object decomposotion
              var _props11 = this.props,
                  className = _props11.className,
                  children = _props11.children,
                  value = _props11.value,
                  color = _props11.color,
                  inputStyle = _props11.inputStyle,
                  labelStyle = _props11.labelStyle,
                  other = _objectWithoutProperties$1(_props11, ['className', 'children', 'value', 'color', 'inputStyle', 'labelStyle']);

              /* eslint-enable no-unused-vars */

              return React.createElement(MbscLabel, { labelStyle: labelStyle, inputStyle: inputStyle }, children, React.createElement('progress', _extends$2({ ref: this.progressMounted }, other)));
          }
      }]);
      return MbscProgress;
  }(MbscColored), _class11.propTypes = _extends$2({}, CorePropTypes, {
      "data-icon": reactString,
      "data-icon-align": PropTypes.oneOf(['left', 'right']),
      val: PropTypes.oneOf(['left', 'right']),
      disabled: reactBool,
      max: reactNumber,
      value: reactNumber,
      color: reactString,
      inputStyle: reactString,
      labelStyle: reactString
  }), _temp11);

  mobiscroll$3.Progress = MbscProgress;

  // slider
  var MbscSlider = (_temp12 = _class12 = function (_MbscColored2) {
      inherits(MbscSlider, _MbscColored2);

      function MbscSlider(props) {
          classCallCheck(this, MbscSlider);

          var _this15 = possibleConstructorReturn(this, (MbscSlider.__proto__ || Object.getPrototypeOf(MbscSlider)).call(this, props));

          _this15.presetName = 'slider';
          _this15.firstInputMounted = _this15.firstInputMounted.bind(_this15);
          _this15.parentMounted = _this15.parentMounted.bind(_this15);
          return _this15;
      }

      createClass(MbscSlider, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              // get settings from state 
              var settings = this.getSettingsFromProps(this.props);
              // initialize the mobiscroll
              this.instance = new Slider(this.firstInput, settings);

              if (this.props.value !== undefined) {
                  this.instance.setVal(this.props.value, true);
              }
              var that = this;
              // our own change handler - to receive the change event
              $$2(this.label).on('change', function () {
                  if (that.props.onChange) {
                      var values = that.instance.getVal();
                      that.props.onChange(values);
                  }
              });

              get(MbscSlider.prototype.__proto__ || Object.getPrototypeOf(MbscSlider.prototype), 'componentDidMount', this).call(this);
          }
      }, {
          key: 'firstInputMounted',
          value: function firstInputMounted(input) {
              this.firstInput = input;
          }
      }, {
          key: 'parentMounted',
          value: function parentMounted(label) {
              this.label = ReactDOM.findDOMNode(label);
          }
      }, {
          key: 'onValueChanged',
          value: function onValueChanged() {
              // this is not triggered - or the event propagation is stopped somewhere on the line
              // to counter this we attach our own change handler in the `componentDidMount` function 
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              // justification: variable 'onChange' and 'className' is defined due to object decomposotion
              var _props12 = this.props,
                  children = _props12.children,
                  value = _props12.value,
                  onChange = _props12.onChange,
                  className = _props12.className,
                  icon = _props12.icon,
                  live = _props12.live,
                  stepLabels = _props12.stepLabels,
                  tooltip = _props12.tooltip,
                  color = _props12.color,
                  inputStyle = _props12.inputStyle,
                  labelStyle = _props12.labelStyle,
                  other = _objectWithoutProperties$1(_props12, ['children', 'value', 'onChange', 'className', 'icon', 'live', 'stepLabels', 'tooltip', 'color', 'inputStyle', 'labelStyle']),
                  values = value || [];

              live = live || this.props['data-live'] || false;
              icon = icon || this.props['data-icon'];
              /* eslint-enable no-unused-vars */

              if (value !== undefined && !Array.isArray(value)) {
                  values = [value];
              }

              return React.createElement(MbscLabel, { ref: this.parentMounted, labelStyle: labelStyle, inputStyle: inputStyle }, children, values.map(function (item, index) {
                  if (index === 0) {
                      return React.createElement('input', _extends$2({ ref: this.firstInputMounted, 'data-label-style': labelStyle, 'data-input-style': inputStyle, 'data-icon': icon, 'data-live': live, key: index, type: 'range' }, other));
                  }
                  return React.createElement('input', { key: index, type: 'range', 'data-live': live, 'data-index': index, 'data-label-style': labelStyle, 'data-input-style': inputStyle });
              }, this));
          }
      }]);
      return MbscSlider;
  }(MbscColored), _class12.propTypes = _extends$2({}, CorePropTypes, {
      highlight: reactBool,
      live: reactBool,
      stepLabels: PropTypes.arrayOf(reactNumber),
      "data-icon": reactString,
      tooltip: reactBool,
      val: PropTypes.oneOf(['left', 'right']),
      disabled: reactBool,
      max: reactNumber,
      min: reactNumber,
      step: reactNumber,
      value: PropTypes.oneOfType([reactNumber, PropTypes.arrayOf(reactNumber)]),
      color: reactString,
      inputStyle: reactString,
      labelStyle: reactString
  }), _temp12);

  mobiscroll$3.Slider = MbscSlider;

  var MbscRating = (_temp13 = _class13 = function (_MbscColored3) {
      inherits(MbscRating, _MbscColored3);

      function MbscRating(props) {
          classCallCheck(this, MbscRating);

          var _this16 = possibleConstructorReturn(this, (MbscRating.__proto__ || Object.getPrototypeOf(MbscRating)).call(this, props));

          _this16.presetName = 'rating';
          _this16.inputMounted = _this16.inputMounted.bind(_this16);
          _this16.parentMounted = _this16.parentMounted.bind(_this16);
          return _this16;
      }

      createClass(MbscRating, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              var _this17 = this;

              // get settings from state
              var settings = this.getSettingsFromProps(this.props);
              // initialize the mobiscroll
              this.instance = new Rating(this.inputNode, settings);
              if (this.props.value !== undefined) {
                  this.instance.setVal(this.props.value, true);
              }

              $$2(this.label).on('change', function () {
                  if (_this17.props.onChange) {
                      var value = _this17.instance.getVal();
                      _this17.props.onChange(value);
                  }
              });

              get(MbscRating.prototype.__proto__ || Object.getPrototypeOf(MbscRating.prototype), 'componentDidMount', this).call(this);
          }
      }, {
          key: 'inputMounted',
          value: function inputMounted(input) {
              this.inputNode = input;
          }
      }, {
          key: 'parentMounted',
          value: function parentMounted(label) {
              this.label = label;
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              // justification: variable 'value' and 'className' is defined due to object decomposotion
              var _props13 = this.props,
                  className = _props13.className,
                  children = _props13.children,
                  onChange = _props13.onChange,
                  value = _props13.value,
                  empty = _props13.empty,
                  filled = _props13.filled,
                  template = _props13.template,
                  val = _props13.val,
                  color = _props13.color,
                  inputStyle = _props13.inputStyle,
                  labelStyle = _props13.labelStyle,
                  other = _objectWithoutProperties$1(_props13, ['className', 'children', 'onChange', 'value', 'empty', 'filled', 'template', 'val', 'color', 'inputStyle', 'labelStyle']);
              /* eslint-enable no-unused-vars */

              return React.createElement(MbscLabel, { ref: this.parentMounted, labelStyle: labelStyle, inputStyle: inputStyle }, children, React.createElement('input', _extends$2({ type: 'rating', 'data-role': 'rating', 'data-val': val, 'data-template': template, 'data-empty': empty, 'data-filled': filled, ref: this.inputMounted }, other)));
          }
      }]);
      return MbscRating;
  }(MbscColored), _class13.propTypes = _extends$2({}, CorePropTypes, {
      val: PropTypes.oneOf(['left', 'right']),
      disabled: reactBool,
      max: reactNumber,
      min: reactNumber,
      step: reactNumber,
      template: reactString,
      empty: reactString,
      filled: reactString,
      value: reactNumber,
      color: reactString,
      inputStyle: reactString,
      labelStyle: reactString
  }), _temp13);

  mobiscroll$3.Rating = MbscRating;

  var MbscFormGroup = (_temp14 = _class14 = function (_React$Component2) {
      inherits(MbscFormGroup, _React$Component2);

      function MbscFormGroup(props) {
          classCallCheck(this, MbscFormGroup);
          return possibleConstructorReturn(this, (MbscFormGroup.__proto__ || Object.getPrototypeOf(MbscFormGroup)).call(this, props));
      }

      createClass(MbscFormGroup, [{
          key: 'componentDidMount',
          value: function componentDidMount() {
              if (this.props.collapsible !== undefined) {
                  var isOpen = this.props.open || false;

                  this.instance = new CollapsibleBase(ReactDOM.findDOMNode(this), { isOpen: isOpen });
              }
          }
      }, {
          key: 'componentDidUpdate',
          value: function componentDidUpdate(prevProps) {
              if (this.props.open !== undefined && this.props.open != prevProps.open) {
                  if (this.props.open) {
                      this.instance.show();
                  } else {
                      this.instance.hide();
                  }
              }
          }
      }, {
          key: 'render',
          value: function render() {
              /* eslint-disable no-unused-vars */
              var _props14 = this.props;

              var children = _props14.children,
                  inset = _props14.inset,
                  collapsible = _props14.collapsible,
                  className = _props14.className,
                  other = _objectWithoutProperties$1(_props14, ['children', 'inset', 'collapsible', 'className']);

              var cssClasses = "mbsc-form-group" + (inset !== undefined ? '-inset' : '') + " " + (className || '');

              return React.createElement('div', _extends$2({ className: cssClasses }, other), children);
          }
      }]);
      return MbscFormGroup;
  }(React.Component), _class14.propTypes = {
      collapsible: PropTypes.bool,
      open: PropTypes.bool,
      inset: PropTypes.any
  }, _temp14);

  mobiscroll$3.FormGroup = MbscFormGroup;
  mobiscroll$3.MbscFormGroup = MbscFormGroup; // deprecated

  var MbscFormGroupTitle = function (_React$Component3) {
      inherits(MbscFormGroupTitle, _React$Component3);

      function MbscFormGroupTitle(props) {
          classCallCheck(this, MbscFormGroupTitle);

          var _this19 = possibleConstructorReturn(this, (MbscFormGroupTitle.__proto__ || Object.getPrototypeOf(MbscFormGroupTitle)).call(this, props));

          _this19.cssClasses = "mbsc-form-group-title " + (_this19.props.className || '');
          return _this19;
      }

      createClass(MbscFormGroupTitle, [{
          key: 'render',
          value: function render() {
              return React.createElement('div', { className: this.cssClasses }, this.props.children);
          }
      }]);
      return MbscFormGroupTitle;
  }(React.Component);

  mobiscroll$3.FormGroupTitle = MbscFormGroupTitle;
  mobiscroll$3.MbscFormGroupTitle = MbscFormGroupTitle; // deprecated

  var MbscFormGroupContent = function (_React$Component4) {
      inherits(MbscFormGroupContent, _React$Component4);

      function MbscFormGroupContent(props) {
          classCallCheck(this, MbscFormGroupContent);

          var _this20 = possibleConstructorReturn(this, (MbscFormGroupContent.__proto__ || Object.getPrototypeOf(MbscFormGroupContent)).call(this, props));

          _this20.cssClasses = "mbsc-form-group-content " + (_this20.props.className || '');
          return _this20;
      }

      createClass(MbscFormGroupContent, [{
          key: 'render',
          value: function render() {
              return React.createElement('div', { className: this.cssClasses }, this.props.children);
          }
      }]);
      return MbscFormGroupContent;
  }(React.Component);

  mobiscroll$3.FormGroupContent = MbscFormGroupContent;
  mobiscroll$3.MbscFormGroupContent = MbscFormGroupContent; // deprecated


  var MbscAccordion = function (_React$Component5) {
      inherits(MbscAccordion, _React$Component5);

      function MbscAccordion(props) {
          classCallCheck(this, MbscAccordion);

          var _this21 = possibleConstructorReturn(this, (MbscAccordion.__proto__ || Object.getPrototypeOf(MbscAccordion)).call(this, props));

          _this21.cssClasses = "mbsc-accordion " + (_this21.props.className || '');
          return _this21;
      }

      createClass(MbscAccordion, [{
          key: 'render',
          value: function render() {
              return React.createElement('div', { className: this.cssClasses }, this.props.children);
          }
      }]);
      return MbscAccordion;
  }(React.Component);

  mobiscroll$3.Accordion = MbscAccordion;

  // Arabic

  function intPart(floatNum) {
      if (floatNum < -0.0000001) {
          return Math.ceil(floatNum - 0.0000001);
      }
      return Math.floor(floatNum + 0.0000001);
  }

  function gregorianToHijri(gY, gM, gD) {
      gY = parseInt(gY);
      gM = parseInt(gM);
      gD = parseInt(gD);

      var jd,
          l,
          j,
          n,
          hijriDate = new Array(0, 0, 0);

      if (gY > 1582 || gY == 1582 && gM > 10 || gY == 1582 && gM == 10 && gD > 14) {
          jd = intPart(1461 * (gY + 4800 + intPart((gM - 14) / 12)) / 4) + intPart(367 * (gM - 2 - 12 * intPart((gM - 14) / 12)) / 12) - intPart(3 * intPart((gY + 4900 + intPart((gM - 14) / 12)) / 100) / 4) + gD - 32075;
      } else {
          jd = 367 * gY - intPart(7 * (gY + 5001 + intPart((gM - 9) / 7)) / 4) + intPart(275 * gM / 9) + gD + 1729777;
      }

      l = jd - 1948440 + 10632;
      n = intPart((l - 1) / 10631);
      l = l - 10631 * n + 354;
      j = intPart((10985 - l) / 5316) * intPart(50 * l / 17719) + intPart(l / 5670) * intPart(43 * l / 15238);
      l = l - intPart((30 - j) / 15) * intPart(17719 * j / 50) - intPart(j / 16) * intPart(15238 * j / 43) + 29;
      gM = intPart(24 * l / 709);
      gD = l - intPart(709 * gM / 24);
      gY = 30 * n + j - 30;

      hijriDate[2] = gD;
      hijriDate[1] = gM;
      hijriDate[0] = gY;

      return hijriDate;
  }

  // Arabic

  mobiscroll$3.i18n.ar = {
      // Core
      rtl: true, // Right to left mode
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: [' ', ' ', '', '', '', '', '', '', '', ' ', ' ', ''],
      monthNamesShort: [' ', ' ', '', '', '', '', '', '', '', ' ', ' ', ''],
      monthText: '',
      secText: '',
      amText: '',
      pmText: '',
      timeFormat: 'hh:ii A',
      yearText: '',
      nowText: '',
      // Calendar component
      firstDay: 0,
      dateText: '',
      timeText: '',
      closeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      allDayText: ' ',
      noEventsText: '  ',
      // Event calendar
      eventText: '',
      eventsText: '',
      moreEventsText: ' ',
      moreEventsPluralText: '  {count}',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Numpad date
      delimiter: '/',
      // Numpad decimal
      decimalSeparator: '.',
      thousandsSeparator: ',',
      // Timer / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: ' ',
      lapText: '',
      hideText: '',
      // Forms
      offText: '',
      onText: '',
      // Listview
      backText: '',
      undoText: ''
  };

  // Bulgarian

  mobiscroll$3.i18n.bg = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      allDayText: ' ',
      noEventsText: ' ',
      moreEventsText: ' {count}',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Catal

  mobiscroll$3.i18n.ca = {
      // Core
      setText: 'Acceptar',
      cancelText: 'Cancellar',
      clearText: 'Esborrar',
      selectedText: '{count} seleccionat',
      selectedPluralText: '{count} seleccionats',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Diumenge', 'Dilluns', 'Dimarts', 'Dimecres', 'Dijous', 'Divendres', 'Dissabte'],
      dayNamesShort: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
      dayNamesMin: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
      dayText: 'Dia',
      hourText: 'Hores',
      minuteText: 'Minuts',
      monthNames: ['Gener', 'Febrer', 'Mar', 'Abril', 'Maig', 'Juny', 'Juliol', 'Agost', 'Setembre', 'Octubre', 'Novembre', 'Desembre'],
      monthNamesShort: ['Gen', 'Feb', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Oct', 'Nov', 'Des'],
      monthText: 'Mes',
      secText: 'Segons',
      timeFormat: 'HH:ii',
      yearText: 'Any',
      nowText: 'Ara',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Avui',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Temps',
      closeText: 'Tancar',
      allDayText: 'Tot el dia',
      noEventsText: 'Cap esdeveniment',
      eventText: 'Esdeveniments',
      eventsText: 'Esdeveniments',
      moreEventsText: '{count} ms',
      // Daterange component
      fromText: 'Iniciar',
      toText: 'Final',
      // Measurement components
      wholeText: 'Sencer',
      fractionText: 'Fracci',
      unitText: 'Unitat',
      // Time / Timespan component
      labels: ['Anys', 'Mesos', 'Dies', 'Hores', 'Minuts', 'Segons', ''],
      labelsShort: ['Anys', 'Mesos', 'Dies', 'Hrs', 'Mins', 'Secs', ''],
      // Timer component
      startText: 'Iniciar',
      stopText: 'Aturar',
      resetText: 'Reiniciar',
      lapText: 'Volta',
      hideText: 'Amagar',
      // Listview
      backText: 'Enrere',
      undoText: 'Desfs',
      // Form
      offText: 'No',
      onText: 'Si'
  };

  // Cestina

  mobiscroll$3.i18n.cs = {
      // Core
      setText: 'Zadej',
      cancelText: 'Storno',
      clearText: 'Vymazat',
      selectedText: 'Oznaen: {count}',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Nedle', 'Pondl', 'ter', 'Steda', 'tvrtek', 'Ptek', 'Sobota'],
      dayNamesShort: ['Ne', 'Po', 't', 'St', 't', 'P', 'So'],
      dayNamesMin: ['N', 'P', '', 'S', '', 'P', 'S'],
      dayText: 'Den',
      hourText: 'Hodiny',
      minuteText: 'Minuty',
      monthNames: ['Leden', 'nor', 'Bezen', 'Duben', 'Kvten', 'erven', 'ervenec', 'Srpen', 'Z', 'jen', 'Listopad', 'Prosinec'],
      monthNamesShort: ['Led', 'no', 'Be', 'Dub', 'Kv', 'er', 'vc', 'Spr', 'Z', 'j', 'Lis', 'Pro'],
      monthText: 'Msc',
      secText: 'Sekundy',
      timeFormat: 'HH:ii',
      yearText: 'Rok',
      nowText: 'Te',
      amText: 'am',
      pmText: 'pm',
      todayText: 'Dnes',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'as',
      closeText: 'Zavt',
      allDayText: 'Cel den',
      noEventsText: 'dn udlosti',
      eventText: 'Udlost',
      eventsText: 'Udlosti',
      moreEventsText: '{count} dal',
      // Daterange component
      fromText: 'Zatek',
      toText: 'Konec',
      // Measurement components
      wholeText: 'Cel',
      fractionText: 'st',
      unitText: 'Jednotka',
      // Time / Timespan component
      labels: ['Roky', 'Msce', 'Dny', 'Hodiny', 'Minuty', 'Sekundy', ''],
      labelsShort: ['Rok', 'Ms', 'Dny', 'Hod', 'Min', 'Sec', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Resetovat',
      lapText: 'Etapa',
      hideText: 'Schovat',
      // Listview
      backText: 'Zpt',
      undoText: 'Zpt',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Dansk
  /*
   * Translation by: Mikkel Bonde, Apacta A/S <mikbonde@gmail.com>
   */

  mobiscroll$3.i18n.da = {
      // Core
      setText: 'St',
      cancelText: 'Annuller',
      clearText: 'Ryd',
      selectedText: '{count} valgt',
      selectedPluralText: '{count} valgt',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
      dayNamesShort: ['Sn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lr'],
      dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
      dayText: 'Dag',
      hourText: 'Timer',
      minuteText: 'Minutter',
      monthNames: ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
      monthText: 'Mned',
      secText: 'Sekunder',
      amText: 'am',
      pmText: 'pm',
      timeFormat: 'HH.ii',
      yearText: 'r',
      nowText: 'Nu',
      todayText: 'I dag',
      // Calendar component
      firstDay: 1,
      dateText: 'Dato',
      timeText: 'Tid',
      closeText: 'Luk',
      allDayText: 'Hele dagen',
      noEventsText: 'Ingen begivenheder',
      eventText: 'Begivenheder',
      eventsText: 'Begivenheder',
      moreEventsText: '{count} mere',
      // Daterange component
      fromText: 'Start',
      toText: 'Slut',
      // Measurement components
      wholeText: 'Hele',
      fractionText: 'Dele',
      unitText: 'Enhed',
      // Time / Timespan component
      labels: ['r', 'Mneder', 'Dage', 'Timer', 'Minutter', 'Sekunder', ''],
      labelsShort: ['r', 'Mdr', 'Dg', 'Timer', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Nulstil',
      lapText: 'Omgang',
      hideText: 'Skjul',
      // Forms
      offText: 'Fra',
      onText: 'Til',
      // Listview
      backText: 'Tilbage',
      undoText: 'Fortryd'
  };

  // Deutsch

  mobiscroll$3.i18n.de = {
      // Core
      setText: 'OK',
      cancelText: 'Abbrechen',
      clearText: 'Lschen',
      selectedText: '{count} ausgewhlt',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
      dayNamesShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      dayNamesMin: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
      dayText: 'Tag',
      delimiter: '.',
      hourText: 'Stunde',
      minuteText: 'Minuten',
      monthNames: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
      monthNamesShort: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
      monthText: 'Monat',
      secText: 'Sekunden',
      timeFormat: 'HH:ii',
      yearText: 'Jahr',
      nowText: 'Jetzt',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Heute',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'Zeit',
      closeText: 'Schlieen',
      allDayText: 'Ganztgig',
      noEventsText: 'Keine Ereignisse',
      eventText: 'Ereignis',
      eventsText: 'Ereignisse',
      moreEventsText: '{count} weiteres Element',
      moreEventsPluralText: '{count} weitere Elemente',
      // Daterange component
      fromText: 'Von',
      toText: 'Bis',
      // Measurement components
      wholeText: 'Ganze Zahl',
      fractionText: 'Bruchzahl',
      unitText: 'Maeinheit',
      // Time / Timespan component
      labels: ['Jahre', 'Monate', 'Tage', 'Stunden', 'Minuten', 'Sekunden', ''],
      labelsShort: ['Jahr.', 'Mon.', 'Tag.', 'Std.', 'Min.', 'Sek.', ''],
      // Timer component
      startText: 'Starten',
      stopText: 'Stoppen',
      resetText: 'Zurcksetzen',
      lapText: 'Lap',
      hideText: 'Ausblenden',
      // Listview
      backText: 'Zurck',
      undoText: 'Rckgngig machen',
      // Form
      offText: 'Aus',
      onText: 'Ein',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Greek

  mobiscroll$3.i18n.el = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '/',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      allDayText: '',
      noEventsText: '  ',
      moreEventsText: '{count} ',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // English (UK)

  mobiscroll$3.i18n['en-GB'] = mobiscroll$3.i18n['en-UK'] = {
      dateFormat: 'dd/mm/yy',
      timeFormat: 'HH:ii'
  };

  // Espaol

  mobiscroll$3.i18n.es = {
      // Core
      setText: 'Aceptar',
      cancelText: 'Cancelar',
      clearText: 'Borrar',
      selectedText: '{count} seleccionado',
      selectedPluralText: '{count} seleccionados',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Domingo', 'Lunes', 'Martes', 'Mircoles', 'Jueves', 'Viernes', 'Sbado'],
      dayNamesShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'S'],
      dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
      dayText: 'Da',
      hourText: 'Horas',
      minuteText: 'Minutos',
      monthNames: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
      monthNamesShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
      monthText: 'Mes',
      secText: 'Segundos',
      timeFormat: 'HH:ii',
      yearText: 'A&ntilde;o',
      nowText: 'Ahora',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Hoy',
      // Calendar component
      firstDay: 1,
      dateText: 'Fecha',
      timeText: 'Tiempo',
      closeText: 'Cerrar',
      allDayText: 'Todo el da',
      noEventsText: 'No hay eventos',
      eventText: 'Evento',
      eventsText: 'Eventos',
      moreEventsText: '{count} ms',
      // Daterange component
      fromText: 'Iniciar',
      toText: 'Final',
      // Measurement components
      wholeText: 'Entero',
      fractionText: 'Fraccin',
      unitText: 'Unidad',
      // Time / Timespan component
      labels: ['Aos', 'Meses', 'Das', 'Horas', 'Minutos', 'Segundos', ''],
      labelsShort: ['Ao', 'Mes', 'Da', 'Hora', 'Min', 'Seg', ''],
      // Timer component
      startText: 'Iniciar',
      stopText: 'Detngase',
      resetText: 'Reinicializar',
      lapText: 'Lap',
      hideText: 'Esconder',
      // Listview
      backText: 'Atrs',
      undoText: 'Deshacer',
      // Form
      offText: 'No',
      onText: 'S',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // 

  var gDaysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var jDaysInMonth = [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29];

  function gregorianToJalali(gY, gM, gD) {
      gY = parseInt(gY);
      gM = parseInt(gM);
      gD = parseInt(gD);

      var i;
      var gy = gY - 1600;
      var gm = gM - 1;
      var gd = gD - 1;

      var gDayNo = 365 * gy + parseInt((gy + 3) / 4) - parseInt((gy + 99) / 100) + parseInt((gy + 399) / 400);

      for (i = 0; i < gm; ++i) {
          gDayNo += gDaysInMonth[i];
      }

      if (gm > 1 && (gy % 4 === 0 && gy % 100 !== 0 || gy % 400 === 0)) {
          ++gDayNo;
      }

      gDayNo += gd;

      var jDayNo = gDayNo - 79;

      var jNp = parseInt(jDayNo / 12053);
      jDayNo %= 12053;

      var jy = 979 + 33 * jNp + 4 * parseInt(jDayNo / 1461);

      jDayNo %= 1461;

      if (jDayNo >= 366) {
          jy += parseInt((jDayNo - 1) / 365);
          jDayNo = (jDayNo - 1) % 365;
      }

      for (i = 0; i < 11 && jDayNo >= jDaysInMonth[i]; ++i) {
          jDayNo -= jDaysInMonth[i];
      }

      var jm = i + 1;
      var jd = jDayNo + 1;

      return [jy, jm, jd];
  }

  // 

  mobiscroll$3.i18n.fa = {
      // Core
      setText: '',
      cancelText: '',
      clearText: ' ',
      selectedText: '{count} ',
      // Datetime component
      calendarSystem: 'jalali',
      dateFormat: 'yy/mm/dd',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      timeWheels: 'iiHH', // Need this for correct RTL display
      yearText: '',
      nowText: '',
      amText: '',
      pmText: '',
      todayText: '',
      //getNumber: function (n) {
      //    var i,
      //        nums = ["", "", "", "", "", "", "", "", "", ""],
      //        res = '';

      //    n = n + '';
      //    for (i = 0; i < n.length; i++) {
      //        res += nums[+n[i]];
      //    }
      //    return res;
      //},
      // Calendar component
      firstDay: 6,
      rtl: true,
      dateText: ' ',
      timeText: ' ',
      closeText: '',
      allDayText: ' ',
      noEventsText: ' ',
      eventText: '',
      eventsText: '',
      moreEventsText: '{count}  ',
      // Daterange component
      fromText: ' ',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: ' ',
      lapText: 'Lap',
      hideText: ' ',
      // Listview
      backText: '',
      undoText: ''
  };

  // Suomi

  mobiscroll$3.i18n.fi = {
      // Core
      setText: 'Aseta',
      cancelText: 'Peruuta',
      clearText: 'Tyhjenn',
      selectedText: '{count} valita',
      // Datetime component
      dateFormat: 'd. MM yy',
      dayNames: ['Sunnuntai', 'Maanantai', 'Tiistai', 'Keskiviiko', 'Torstai', 'Perjantai', 'Lauantai'],
      dayNamesShort: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
      dayNamesMin: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
      dayText: 'Piv',
      delimiter: '.',
      hourText: 'Tuntia',
      minuteText: 'Minuutti',
      monthNames: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Keskuu', 'Heinkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
      monthNamesShort: ['Tam', 'Hel', 'Maa', 'Huh', 'Tou', 'Kes', 'Hei', 'Elo', 'Syy', 'Lok', 'Mar', 'Jou'],
      monthText: 'Kuukausi',
      secText: 'Sekunda',
      timeFormat: 'H:ii',
      yearText: 'Vuosi',
      nowText: 'Nyt',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: 'Pivys',
      timeText: 'Aika',
      todayText: 'Tnn',
      prevMonthText: 'Edellinen kuukausi',
      nextMonthText: 'Ensi kuussa',
      prevYearText: 'Edellinen vuosi',
      nextYearText: 'Ensi vuosi',
      closeText: 'Sulje',
      eventText: 'Tapahtumia',
      eventsText: 'Tapahtumia',
      allDayText: 'Koko piv',
      noEventsText: 'Ei tapahtumia',
      moreEventsText: '{count} muu',
      moreEventsPluralText: '{count} muuta',
      // Daterange component
      fromText: 'Alkaa',
      toText: 'Pttyy',
      // Measurement components
      wholeText: 'Kokonainen',
      fractionText: 'Murtoluku',
      unitText: 'Yksikk',
      // Time / Timespan component
      labels: ['Vuosi', 'Kuukausi', 'Piv', 'Tunnin', 'Minuutti', 'sekuntia', ''],
      labelsShort: ['Vuo', 'Kuu', 'Pi', 'Tun', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Kynnistys',
      stopText: 'Seis',
      resetText: 'Aseta uudelleen',
      lapText: 'Kierros',
      hideText: 'Vuota',
      // Listview
      backText: 'Edellinen',
      undoText: 'Kumoa',
      // Form
      offText: 'Pois',
      onText: 'Pll',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Franais

  mobiscroll$3.i18n.fr = {
      // Core
      setText: 'Terminer',
      cancelText: 'Annuler',
      clearText: 'Effacer',
      selectedText: '{count} slectionn',
      selectedPluralText: '{count} slectionns',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
      dayNamesShort: ['Dim.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'],
      dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
      dayText: 'Jour',
      monthText: 'Mois',
      monthNames: ['Janvier', 'Fvrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Aot', 'Septembre', 'Octobre', 'Novembre', 'Dcembre'],
      monthNamesShort: ['Janv.', 'Fvr.', 'Mars', 'Avril', 'Mai', 'Juin', 'Juil.', 'Aot', 'Sept.', 'Oct.', 'Nov.', 'Dc.'],
      hourText: 'Heures',
      minuteText: 'Minutes',
      secText: 'Secondes',
      timeFormat: 'HH:ii',
      yearText: 'Anne',
      nowText: 'Maintenant',
      pmText: 'pm',
      amText: 'am',
      todayText: "Aujourd'hui",
      // Calendar component
      firstDay: 1,
      dateText: 'Date',
      timeText: 'Heure',
      closeText: 'Fermer',
      allDayText: 'Toute la journe',
      noEventsText: 'Aucun vnement',
      eventText: 'vnement',
      eventsText: 'vnements',
      moreEventsText: '{count} autre',
      moreEventsPluralText: '{count} autres',
      // Daterange component
      fromText: 'Dmarrer',
      toText: 'Fin',
      // Measurement components
      wholeText: 'Entier',
      fractionText: 'Fraction',
      unitText: 'Unit',
      // Time / Timespan component
      labels: ['Ans', 'Mois', 'Jours', 'Heures', 'Minutes', 'Secondes', ''],
      labelsShort: ['Ans', 'Mois', 'Jours', 'Hrs', 'Min', 'Sec', ''],
      // Timer component
      startText: 'Dmarrer',
      stopText: 'Arrter',
      resetText: 'Rinitialiser',
      lapText: 'Lap',
      hideText: 'Cachez',
      // Listview
      backText: 'Retour',
      undoText: 'Annuler',
      // Form
      offText: 'Non',
      onText: 'Oui',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Hebrew

  mobiscroll$3.i18n.he = {
      // Core
      rtl: true, // Right to left mode
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      selectedPluralText: '{count} ',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ["'", "'", "'", "'", "'", "'", "'"],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
      monthText: '',
      secText: '',
      amText: 'am',
      pmText: 'pm',
      timeFormat: 'HH:ii',
      timeWheels: 'iiHH', // Need this for correct RTL display
      yearText: '',
      nowText: '',
      // Calendar component
      firstDay: 0,
      dateText: '',
      timeText: '',
      closeText: '',
      todayText: '',
      allDayText: ' ',
      noEventsText: ' ',
      // Event calendar
      eventText: '',
      eventsText: '',
      moreEventsText: '  ',
      moreEventsPluralText: '{count}  ',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Forms
      offText: '',
      onText: '',
      // Listview
      backText: '',
      undoText: ' '
  };

  // Hindi

  mobiscroll$3.i18n.hi = {
      // Core
      setText: ' ',
      cancelText: ' ',
      clearText: ' ',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: [' ', '', '', '', '', '', '', ' ', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      allDayText: ' ',
      noEventsText: 'Ei tapahtumia',
      moreEventsText: '{count} ',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: ' ',
      lapText: '',
      hideText: '',
      // Listview
      backText: '', // check
      undoText: ' ',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Croatian

  mobiscroll$3.i18n.hr = {
      // Core
      setText: 'Postavi',
      cancelText: 'Izlaz',
      clearText: 'Izbrii',
      selectedText: '{count} odabran',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Nedjelja', 'Ponedjeljak', 'Utorak', 'Srijeda', 'etvrtak', 'Petak', 'Subota'],
      dayNamesShort: ['Ned', 'Pon', 'Uto', 'Sri', 'et', 'Pet', 'Sub'],
      dayNamesMin: ['Ne', 'Po', 'Ut', 'Sr', 'e', 'Pe', 'Su'],
      dayText: 'Dan',
      delimiter: '.',
      hourText: 'Sat',
      minuteText: 'Minuta',
      monthNames: ['Sijeanj', 'Veljaa', 'Oujak', 'Travanj', 'Svibanj', 'Lipanj', 'Srpanj', 'Kolovoz', 'Rujan', 'Listopad', 'Studeni', 'Prosinac'],
      monthNamesShort: ['Sij', 'Velj', 'Ou', 'Tra', 'Svi', 'Lip', 'Srp', 'Kol', 'Ruj', 'Lis', 'Stu', 'Pro'],
      monthText: 'Mjesec',
      secText: 'Sekunda',
      timeFormat: 'H:ii',
      yearText: 'Godina',
      nowText: 'Sada',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'Vrijeme',
      todayText: 'Danas',
      prevMonthText: 'Prethodni mjesec',
      nextMonthText: 'Sljedei mjesec',
      prevYearText: 'Prethodni godina',
      nextYearText: 'Slijedee godine',
      closeText: 'Zatvori',
      eventText: 'Dogaaj',
      eventsText: 'dogaaja',
      allDayText: 'Cijeli dan',
      noEventsText: 'Bez dogaaja',
      moreEventsText: 'Jo {count}',
      // Daterange component
      fromText: 'Poinje',
      toText: 'Zavrava',
      // Measurement components
      wholeText: 'Cjelina',
      fractionText: 'Frakcija',
      unitText: 'Jedinica',
      // Time / Timespan component
      labels: ['godina', 'mjesec', 'dan', 'sat', 'minuta', 'sekunda', ''],
      labelsShort: ['god', 'mje', 'dan', 'sat', 'min', 'sec', ''],
      // Timer component
      startText: 'Poetak',
      stopText: 'Prekid',
      resetText: 'Resetiraj',
      lapText: 'Ciklus',
      hideText: 'Sakriti',
      // Listview
      backText: 'Natrag',
      undoText: 'Ponitavanje',
      // Form
      offText: 'Uklj.',
      onText: 'Isklj.',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Magyar

  mobiscroll$3.i18n.hu = {
      // Core
      setText: 'OK',
      cancelText: 'Mgse',
      clearText: 'Trls',
      selectedText: '{count} kivlasztva',
      // Datetime component
      dateFormat: 'yy.mm.dd.',
      dayNames: ['Vasrnap', 'Htf', 'Kedd', 'Szerda', 'Cstrtk', 'Pntek', 'Szombat'],
      dayNamesShort: ['Va', 'H', 'Ke', 'Sze', 'Cs', 'P', 'Szo'],
      dayNamesMin: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
      dayText: 'Nap',
      delimiter: '.',
      hourText: 'ra',
      minuteText: 'Perc',
      monthNames: ['Janur', 'Februr', 'Mrcius', 'prilis', 'Mjus', 'Jnius', 'Jlius', 'Augusztus', 'Szeptember', 'Oktber', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mr', 'pr', 'Mj', 'Jn', 'Jl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
      monthText: 'Hnap',
      secText: 'Msodperc',
      timeFormat: 'H:ii',
      yearText: 'v',
      nowText: 'Most',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: 'Dtum',
      timeText: 'Id',
      todayText: 'Ma',
      prevMonthText: 'Elz hnap',
      nextMonthText: 'Kvetkez hnap',
      prevYearText: 'Elz v',
      nextYearText: 'Kvetkez v',
      closeText: 'Bezr',
      eventText: 'esemny',
      eventsText: 'esemny',
      allDayText: 'Egsz nap',
      noEventsText: 'Nincs esemny',
      moreEventsText: '{count} tovbbi',
      // Daterange component
      fromText: 'Eleje',
      toText: 'Vge',
      // Measurement components
      wholeText: 'Egsz',
      fractionText: 'Trt',
      unitText: 'Egysg',
      // Time / Timespan component
      labels: ['v', 'Hnap', 'Nap', 'ra', 'Perc', 'Msodperc', ''],
      labelsShort: ['v', 'H.', 'Nap', 'ra', 'Perc', 'Mp.', ''],
      // Timer component
      startText: 'Indt',
      stopText: 'Megllt',
      resetText: 'Visszallt',
      lapText: 'Lap',
      hideText: 'Elrejt',
      // Listview
      backText: 'Vissza',
      undoText: 'Visszavon',
      // Form
      offText: 'Ki',
      onText: 'Be',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Italiano 

  mobiscroll$3.i18n.it = {
      // Core
      setText: 'OK',
      cancelText: 'Annulla',
      clearText: 'Chiarire',
      selectedText: '{count} selezionato',
      selectedPluralText: '{count} selezionati',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Domenica', 'Luned', 'Merted', 'Mercoled', 'Gioved', 'Venerd', 'Sabato'],
      dayNamesShort: ['Do', 'Lu', 'Ma', 'Me', 'Gi', 'Ve', 'Sa'],
      dayNamesMin: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
      dayText: 'Giorno',
      hourText: 'Ore',
      minuteText: 'Minuti',
      monthNames: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'],
      monthNamesShort: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'],
      monthText: 'Mese',
      secText: 'Secondi',
      timeFormat: 'HH:ii',
      yearText: 'Anno',
      nowText: 'Ora',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Oggi',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Volta',
      closeText: 'Chiudere',
      allDayText: 'Tutto il giorno',
      noEventsText: 'Nessun evento',
      eventText: 'Evento',
      eventsText: 'Eventi',
      moreEventsText: '{count} altro',
      moreEventsPluralText: 'altri {count}',
      // Daterange component
      fromText: 'Inizio',
      toText: 'Fine',
      // Measurement components
      wholeText: 'Intero',
      fractionText: 'Frazione',
      unitText: 'Unit',
      // Time / Timespan component
      labels: ['Anni', 'Mesi', 'Giorni', 'Ore', 'Minuti', 'Secondi', ''],
      labelsShort: ['Anni', 'Mesi', 'Gio', 'Ore', 'Min', 'Sec', ''],
      // Timer component
      startText: 'Inizio',
      stopText: 'Arresto',
      resetText: 'Ripristina',
      lapText: 'Lap',
      hideText: 'Nascondi',
      // Listview
      backText: 'Indietro',
      undoText: 'Annulla',
      // Form
      offText: 'Via',
      onText: 'Su',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  //  - Japanese

  mobiscroll$3.i18n.ja = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'yymmdd',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      yearSuffix: '',
      monthSuffix: '',
      daySuffix: '',
      todayText: '',
      // Calendar component
      dateText: '',
      timeText: '',
      closeText: '',
      allDayText: '',
      noEventsText: '',
      eventText: '',
      eventsText: '',
      moreEventsText: ' {count} ',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: ''
  };

  // Korean

  mobiscroll$3.i18n.ko = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'yymmdd',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '-',
      hourText: '',
      minuteText: '',
      monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      yearSuffix: '',
      monthSuffix: '',
      daySuffix: '',
      // Calendar component
      firstDay: 0,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      allDayText: '',
      noEventsText: ' ',
      moreEventsText: '{count} ',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: ' ',
      resetText: '',
      lapText: '',
      hideText: ' ',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Lietuvi

  mobiscroll$3.i18n.lt = {
      // Core
      setText: 'OK',
      cancelText: 'Ataukti',
      clearText: 'Ivalyti',
      selectedText: 'Pasirinktas {count}',
      selectedPluralText: 'Pasirinkti {count}',
      // Datetime component
      dateFormat: 'yy-mm-dd',
      dayNames: ['Sekmadienis', 'Pirmadienis', 'Antradienis', 'Treiadienis', 'Ketvirtadienis', 'Penktadienis', 'etadienis'],
      dayNamesShort: ['S', 'Pr', 'A', 'T', 'K', 'Pn', ''],
      dayNamesMin: ['S', 'Pr', 'A', 'T', 'K', 'Pn', ''],
      dayText: 'Diena',
      hourText: 'Valanda',
      minuteText: 'Minutes',
      monthNames: ['Sausis', 'Vasaris', 'Kovas', 'Balandis', 'Gegu', 'Birelis', 'Liepa', 'Rugpjtis', 'Rugsjis', 'Spalis', 'Lapkritis', 'Gruodis'],
      monthNamesShort: ['Sau', 'Vas', 'Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rugp', 'Rugs', 'Spa', 'Lap', 'Gruo'],
      monthText: 'Mnuo',
      secText: 'Sekundes',
      amText: 'am',
      pmText: 'pm',
      timeFormat: 'HH:ii',
      yearText: 'Metai',
      nowText: 'Dabar',
      todayText: 'iandien',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Laikas',
      closeText: 'Udaryti',
      allDayText: 'Vis dien',
      noEventsText: 'Nra vyki',
      eventText: 'vyki',
      eventsText: 'vykiai',
      moreEventsText: 'Dar {count}',
      // Daterange component
      fromText: 'Nuo',
      toText: 'Iki',
      // Measurement components
      wholeText: 'Visas',
      fractionText: 'Frakcija',
      unitText: 'Vienetas',
      // Time / Timespan component
      labels: ['Metai', 'Mnesiai', 'Dienos', 'Valandos', 'Minutes', 'Sekundes', ''],
      labelsShort: ['m', 'mn.', 'd', 'h', 'min', 's', ''],
      // Timer component
      startText: 'Pradti',
      stopText: 'Sustabdyti',
      resetText: 'Inaujo',
      lapText: 'Ratas',
      hideText: 'Slpti',
      // Listview
      backText: 'Atgal',
      undoText: 'Anuliuoti',
      // Form
      offText: 'Ij.',
      onText: 'j.',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Nederlands

  mobiscroll$3.i18n.nl = {
      // Core
      setText: 'Instellen',
      cancelText: 'Annuleren',
      clearText: 'Leegmaken',
      selectedText: '{count} gekozen',
      // Datetime component
      dateFormat: 'dd-mm-yy',
      dayNames: ['Zondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrijdag', 'Zaterdag'],
      dayNamesShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
      dayNamesMin: ['z', 'm', 'd', 'w', 'd', 'v', 'z'],
      dayText: 'Dag',
      hourText: 'Uur',
      minuteText: 'Minuten',
      monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
      monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
      monthText: 'Maand',
      secText: 'Seconden',
      timeFormat: 'HH:ii',
      yearText: 'Jaar',
      nowText: 'Nu',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Vandaag',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'Tijd',
      closeText: 'Sluiten',
      allDayText: 'Hele dag',
      noEventsText: 'Geen activiteiten',
      eventText: 'Activiteit',
      eventsText: 'Activiteiten',
      moreEventsText: 'nog {count}',
      // Daterange component
      fromText: 'Start',
      toText: 'Einde',
      // Measurement components
      wholeText: 'geheel',
      fractionText: 'fractie',
      unitText: 'eenheid',
      // Time / Timespan component
      labels: ['Jaren', 'Maanden', 'Dagen', 'Uren', 'Minuten', 'Seconden', ''],
      labelsShort: ['j', 'm', 'd', 'u', 'min', 'sec', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Reset',
      lapText: 'Ronde',
      hideText: 'Verbergen',
      // Listview
      backText: 'Terug',
      undoText: 'Onged. maken',
      // Form
      offText: 'Uit',
      onText: 'Aan',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Norsk

  mobiscroll$3.i18n.no = {
      // Core
      setText: 'OK',
      cancelText: 'Avbryt',
      clearText: 'Tmme',
      selectedText: '{count} valgt',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
      dayNamesShort: ['S', 'Ma', 'Ti', 'On', 'To', 'Fr', 'L'],
      dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
      dayText: 'Dag',
      delimiter: '.',
      hourText: 'Time',
      minuteText: 'Minutt',
      monthNames: ['Januar', 'Februar', 'Mars', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Desember'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
      monthText: 'Mned',
      secText: 'Sekund',
      timeFormat: 'HH:ii',
      yearText: 'r',
      nowText: 'N',
      pmText: 'pm',
      amText: 'am',
      todayText: 'I dag',
      // Calendar component
      firstDay: 1,
      dateText: 'Dato',
      timeText: 'Tid',
      closeText: 'Lukk',
      allDayText: 'Hele dagen',
      noEventsText: 'Ingen hendelser',
      eventText: 'Hendelse',
      eventsText: 'Hendelser',
      moreEventsText: '{count} mere',
      // Daterange component
      fromText: 'Start',
      toText: 'End',
      // Measurement components
      wholeText: 'Hele',
      fractionText: 'Fraksjon',
      unitText: 'Enhet',
      // Time / Timespan component
      labels: ['r', 'Mneder', 'Dager', 'Timer', 'Minutter', 'Sekunder', ''],
      labelsShort: ['r', 'Mn', 'Dag', 'Time', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stopp',
      resetText: 'Tilbakestille',
      lapText: 'Runde',
      hideText: 'Skjul',
      // Listview
      backText: 'Tilbake',
      undoText: 'Angre',
      // Form
      offText: 'Av',
      onText: 'P',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Polski

  mobiscroll$3.i18n.pl = {
      // Core
      setText: 'Zestaw',
      cancelText: 'Anuluj',
      clearText: 'Oczyci',
      selectedText: 'Wybr: {count}',
      // Datetime component
      dateFormat: 'yy-mm-dd',
      dayNames: ['Niedziela', 'Poniedziaek', 'Wtorek', 'roda', 'Czwartek', 'Pitek', 'Sobota'],
      dayNamesShort: ['Niedz.', 'Pon.', 'Wt.', 'r.', 'Czw.', 'Pt.', 'Sob.'],
      dayNamesMin: ['N', 'P', 'W', '', 'C', 'P', 'S'],
      dayText: 'Dzie',
      hourText: 'Godziny',
      minuteText: 'Minuty',
      monthNames: ['Stycze', 'Luty', 'Marzec', 'Kwiecie', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpie', 'Wrzesie', 'Padziernik', 'Listopad', 'Grudzie'],
      monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Pa', 'Lis', 'Gru'],
      monthText: 'Miesic',
      secText: 'Sekundy',
      timeFormat: 'HH:ii',
      yearText: 'Rok',
      nowText: 'Teraz',
      amText: 'am',
      pmText: 'pm',
      todayText: 'Dzisiaj',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Czas',
      closeText: 'Zakoczenie',
      allDayText: 'Cay dzie',
      noEventsText: 'Brak wydarze',
      eventText: 'Wydarze',
      eventsText: 'Wydarzenia',
      moreEventsText: 'Jeszcze {count}',
      // Daterange component
      fromText: 'Rozpoczcie',
      toText: 'Koniec',
      // Measurement components
      wholeText: 'Cay',
      fractionText: 'Uamek',
      unitText: 'Jednostka',
      // Time / Timespan component
      labels: ['Lata', 'Miesic', 'Dni', 'Godziny', 'Minuty', 'Sekundy', ''],
      labelsShort: ['R', 'M', 'Dz', 'Godz', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Rozpoczcie',
      stopText: 'Zatrzyma',
      resetText: 'Zresetowa',
      lapText: 'Zakadka',
      hideText: 'Ukry',
      // Listview
      backText: 'Wr',
      undoText: 'Cofnij',
      // Form
      offText: 'Wy',
      onText: 'W',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Portugus Brasileiro
  /*
   * Translation by: Ivan Gomes <contato@ivangomes.com.br>
   */

  mobiscroll$3.i18n['pt-BR'] = {
      // Core
      setText: 'Selecionar',
      cancelText: 'Cancelar',
      clearText: 'Claro',
      selectedText: '{count} selecionado',
      selectedPluralText: '{count} selecionados',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Domingo', 'Segunda-feira', 'Tera-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sbado'],
      dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
      dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
      dayText: 'Dia',
      hourText: 'Hora',
      minuteText: 'Minutos',
      monthNames: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
      monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
      monthText: 'Ms',
      secText: 'Segundo',
      timeFormat: 'HH:ii',
      yearText: 'Ano',
      nowText: 'Agora',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Hoje',
      // Calendar component
      dateText: 'Data',
      timeText: 'Tempo',
      closeText: 'Fechar',
      allDayText: 'Dia inteiro',
      noEventsText: 'Nenhum evento',
      eventText: 'Evento',
      eventsText: 'Eventos',
      moreEventsText: 'Mais {count}',
      // Daterange component
      fromText: 'In&iacute;cio',
      toText: 'Fim',
      // Measurement components
      wholeText: 'Inteiro',
      fractionText: 'Frao',
      unitText: 'Unidade',
      // Time / Timespan component
      labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
      labelsShort: ['Ano', 'M&ecirc;s', 'Dia', 'Hora', 'Min', 'Seg', ''],
      // Timer component
      startText: 'Comear',
      stopText: 'Pare',
      resetText: 'Reinicializar',
      lapText: 'Lap',
      hideText: 'Esconder',
      // Listview
      backText: 'Anterior',
      undoText: 'Desfazer',
      // Form
      offText: 'Desl',
      onText: 'Lig',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Portugus Europeu
  /*
   * Translation by: Jorge Simoes <http://jorge.simoes.com>
   */

  mobiscroll$3.i18n['pt-PT'] = {
      // Core
      setText: 'Seleccionar',
      cancelText: 'Cancelar',
      clearText: 'Claro',
      selectedText: '{count} selecionado',
      selectedPluralText: '{count} selecionados',
      // Datetime component
      dateFormat: 'dd-mm-yy',
      dayNames: ['Domingo', 'Segunda-feira', 'Tera-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sbado'],
      dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
      dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
      dayText: 'Dia',
      hourText: 'Horas',
      minuteText: 'Minutos',
      monthNames: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
      monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
      monthText: 'Ms',
      secText: 'Segundo',
      timeFormat: 'HH:ii',
      yearText: 'Ano',
      nowText: 'Actualizar',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Hoy',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Tempo',
      closeText: 'Fechar',
      allDayText: 'Todo o dia',
      noEventsText: 'Nenhum evento',
      eventText: 'Evento',
      eventsText: 'Eventos',
      moreEventsText: 'mais {count}',
      // Daterange component
      fromText: 'Incio',
      toText: 'Fim',
      // Measurement components
      wholeText: 'Inteiro',
      fractionText: 'Fraco',
      unitText: 'Unidade',
      // Time / Timespan component
      labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
      labelsShort: ['Ano', 'Ms', 'Dia', 'Hora', 'Min', 'Seg', ''],
      // Timer component
      startText: 'Comear',
      stopText: 'Parar',
      resetText: 'Reinicializar',
      lapText: 'Lap',
      hideText: 'Esconder',
      // Listview
      backText: 'Anterior',
      undoText: 'Anular',
      // Form
      offText: 'Desl',
      onText: 'Lig',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Romn

  mobiscroll$3.i18n.ro = {
      // Core
      setText: 'Setare',
      cancelText: 'Anulare',
      clearText: 'tergere',
      selectedText: '{count} selectat',
      selectedPluralText: '{count} selectate',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Duminic', 'Luni', 'Mari', 'Miercuri', 'Joi', 'Vineri', 'Smbt'],
      dayNamesShort: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'S'],
      dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
      dayText: ' Ziua',
      delimiter: '.',
      hourText: ' Ore ',
      minuteText: 'Minute',
      monthNames: ['Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie', 'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'],
      monthNamesShort: ['Ian.', 'Feb.', 'Mar.', 'Apr.', 'Mai', 'Iun.', 'Iul.', 'Aug.', 'Sept.', 'Oct.', 'Nov.', 'Dec.'],
      monthText: 'Luna',
      secText: 'Secunde',
      timeFormat: 'HH:ii',
      yearText: 'Anul',
      nowText: 'Acum',
      amText: 'am',
      pmText: 'pm',
      todayText: 'Astzi',
      prevMonthText: 'Luna anterioar',
      nextMonthText: 'Luna urmtoare',
      prevYearText: 'Anul anterior',
      nextYearText: 'Anul urmtor',
      eventText: 'Eveniment',
      eventsText: 'Evenimente',
      allDayText: 'Toat ziua',
      noEventsText: 'Niciun eveniment',
      moreEventsText: 'nc unul',
      moreEventsPluralText: 'nc {count}',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Ora',
      closeText: 'nchidere',
      // Daterange component
      fromText: 'Start',
      toText: 'Final',
      // Measurement components
      wholeText: 'Complet',
      fractionText: 'Parial',
      unitText: 'Unitate',
      // Time / Timespan component
      labels: ['Ani', 'Luni', 'Zile', 'Ore', 'Minute', 'Secunde', ''],
      labelsShort: ['Ani', 'Luni', 'Zile', 'Ore', 'Min.', 'Sec.', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Resetare',
      lapText: 'Tur',
      hideText: 'Ascundere',
      // Listview
      backText: 'napoi',
      undoText: 'Anuleaz',
      // Form
      offText: 'Nu',
      onText: 'Da',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  //  (UA)

  mobiscroll$3.i18n['ru-UA'] = {
      // Core
      setText: '',
      cancelText: '',
      clearText: 'r',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['.', '.', '', '.', '', '', '', '.', '.', '.', '.', '.'],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      yearText: '',
      nowText: '',
      amText: 'am',
      pmText: 'pm',
      todayText: 'C',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      closeText: '',
      allDayText: ' ',
      noEventsText: ' ',
      eventText: '',
      eventsText: '',
      moreEventsText: ' {count}',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '  ', '  ', '  ', '  ', ' ', ''],
      labelsShort: ['', '.', '.', '.', '.', '.', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '  ',
      lapText: '  ',
      hideText: '  ',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // 

  mobiscroll$3.i18n['ru-RU'] = mobiscroll$3.i18n.ru = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      yearText: '',
      nowText: '',
      amText: 'am',
      pmText: 'pm',
      todayText: 'C',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      closeText: '',
      allDayText: ' ',
      noEventsText: ' ',
      eventText: '',
      eventsText: '',
      moreEventsText: ' {count}',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Slovencina

  mobiscroll$3.i18n.sk = {
      // Core
      setText: 'Zadaj',
      cancelText: 'Zrui',
      clearText: 'Vymaza',
      selectedText: 'Oznaen: {count}',
      // Datetime component
      dateFormat: 'd.m.yy',
      dayNames: ['Nedea', 'Pondelok', 'Utorok', 'Streda', 'tvrtok', 'Piatok', 'Sobota'],
      dayNamesShort: ['Ne', 'Po', 'Ut', 'St', 't', 'Pi', 'So'],
      dayNamesMin: ['N', 'P', 'U', 'S', '', 'P', 'S'],
      dayText: 'e',
      hourText: 'Hodiny',
      minuteText: 'Minty',
      monthNames: ['Janur', 'Februr', 'Marec', 'Aprl', 'Mj', 'Jn', 'Jl', 'August', 'September', 'Oktber', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mj', 'Jn', 'Jl', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
      monthText: 'Mesiac',
      secText: 'Sekundy',
      timeFormat: 'H:ii',
      yearText: 'Rok',
      nowText: 'Teraz',
      amText: 'am',
      pmText: 'pm',
      todayText: 'Dnes',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'as',
      closeText: 'Zavrie',
      allDayText: 'Cel de',
      noEventsText: 'iadne udalosti',
      eventText: 'Udalost',
      eventsText: 'Udalosti',
      moreEventsText: '{count} alia',
      moreEventsPluralText: '{count} alie',
      // Daterange component
      fromText: 'Zaiatok',
      toText: 'Koniec',
      // Measurement components
      wholeText: 'Cel',
      fractionText: 'as',
      unitText: 'Jednotka',
      // Time / Timespan component
      labels: ['Roky', 'Mesiace', 'Dni', 'Hodiny', 'Minty', 'Sekundy', ''],
      labelsShort: ['Rok', 'Mes', 'Dni', 'Hod', 'Min', 'Sec', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Resetova',
      lapText: 'Etapa',
      hideText: 'Schova',
      // Listview
      backText: 'Sp',
      undoText: 'Sp',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Serbian

  mobiscroll$3.i18n.sr = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      allDayText: ' ',
      noEventsText: ' ',
      moreEventsText: ' {count}',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: 'e',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Svenska

  mobiscroll$3.i18n.sv = {
      // Core
      setText: 'OK',
      cancelText: 'Avbryt',
      clearText: 'Klara',
      selectedText: '{count} vald',
      // Datetime component
      dateFormat: 'yy-mm-dd',
      dayNames: ['Sndag', 'Mndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
      dayNamesShort: ['S', 'M', 'Ti', 'On', 'To', 'Fr', 'L'],
      dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
      dayText: 'Dag',
      hourText: 'Timme',
      minuteText: 'Minut',
      monthNames: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni', 'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
      monthText: 'Mnad',
      secText: 'Sekund',
      timeFormat: 'HH:ii',
      yearText: 'r',
      nowText: 'Nu',
      pmText: 'pm',
      amText: 'am',
      todayText: 'I dag',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'Tid',
      closeText: 'Stng',
      allDayText: 'Heldag',
      noEventsText: 'Inga aktiviteter',
      eventText: 'Hndelse',
      eventsText: 'Hndelser',
      moreEventsText: '{count} till',
      // Daterange component
      fromText: 'Start',
      toText: 'Slut',
      // Measurement components
      wholeText: 'Hela',
      fractionText: 'Brk',
      unitText: 'Enhet',
      // Time / Timespan component
      labels: ['r', 'Mnader', 'Dagar', 'Timmar', 'Minuter', 'Sekunder', ''],
      labelsShort: ['r', 'Mn', 'Dag', 'Tim', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stopp',
      resetText: 'terstll',
      lapText: 'Varv',
      hideText: 'Dlj',
      // Listview
      backText: 'Tillbaka',
      undoText: 'ngra',
      // Form
      offText: 'Av',
      onText: 'P'
  };

  // Trke

  mobiscroll$3.i18n.tr = {
      // Core
      setText: 'Se',
      cancelText: 'ptal',
      clearText: 'Temizleyin',
      selectedText: '{count} seilmi',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Pazar', 'Pazartesi', 'Sal', 'aramba', 'Perembe', 'Cuma', 'Cumartesi'],
      dayNamesShort: ['Paz', 'Pzt', 'Sal', 'ar', 'Per', 'Cum', 'Cmt'],
      dayNamesMin: ['P', 'P', 'S', '', 'P', 'C', 'C'],
      dayText: 'Gn',
      delimiter: '.',
      hourText: 'Saat',
      minuteText: 'Dakika',
      monthNames: ['Ocak', 'ubat', 'Mart', 'Nisan', 'Mays', 'Haziran', 'Temmuz', 'Austos', 'Eyll', 'Ekim', 'Kasm', 'Aralk'],
      monthNamesShort: ['Oca', 'ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Au', 'Eyl', 'Eki', 'Kas', 'Ara'],
      monthText: 'Ay',
      secText: 'Saniye',
      timeFormat: 'HH:ii',
      yearText: 'Yl',
      nowText: 'imdi',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Bugn',
      // Calendar component
      firstDay: 1,
      dateText: 'Tarih',
      timeText: 'Zaman',
      closeText: 'Kapatmak',
      allDayText: 'Tm gn',
      noEventsText: 'Etkinlik Yok',
      eventText: 'Etkinlik',
      eventsText: 'Etkinlikler',
      moreEventsText: '{count} tane daha',
      // Daterange component
      fromText: 'Bala',
      toText: 'Son',
      // Measurement components
      wholeText: 'Tam',
      fractionText: 'Kesir',
      unitText: 'Birim',
      // Time / Timespan component
      labels: ['Yl', 'Ay', 'Gn', 'Saat', 'Dakika', 'Saniye', ''],
      labelsShort: ['Yl', 'Ay', 'Gn', 'Sa', 'Dak', 'Sn', ''],
      // Timer component
      startText: 'Bala',
      stopText: 'Durdur',
      resetText: 'Sfrla',
      lapText: 'Tur',
      hideText: 'Gizle',
      // Listview
      backText: 'Geri',
      undoText: 'Geri Al',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: '.'
  };

  // Vietnamese 

  mobiscroll$3.i18n.vi = {
      // Core
      setText: 't',
      cancelText: 'Hy b',
      clearText: 'Xa',
      selectedText: '{count} chn',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Ch Nht', 'Th Hai', 'Th Ba', 'Th T', 'Th Nm', 'Th Su', 'Th By'],
      dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
      dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
      dayText: '',
      delimiter: '/',
      hourText: 'Gi',
      minuteText: 'Pht',
      monthNames: ['Thng Mt', 'Thng Hai', 'Thng Ba', 'Thng T', 'Thng Nm', 'Thng Su', 'Thng By', 'Thng Tm', 'Thng Chn', 'Thng Mi', 'Thng Mi Mt', 'Thng Mi Hai'],
      monthNamesShort: ['Thng 1', 'Thng 2', 'Thng 3', 'Thng 4', 'Thng 5', 'Thng 6', 'Thng 7', 'Thng 8', 'Thng 9', 'Thng 10', 'Thng 11', 'Thng 12'],
      monthText: 'Thng',
      secText: 'Giy',
      timeFormat: 'H:ii',
      yearText: 'Nm',
      nowText: 'By gi',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 0,
      dateText: 'Ngy',
      timeText: 'Hi',
      todayText: 'Hm nay',
      prevMonthText: 'Thng trc',
      nextMonthText: 'Thng ti',
      prevYearText: 'Mm trc',
      nextYearText: 'Nm ti',
      closeText: 'ng',
      eventText: 'S kin',
      eventsText: 'S kin',
      allDayText: 'C ngy',
      noEventsText: 'Khng c s kin',
      moreEventsText: '{count} th khc',
      // Daterange component
      fromText: 'T',
      toText: 'Ti',
      // Measurement components
      wholeText: 'Ton th',
      fractionText: 'Phn s',
      unitText: 'n v',
      // Time / Timespan component
      labels: ['Nm', 'Thng', 'Ngy', 'Gi', 'Pht', 'Giy', ''],
      labelsShort: ['Nm', 'Thng', 'Ngy', 'Gi', 'Pht', 'Giy', ''],
      // Timer component
      startText: 'Bt u',
      stopText: 'Dng',
      resetText: 't li',
      lapText: 'Vng',
      hideText: 'Giu',
      // Listview
      backText: 'Quay li',
      undoText: 'Hon tc',
      // Form
      offText: 'Tt',
      onText: 'Bt',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Chinese

  mobiscroll$3.i18n.zh = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'yymmd',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      yearSuffix: '',
      monthSuffix: '',
      daySuffix: '',
      todayText: '',
      // Calendar component
      dateText: '',
      timeText: '',
      closeText: '',
      allDayText: '',
      noEventsText: '',
      eventText: '',
      eventsText: '',
      moreEventsText: ' {count} ',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  var themes$1 = mobiscroll$3.themes;

  themes$1.frame.ios = {
      display: 'bottom', // frame
      headerText: false, // frame
      btnWidth: false, // frame
      deleteIcon: 'ios-backspace', // numpad
      scroll3d: os != 'wp' && (os != 'android' || majorVersion > 7)
  };

  themes$1.scroller.ios = extend$1({}, themes$1.frame.ios, {
      rows: 5, // scroller
      height: 34, // scroller
      minWidth: 55, // scroller
      selectedLineHeight: true, // scroller
      selectedLineBorder: 1, // scroller
      showLabel: false, // scroller
      useShortLabels: true, // timespan/timer
      btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5', // scroller
      btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5', // scroller
      checkIcon: 'ion-ios7-checkmark-empty', // select
      filterClearIcon: 'ion-close-circled', // select
      dateDisplay: 'MMdyy', // date
      btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5', // calendar
      btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar
  });

  themes$1.listview.ios = {
      leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',
      rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'
  };

  themes$1.form.ios = {};

  function _addRipple($control, ev) {
      var x = getCoord(ev, 'X', true),
          y = getCoord(ev, 'Y', true),
          rect = $control.offset(),
          left = x - rect.left,
          top = y - rect.top,
          width = Math.max(left, $control[0].offsetWidth - left),
          height = Math.max(top, $control[0].offsetHeight - top),
          size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

      _removeRipple($ripple);

      $ripple = $$2('<span class="mbsc-ripple"></span>').css({
          width: size,
          height: size,
          top: y - rect.top - size / 2,
          left: x - rect.left - size / 2
      }).appendTo($control);

      setTimeout(function () {
          $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');
      }, 10);
  }

  function _removeRipple($r) {
      setTimeout(function () {
          if ($r) {
              $r.removeClass('mbsc-ripple-visible');
              setTimeout(function () {
                  $r.remove();
              }, 2000);
          }
      }, 100);
  }

  function initRipple($markup, selector, disabled, nohl) {
      var startX, startY;

      $markup.off('.mbsc-ripple').on('touchstart.mbsc-ripple mousedown.mbsc-ripple', selector, function (ev) {
          if (testTouch(ev, this)) {
              startX = getCoord(ev, 'X');
              startY = getCoord(ev, 'Y');

              $active$1 = $$2(this);

              if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {
                  _addRipple($active$1, ev);
              } else {
                  $active$1 = null;
              }
          }
      }).on('touchmove.mbsc-ripple mousemove.mbsc-ripple', selector, function (ev) {
          if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {
              _removeRipple($ripple);
              $active$1 = null;
          }
      }).on('touchend.mbsc-ripple touchcancel.mbsc-ripple mouseleave.mbsc-ripple mouseup.mbsc-ripple', selector, function () {
          if ($active$1) {
              setTimeout(function () {
                  _removeRipple($ripple);
              }, 100);
              $active$1 = null;
          }
      });
  }

  var $active$1;
  var $ripple;
  var themes$2 = mobiscroll$3.themes;

  themes$2.frame.material = {
      headerText: false,
      btnWidth: false,
      deleteIcon: 'material-backspace',
      onMarkupReady: function onMarkupReady(ev) {
          initRipple($$2(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');
      }
  };

  themes$2.scroller.material = extend$1({}, themes$2.frame.material, {
      showLabel: false,
      selectedLineBorder: 2,
      weekDays: 'min',
      icon: {
          filled: 'material-star',
          empty: 'material-star-outline'
      },
      checkIcon: 'material-check',
      btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',
      btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',
      btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',
      btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right'
  });

  themes$2.listview.material = {
      leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',
      rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',
      onItemActivate: function onItemActivate(ev) {
          _addRipple($$2(ev.target), ev.domEvent);
      },
      onItemDeactivate: function onItemDeactivate() {
          _removeRipple($ripple);
      },
      onSlideStart: function onSlideStart(ev) {
          $$2('.mbsc-ripple', ev.target).remove();
      },
      onSortStart: function onSortStart(ev) {
          $$2('.mbsc-ripple', ev.target).remove();
      }
  };

  themes$2.navigation.material = {
      onInit: function onInit() {
          initRipple($$2(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');
      },
      onMarkupInit: function onMarkupInit() {
          $$2('.mbsc-ripple', this).remove();
      },
      onDestroy: function onDestroy() {
          $$2(this).off('.mbsc-ripple');
      }
  };

  themes$2.form.material = {
      addRipple: function addRipple(elm, ev) {
          _addRipple(elm, ev);
      },
      removeRipple: function removeRipple() {
          _removeRipple($ripple);
      }
  };

  var themes$3 = mobiscroll$3.themes;

  themes$3.frame.windows = {
      headerText: false,
      deleteIcon: 'backspace4',
      //setIcon: 'material-check',
      //cancelIcon: 'material-close',
      //closeIcon: 'material-close',
      //clearIcon: 'material-close',
      //okIcon: 'material-check',
      //nowIcon: 'loop2',
      //startIcon: 'play3',
      //stopIcon: 'pause2',
      //resetIcon: 'stop2',
      //lapIcon: 'loop2',
      //btnWidth: false,
      btnReverse: true
  };

  themes$3.scroller.windows = extend$1({}, themes$3.frame.windows, {
      rows: 6, // scroller
      minWidth: 88,
      height: 44,
      btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
      btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
      checkIcon: 'material-check',
      dateDisplay: 'MMdyy', // date
      showLabel: false,
      showScrollArrows: true,
      btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5', // calendar
      btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5', // calendar
      dayNamesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      useShortLabels: true // timespan/timer
  });

  themes$3.form.windows = {};

  mobiscroll$3.customTheme('ios-dark', 'ios');

  mobiscroll$3.customTheme('material-dark', 'material');

  mobiscroll$3.customTheme('mobiscroll-dark', 'mobiscroll');

  mobiscroll$3.customTheme('windows-dark', 'windows');

  var themes$4 = mobiscroll$3.themes;

  var theme = 'mobiscroll';

  if (os == 'android') {
      theme = 'material';
  } else if (os == 'ios') {
      theme = 'ios';
  } else if (os == 'wp') {
      theme = 'windows';
  }

  $$2.each(themes$4.frame, function (key, settings) {
      // Stop at the first custom theme with the OS base theme
      if (theme && settings.baseTheme == theme && key != 'mobiscroll-dark' && key != 'material-dark' && key != 'windows-dark' && key != 'ios-dark') {
          mobiscroll$3.autoTheme = key;
          return false;
      } else if (key == theme) {
          mobiscroll$3.autoTheme = key;
      }
  });

  // Languages
  // Themes
  // Custom themes
  // Auto Theme

  // Components

  return mobiscroll$3;

})));

//# sourceMappingURL=mobiscroll.react.js.map