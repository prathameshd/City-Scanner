(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('react-dom'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['react', 'react-dom', 'prop-types'], factory) :
  (global.mobiscroll = factory(global.React,global.ReactDOM,global.PropTypes));
}(this, (function (React,ReactDOM,PropTypes) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;
  ReactDOM = ReactDOM && ReactDOM.hasOwnProperty('default') ? ReactDOM['default'] : ReactDOM;
  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

  var mobiscroll$3 = mobiscroll$3 || {};

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };











  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();







  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };











  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var cssNumber = {
      'column-count': 1,
      'columns': 1,
      'font-weight': 1,
      'line-height': 1,
      'opacity': 1,
      'z-index': 1,
      'zoom': 1
  };
  var propMap = {
      'readonly': 'readOnly'
  };
  var emptyArray = [];
  var _slice = Array.prototype.slice;

  function isFunction(value) {
      return typeof value === "function";
  }

  function isObject(obj) {
      return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === "object";
  }

  function likeArray(obj) {
      return typeof obj.length == 'number';
  }

  function camelize(str) {
      return str.replace(/-+(.)?/g, function (match, chr) {
          return chr ? chr.toUpperCase() : '';
      });
  }

  function extend(target, source, deep) {
      for (var key in source) {
          if (deep && ($$1.isPlainObject(source[key]) || $$1.isArray(source[key]))) {
              if ($$1.isPlainObject(source[key]) && !$$1.isPlainObject(target[key]) || $$1.isArray(source[key]) && !$$1.isArray(target[key])) {
                  target[key] = {};
              }
              extend(target[key], source[key], deep);
          } else if (source[key] !== undefined) {
              target[key] = source[key];
          }
      }
  }

  function dasherize(str) {
      return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
  }

  function maybeAddPx(name, value) {
      return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
  }

  var Dom = function () {
      var Dom = function Dom(arr) {
          var _this = this,
              i = 0;
          // Create array-like object
          for (i = 0; i < arr.length; i++) {
              _this[i] = arr[i];
          }
          _this.length = arr.length;
          // Return collection with methods
          return $(this);
      };

      var $ = function $(selector, context) {
          var arr = [],
              i = 0;
          if (selector && !context) {
              if (selector instanceof Dom) {
                  return selector;
              }
          }

          if (isFunction(selector)) {
              return $(document).ready(selector);
          }

          if (selector) {
              // String
              if (typeof selector === 'string') {
                  var els, tempParent, html;
                  selector = html = selector.trim();
                  if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                      var toCreate = 'div';
                      if (html.indexOf('<li') === 0) {
                          toCreate = 'ul';
                      }
                      if (html.indexOf('<tr') === 0) {
                          toCreate = 'tbody';
                      }
                      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
                          toCreate = 'tr';
                      }
                      if (html.indexOf('<tbody') === 0) {
                          toCreate = 'table';
                      }
                      if (html.indexOf('<option') === 0) {
                          toCreate = 'select';
                      }
                      tempParent = document.createElement(toCreate);
                      tempParent.innerHTML = html;
                      for (i = 0; i < tempParent.childNodes.length; i++) {
                          arr.push(tempParent.childNodes[i]);
                      }
                  } else {
                      if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                          // Pure ID selector
                          els = [document.getElementById(selector.split('#')[1])];
                      } else {
                          if (context instanceof Dom) {
                              context = context[0];
                          }
                          // Other selectors
                          els = (context || document).querySelectorAll(selector);
                      }
                      for (i = 0; i < els.length; i++) {
                          if (els[i]) {
                              arr.push(els[i]);
                          }
                      }
                  }
              }
              // Node/element
              else if (selector.nodeType || selector === window || selector === document) {
                      arr.push(selector);
                  }
                  //Array of elements or instance of Dom
                  else if (selector.length > 0 && selector[0].nodeType) {
                          for (i = 0; i < selector.length; i++) {
                              arr.push(selector[i]);
                          }
                      } else if ($.isArray(selector)) {
                          arr = selector;
                      }
          }
          return new Dom(arr);
      };

      Dom.prototype = {
          ready: function ready(callback) {
              if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {
                  callback($);
              } else {
                  document.addEventListener('DOMContentLoaded', function () {
                      callback($);
                  }, false);
              }
              return this;
          },
          concat: emptyArray.concat,
          empty: function empty() {
              return this.each(function () {
                  this.innerHTML = '';
              });
          },
          map: function map(fn) {
              return $($.map(this, function (el, i) {
                  return fn.call(el, i, el);
              }));
          },
          slice: function slice() {
              return $(_slice.apply(this, arguments));
          },
          // Classes and attriutes
          // NOTE: element.classList attribure is not supported on android 2.3!!!
          addClass: function addClass(className) {
              if (typeof className === 'undefined') {
                  return this;
              }

              var classes = className.split(' ');

              for (var i = 0; i < classes.length; i++) {
                  for (var j = 0; j < this.length; j++) {
                      if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
                          this[j].classList.add(classes[i]);
                      }
                  }
              }
              return this;
          },
          removeClass: function removeClass(className) {
              if (typeof className === 'undefined') {
                  return this;
              }

              var classes = className.split(' ');
              for (var i = 0; i < classes.length; i++) {
                  for (var j = 0; j < this.length; j++) {
                      if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
                          this[j].classList.remove(classes[i]);
                      }
                  }
              }
              return this;
          },
          hasClass: function hasClass(className) {
              return this[0] ? this[0].classList.contains(className) : false;
          },
          toggleClass: function toggleClass(className) {
              var classes = className.split(' ');
              for (var i = 0; i < classes.length; i++) {
                  for (var j = 0; j < this.length; j++) {
                      if (typeof this[j].classList !== 'undefined') {
                          this[j].classList.toggle(classes[i]);
                      }
                  }
              }
              return this;
          },
          closest: function closest(selector, context) {
              var node = this[0],
                  collection = false;

              if (isObject(selector)) {
                  collection = $(selector);
              }
              while (node && !(collection ? collection.indexOf(node) >= 0 : $.matches(node, selector))) {
                  node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;
              }

              return $(node);
          },
          attr: function attr(attrs, value) {
              var attr;

              if (arguments.length === 1 && typeof attrs === 'string') {
                  // Get attr
                  if (this.length) {
                      attr = this[0].getAttribute(attrs);
                      return attr || attr === '' ? attr : undefined;
                  }
              } else {
                  // Set attrs
                  for (var i = 0; i < this.length; i++) {
                      if (arguments.length === 2) {
                          // String
                          this[i].setAttribute(attrs, value);
                      } else {
                          // Object
                          for (var attrName in attrs) {
                              this[i][attrName] = attrs[attrName];
                              this[i].setAttribute(attrName, attrs[attrName]);
                          }
                      }
                  }
                  return this;
              }
          },
          removeAttr: function removeAttr(attr) {
              for (var i = 0; i < this.length; i++) {
                  this[i].removeAttribute(attr);
              }
              return this;
          },
          prop: function prop(props, value) {
              props = propMap[props] || props;
              if (arguments.length === 1 && typeof props === 'string') {
                  // Get prop
                  return this[0] ? this[0][props] : undefined;
              } else {
                  // Set props
                  for (var i = 0; i < this.length; i++) {
                      this[i][props] = value;
                  }
                  return this;
              }
          },
          val: function val(value) {
              if (typeof value === 'undefined') {
                  if (this.length && this[0].multiple) {
                      return $.map(this.find('option:checked'), function (v) {
                          return v.value;
                      });
                  }
                  return this[0] ? this[0].value : undefined;
              }

              if (this.length && this[0].multiple) {
                  $.each(this[0].options, function () {
                      this.selected = value.indexOf(this.value) != -1;
                  });
              } else {
                  for (var i = 0; i < this.length; i++) {
                      this[i].value = value;
                  }
              }

              return this;
          },
          //Events
          on: function on(eventName, targetSelector, listener, capture) {
              var events = eventName.split(' '),
                  i,
                  j;

              function handleLiveEvent(e) {
                  var k,
                      parents,
                      target = e.target;

                  if ($(target).is(targetSelector)) {
                      listener.call(target, e);
                  } else {
                      parents = $(target).parents();
                      for (k = 0; k < parents.length; k++) {
                          if ($(parents[k]).is(targetSelector)) {
                              listener.call(parents[k], e);
                          }
                      }
                  }
              }

              function handleNamespaces(elm, name, listener, capture) {
                  var namespace = name.split('.');

                  if (!elm.DomNameSpaces) {
                      elm.DomNameSpaces = [];
                  }

                  elm.DomNameSpaces.push({
                      namespace: namespace[1],
                      event: namespace[0],
                      listener: listener,
                      capture: capture
                  });

                  elm.addEventListener(namespace[0], listener, capture);
              }

              for (i = 0; i < this.length; i++) {
                  if (isFunction(targetSelector) || targetSelector === false) {
                      // Usual events
                      if (isFunction(targetSelector)) {
                          capture = listener || false;
                          listener = targetSelector;
                      }
                      for (j = 0; j < events.length; j++) {
                          // check for namespaces
                          if (events[j].indexOf('.') != -1) {
                              handleNamespaces(this[i], events[j], listener, capture);
                          } else {
                              this[i].addEventListener(events[j], listener, capture);
                          }
                      }
                  } else {
                      // Live events
                      for (j = 0; j < events.length; j++) {
                          if (!this[i].DomLiveListeners) {
                              this[i].DomLiveListeners = [];
                          }

                          this[i].DomLiveListeners.push({
                              listener: listener,
                              liveListener: handleLiveEvent
                          });

                          if (events[j].indexOf('.') != -1) {
                              handleNamespaces(this[i], events[j], handleLiveEvent, capture);
                          } else {
                              this[i].addEventListener(events[j], handleLiveEvent, capture);
                          }
                      }
                  }
              }
              return this;
          },
          off: function off(eventName, targetSelector, listener, capture) {
              var events,
                  i,
                  j,
                  k,
                  that = this;

              function removeEvents(event) {
                  var i,
                      j,
                      item,
                      parts = event.split('.'),
                      name = parts[0],
                      ns = parts[1];

                  for (i = 0; i < that.length; ++i) {
                      if (that[i].DomNameSpaces) {
                          for (j = 0; j < that[i].DomNameSpaces.length; ++j) {
                              item = that[i].DomNameSpaces[j];

                              if (item.namespace == ns && (item.event == name || !name)) {
                                  that[i].removeEventListener(item.event, item.listener, item.capture);
                                  item.removed = true;
                              }
                          }
                          // remove the events from the DomNameSpaces array
                          for (j = that[i].DomNameSpaces.length - 1; j >= 0; --j) {
                              if (that[i].DomNameSpaces[j].removed) {
                                  that[i].DomNameSpaces.splice(j, 1);
                              }
                          }
                      }
                  }
              }

              events = eventName.split(' ');

              for (i = 0; i < events.length; i++) {
                  for (j = 0; j < this.length; j++) {
                      if (isFunction(targetSelector) || targetSelector === false) {
                          // Usual events
                          if (isFunction(targetSelector)) {
                              capture = listener || false;
                              listener = targetSelector;
                          }

                          if (events[i].indexOf('.') === 0) {
                              // remove namespace events
                              removeEvents(events[i].substr(1), listener, capture);
                          } else {
                              this[j].removeEventListener(events[i], listener, capture);
                          }
                      } else {
                          // Live event
                          if (this[j].DomLiveListeners) {
                              for (k = 0; k < this[j].DomLiveListeners.length; k++) {
                                  if (this[j].DomLiveListeners[k].listener === listener) {
                                      this[j].removeEventListener(events[i], this[j].DomLiveListeners[k].liveListener, capture);
                                  }
                              }
                          }
                          if (this[j].DomNameSpaces && this[j].DomNameSpaces.length && events[i]) {
                              removeEvents(events[i]);
                          }
                      }
                  }
              }

              return this;
          },
          trigger: function trigger(eventName, eventData) {
              var events = eventName.split(' ');
              for (var i = 0; i < events.length; i++) {
                  for (var j = 0; j < this.length; j++) {
                      var evt;
                      try {
                          evt = new CustomEvent(events[i], {
                              detail: eventData,
                              bubbles: true,
                              cancelable: true
                          });
                      } catch (e) {
                          evt = document.createEvent('Event');
                          evt.initEvent(events[i], true, true);
                          evt.detail = eventData;
                      }
                      this[j].dispatchEvent(evt);
                  }
              }
              return this;
          },
          // Sizing/Styles
          width: function width(dim) {
              if (dim !== undefined) {
                  return this.css('width', dim);
              }

              if (this[0] === window) {
                  return window.innerWidth;
              } else if (this[0] === document) {
                  return document.documentElement.scrollWidth;
              } else {
                  return this.length > 0 ? parseFloat(this.css('width')) : null;
              }
          },
          height: function height(dim) {
              if (dim !== undefined) {
                  return this.css('height', dim);
              }

              if (this[0] === window) {
                  return window.innerHeight;
              } else if (this[0] === document) {
                  var body = document.body,
                      html = document.documentElement;

                  return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
              } else {
                  return this.length > 0 ? parseFloat(this.css('height')) : null;
              }
          },
          innerWidth: function innerWidth() {
              var elm = this;
              if (this.length > 0) {
                  if (this[0].innerWidth) {
                      return this[0].innerWidth;
                  } else {
                      var size = this[0].offsetWidth,
                          sides = ['left', 'right'];

                      sides.forEach(function (side) {
                          size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
                      });
                      return size;
                  }
              }
          },
          innerHeight: function innerHeight() {
              var elm = this;
              if (this.length > 0) {
                  if (this[0].innerHeight) {
                      return this[0].innerHeight;
                  } else {
                      var size = this[0].offsetHeight,
                          sides = ['top', 'bottom'];

                      sides.forEach(function (side) {
                          size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
                      });

                      return size;
                  }
              }
          },
          offset: function offset() {
              if (this.length > 0) {
                  var el = this[0],
                      box = el.getBoundingClientRect(),
                      doc = document.documentElement;

                  return {
                      top: box.top + window.pageYOffset - doc.clientTop,
                      left: box.left + window.pageXOffset - doc.clientLeft
                  };
              }
          },
          hide: function hide() {
              for (var i = 0; i < this.length; i++) {
                  this[i].style.display = 'none';
              }
              return this;
          },
          show: function show() {
              for (var i = 0; i < this.length; i++) {
                  if (this[i].style.display == "none") {
                      this[i].style.display = '';
                  }

                  if (getComputedStyle(this[i], '').getPropertyValue("display") == "none") {
                      this[i].style.display = 'block';
                  }
              }

              return this;
          },
          clone: function clone() {
              return this.map(function () {
                  return this.cloneNode(true);
              });
          },
          styles: function styles() {
              return this[0] ? window.getComputedStyle(this[0], null) : undefined;
          },
          css: function css(property, value) {
              var i,
                  key,
                  element = this[0],
                  css = '';

              if (arguments.length < 2) {
                  if (!element) {
                      return;
                  }
                  if (typeof property === 'string') {
                      return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);
                  }
              }

              if (typeof property === 'string') {
                  if (!value && value !== 0) {
                      this.each(function () {
                          this.style.removeProperty(dasherize(property));
                      });
                  } else {
                      css = dasherize(property) + ":" + maybeAddPx(property, value);
                  }
              } else {
                  for (key in property) {
                      if (!property[key] && property[key] !== 0) {
                          for (i = 0; i < this.length; i++) {
                              this[i].style.removeProperty(dasherize(key));
                          }
                      } else {
                          css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
                      }
                  }
              }

              return this.each(function () {
                  this.style.cssText += ';' + css;
              });
          },
          each: function each(callback) {
              for (var i = 0; i < this.length; i++) {
                  if (callback.apply(this[i], [i, this[i]]) === false) {
                      break;
                  }
              }
              return this;
          },
          filter: function filter(callback) {
              var matchedItems = [];

              for (var i = 0; i < this.length; i++) {
                  if (isFunction(callback)) {
                      if (callback.call(this[i], i, this[i])) {
                          matchedItems.push(this[i]);
                      }
                  } else if ($.matches(this[i], callback)) {
                      matchedItems.push(this[i]);
                  }
              }

              return new Dom(matchedItems);
          },
          html: function html(_html) {
              if (typeof _html === 'undefined') {
                  return this[0] ? this[0].innerHTML : undefined;
              } else {
                  this.empty();
                  for (var i = 0; i < this.length; i++) {
                      this[i].innerHTML = _html;
                  }
                  return this;
              }
          },
          text: function text(_text) {
              if (typeof _text === 'undefined') {
                  return this[0] ? this[0].textContent.trim() : null;
              } else {
                  for (var i = 0; i < this.length; i++) {
                      this[i].textContent = _text;
                  }
                  return this;
              }
          },
          is: function is(selector) {
              return this.length > 0 && $.matches(this[0], selector);
          },
          not: function not(selector) {
              var nodes = [];
              if (isFunction(selector) && selector.call !== undefined) {
                  this.each(function (idx) {
                      if (!selector.call(this, idx)) {
                          nodes.push(this);
                      }
                  });
              } else {
                  var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);

                  if (isObject(excludes)) {
                      excludes = $.map(excludes, function (el) {
                          return el;
                      });
                  }

                  this.each(function (i, el) {
                      if (excludes.indexOf(el) < 0) {
                          nodes.push(el);
                      }
                  });
              }

              return $(nodes);
          },
          indexOf: function indexOf(el) {
              for (var i = 0; i < this.length; i++) {
                  if (this[i] === el) {
                      return i;
                  }
              }
          },
          index: function index(element) {
              return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
          },
          get: function get$$1(idx) {
              return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
          },
          eq: function eq(index) {
              if (typeof index === 'undefined') {
                  return this;
              }
              var length = this.length,
                  returnIndex;

              if (index > length - 1) {
                  return new Dom([]);
              }
              if (index < 0) {
                  returnIndex = length + index;
                  return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);
              }
              return new Dom([this[index]]);
          },
          append: function append(newChild) {
              var i, j;
              for (i = 0; i < this.length; i++) {
                  if (typeof newChild === 'string') {
                      var tempDiv = document.createElement('div');
                      tempDiv.innerHTML = newChild;
                      while (tempDiv.firstChild) {
                          this[i].appendChild(tempDiv.firstChild);
                      }
                  } else if (newChild instanceof Dom) {
                      for (j = 0; j < newChild.length; j++) {
                          this[i].appendChild(newChild[j]);
                      }
                  } else {
                      this[i].appendChild(newChild);
                  }
              }
              return this;
          },
          appendTo: function appendTo(parent) {
              $(parent).append(this);
              return this;
          },
          prepend: function prepend(newChild) {
              var i, j;
              for (i = 0; i < this.length; i++) {
                  if (typeof newChild === 'string') {
                      var tempDiv = document.createElement('div');
                      tempDiv.innerHTML = newChild;
                      for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
                          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                      }
                      // this[i].insertAdjacentHTML('afterbegin', newChild);
                  } else if (newChild instanceof Dom) {
                      for (j = 0; j < newChild.length; j++) {
                          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                      }
                  } else {
                      this[i].insertBefore(newChild, this[i].childNodes[0]);
                  }
              }
              return this;
          },
          prependTo: function prependTo(parent) {
              $(parent).prepend(this);
              return this;
          },
          insertBefore: function insertBefore(selector) {
              var before = $(selector);

              for (var i = 0; i < this.length; i++) {
                  if (before.length === 1) {
                      before[0].parentNode.insertBefore(this[i], before[0]);
                  } else if (before.length > 1) {
                      for (var j = 0; j < before.length; j++) {
                          before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
                      }
                  }
              }
              return this;
          },
          insertAfter: function insertAfter(selector) {
              var after = $(selector);
              for (var i = 0; i < this.length; i++) {
                  if (after.length === 1) {
                      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
                  } else if (after.length > 1) {
                      for (var j = 0; j < after.length; j++) {
                          after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
                      }
                  }
              }

              return this;
          },
          next: function next(selector) {
              if (this.length > 0) {
                  if (selector) {
                      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                          return new Dom([this[0].nextElementSibling]);
                      } else {
                          return new Dom([]);
                      }
                  } else {
                      if (this[0].nextElementSibling) {
                          return new Dom([this[0].nextElementSibling]);
                      } else {
                          return new Dom([]);
                      }
                  }
              } else {
                  return new Dom([]);
              }
          },
          nextAll: function nextAll(selector) {
              var nextEls = [],
                  el = this[0];

              if (!el) {
                  return new Dom([]);
              }
              while (el.nextElementSibling) {
                  var next = el.nextElementSibling;
                  if (selector) {
                      if ($(next).is(selector)) {
                          nextEls.push(next);
                      }
                  } else {
                      nextEls.push(next);
                  }
                  el = next;
              }
              return new Dom(nextEls);
          },
          prev: function prev(selector) {
              if (this.length > 0) {
                  if (selector) {
                      if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {
                          return new Dom([this[0].previousElementSibling]);
                      } else {
                          return new Dom([]);
                      }
                  } else {
                      if (this[0].previousElementSibling) {
                          return new Dom([this[0].previousElementSibling]);
                      } else {
                          return new Dom([]);
                      }
                  }
              } else {
                  return new Dom([]);
              }
          },
          prevAll: function prevAll(selector) {
              var prevEls = [];
              var el = this[0];
              if (!el) {
                  return new Dom([]);
              }
              while (el.previousElementSibling) {
                  var prev = el.previousElementSibling;
                  if (selector) {
                      if ($(prev).is(selector)) {
                          prevEls.push(prev);
                      }
                  } else {
                      prevEls.push(prev);
                  }
                  el = prev;
              }
              return new Dom(prevEls);
          },
          parent: function parent(selector) {
              var parents = [];
              for (var i = 0; i < this.length; i++) {
                  if (this[i].parentNode !== null) {
                      if (selector) {
                          if ($(this[i].parentNode).is(selector)) {
                              parents.push(this[i].parentNode);
                          }
                      } else {
                          parents.push(this[i].parentNode);
                      }
                  }
              }
              return $($.unique(parents));
          },
          parents: function parents(selector) {
              var parents = [];
              for (var i = 0; i < this.length; i++) {
                  var parent = this[i].parentNode;
                  while (parent) {
                      if (selector) {
                          if ($(parent).is(selector)) {
                              parents.push(parent);
                          }
                      } else {
                          parents.push(parent);
                      }
                      parent = parent.parentNode;
                  }
              }
              return $($.unique(parents));
          },
          find: function find(selector) {
              var foundElements = [];
              for (var i = 0; i < this.length; i++) {
                  var found = this[i].querySelectorAll(selector);
                  for (var j = 0; j < found.length; j++) {
                      foundElements.push(found[j]);
                  }
              }
              return new Dom(foundElements);
          },
          children: function children(selector) {
              var children = [];
              for (var i = 0; i < this.length; i++) {
                  var childNodes = this[i].childNodes;

                  for (var j = 0; j < childNodes.length; j++) {
                      if (!selector) {
                          if (childNodes[j].nodeType === 1) {
                              children.push(childNodes[j]);
                          }
                      } else {
                          if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
                              children.push(childNodes[j]);
                          }
                      }
                  }
              }

              return new Dom($.unique(children));
          },
          remove: function remove() {
              for (var i = 0; i < this.length; i++) {
                  if (this[i].parentNode) {
                      this[i].parentNode.removeChild(this[i]);
                  }
              }
              return this;
          },
          add: function add() {
              var dom = this;
              var i, j;
              for (i = 0; i < arguments.length; i++) {
                  var toAdd = $(arguments[i]);
                  for (j = 0; j < toAdd.length; j++) {
                      dom[dom.length] = toAdd[j];
                      dom.length++;
                  }
              }
              return dom;
          },
          before: function before(elm) {
              $(elm).insertBefore(this);
              return this;
          },
          after: function after(elm) {
              $(elm).insertAfter(this);
              return this;
          },
          scrollTop: function scrollTop(value) {
              if (!this.length) {
                  return;
              }
              var hasScrollTop = 'scrollTop' in this[0];

              if (value === undefined) {
                  return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
              }
              return this.each(hasScrollTop ? function () {
                  this.scrollTop = value;
              } : function () {
                  this.scrollTo(this.scrollX, value);
              });
          },
          scrollLeft: function scrollLeft(value) {
              if (!this.length) {
                  return;
              }
              var hasScrollLeft = 'scrollLeft' in this[0];

              if (value === undefined) {
                  return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
              }
              return this.each(hasScrollLeft ? function () {
                  this.scrollLeft = value;
              } : function () {
                  this.scrollTo(value, this.scrollY);
              });
          },
          contents: function contents() {
              return this.map(function (i, v) {
                  return _slice.call(v.childNodes);
              });
          },
          nextUntil: function nextUntil(selector) {
              var n = this,
                  array = [];

              while (n.length && !n.filter(selector).length) {
                  array.push(n[0]);
                  n = n.next();
              }

              return $(array);
          },
          prevUntil: function prevUntil(selector) {
              var n = this,
                  array = [];

              while (n.length && !$(n).filter(selector).length) {
                  array.push(n[0]);
                  n = n.prev();
              }

              return $(array);
          },
          detach: function detach() {
              return this.remove();
          }
      };

      // Link to prototype
      $.fn = Dom.prototype;

      return $;
  }();

  // Export to local scope
  var $$1 = Dom;

  // Export to mobiscroll
  mobiscroll$3.$ = Dom;

  // DOM Library Utilites
  $$1.inArray = function (elem, array, i) {
      return emptyArray.indexOf.call(array, elem, i);
  };

  $$1.extend = function (target) {
      var deep,
          args = _slice.call(arguments, 1);

      if (typeof target == 'boolean') {
          deep = target;
          target = args.shift();
      }

      target = target || {};

      args.forEach(function (arg) {
          extend(target, arg, deep);
      });

      return target;
  };

  $$1.isFunction = isFunction;

  $$1.isArray = function (arr) {
      return Object.prototype.toString.apply(arr) === '[object Array]';
  };

  $$1.isPlainObject = function (obj) {
      return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;
  };

  $$1.each = function (obj, callback) {
      var i, prop;

      if (!isObject(obj) || !callback) {
          return;
      }

      if ($$1.isArray(obj) || obj instanceof Dom) {
          // Array
          for (i = 0; i < obj.length; i++) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
              }
          }
      } else {
          // Object
          for (prop in obj) {
              if (obj.hasOwnProperty(prop) && prop !== 'length') {
                  if (callback.call(obj[prop], prop, obj[prop]) === false) {
                      break;
                  }
              }
          }
      }

      return this;
  };

  $$1.unique = function (arr) {
      var unique = [];
      for (var i = 0; i < arr.length; i++) {
          if (unique.indexOf(arr[i]) === -1) {
              unique.push(arr[i]);
          }
      }
      return unique;
  };

  $$1.map = function (elements, callback) {
      var value,
          values = [],
          i,
          key;
      if (likeArray(elements)) {
          for (i = 0; i < elements.length; i++) {
              value = callback(elements[i], i);
              if (value !== null) {
                  values.push(value);
              }
          }
      } else {
          for (key in elements) {
              value = callback(elements[key], key);
              if (value !== null) {
                  values.push(value);
              }
          }
      }

      return values.length > 0 ? $$1.fn.concat.apply([], values) : values;
  };

  $$1.matches = function (element, selector) {
      if (!selector || !element || element.nodeType !== 1) {
          return false;
      }

      var matchesSelector = element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;

      return matchesSelector.call(element, selector);
  };

  var os;
  var vers;
  var majorVersion;
  var minorVersion;
  var version = [];
  var isBrowser = typeof window !== 'undefined';
  var userAgent = isBrowser ? navigator.userAgent : '';
  var device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i);
  var raf = isBrowser && window.requestAnimationFrame || function (func) {
      func();
  };
  var rafc = isBrowser && window.cancelAnimationFrame || function () {};

  if (/Android/i.test(device)) {
      os = 'android';
      vers = userAgent.match(/Android\s+([\d\.]+)/i);
      if (vers) {
          version = vers[0].replace('Android ', '').split('.');
      }
  } else if (/iPhone|iPad|iPod/i.test(device)) {
      os = 'ios';
      vers = userAgent.match(/OS\s+([\d\_]+)/i);
      if (vers) {
          version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');
      }
  } else if (/Windows Phone/i.test(device)) {
      os = 'wp';
  } else if (/Windows|MSIE/i.test(device)) {
      os = 'windows';
  }

  majorVersion = version[0];
  minorVersion = version[1];

  function noop() {}

  function objectToArray(obj) {
      var arr = [],
          i;

      for (i in obj) {
          arr.push(obj[i]);
      }

      return arr;
  }

  function isNumeric(a) {
      return a - parseFloat(a) >= 0;
  }

  function isString(s) {
      return typeof s === 'string';
  }

  function constrain(val, min, max) {
      return Math.max(min, Math.min(val, max));
  }

  function vibrate(time) {
      if ('vibrate' in navigator) {
          navigator.vibrate(time || 50);
      }
  }

  function getPercent(v, min, max) {
      return (v - min) * 100 / (max - min);
  }

  function getBoolAttr(attr, def, $elm) {
      var v = $elm.attr(attr);
      return v === undefined || v === '' ? def : v === 'true';
  }

  var tapped = 0;

  function preventClick() {
      // Prevent ghost click
      tapped++;
      setTimeout(function () {
          tapped--;
      }, 500);
  }

  function triggerClick(ev, control) {
      var touch = (ev.originalEvent || ev).changedTouches[0],
          evt = document.createEvent('MouseEvents');

      evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
      evt.tap = true;

      control.mbscChange = true;
      control.dispatchEvent(evt);

      // Prevent ghost click
      preventClick();
  }

  function getCoord(e, c, page) {
      var ev = e.originalEvent || e,
          prop = (page ? 'page' : 'client') + c;

      // Multi touch support
      if (ev.targetTouches && ev.targetTouches[0]) {
          return ev.targetTouches[0][prop];
      }

      if (ev.changedTouches && ev.changedTouches[0]) {
          return ev.changedTouches[0][prop];
      }

      return e[prop];
  }

  function tap(that, el, handler, prevent, tolerance, time) {
      var startX,
          startY,
          target,
          moved,
          startTime,
          $ = mobiscroll$3.$,
          $elm = $(el);

      tolerance = tolerance || 9;

      function onStart(ev) {
          if (!target) {
              // Can't always call preventDefault here, it kills page scroll
              if (prevent) {
                  ev.preventDefault();
              }
              target = this;
              startX = getCoord(ev, 'X');
              startY = getCoord(ev, 'Y');
              moved = false;
              startTime = new Date();
          }
      }

      function onMove(ev) {
          // If movement is more than 20px, don't fire the click event handler
          if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {
              moved = true;
          }
      }

      function onEnd(ev) {
          if (target) {
              if (time && new Date() - startTime < 100 || !moved) {
                  ev.preventDefault();
                  handler.call(target, ev, that);
              }

              target = false;

              preventClick();
          }
      }

      function onCancel() {
          target = false;
      }

      if (that.settings.tap) {
          $elm.on('touchstart.mbsc', onStart).on('touchcancel.mbsc', onCancel).on('touchmove.mbsc', onMove).on('touchend.mbsc', onEnd);
      }

      $elm.on('click.mbsc', function (ev) {
          if (prevent) {
              ev.preventDefault();
          }
          // If handler was not called on touchend, call it on click;
          handler.call(this, ev, that);
      });
  }

  // Prevent standard behaviour on body click
  function bustClick(ev) {
      // Textarea needs the mousedown event
      if (tapped && !ev.tap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {
          ev.stopPropagation();
          ev.preventDefault();
          return false;
      }
  }

  if (isBrowser) {
      ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {
          document.addEventListener(ev, bustClick, true);
      });

      if (os == 'android' && majorVersion < 5) {
          document.addEventListener('change', function (ev) {
              if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {
                  ev.stopPropagation();
                  ev.preventDefault();
              }
              delete ev.target.mbscChange;
          }, true);
      }
  }

  /*!
   * Mobiscroll v4.0.0
   * http://mobiscroll.com
   *
   * Copyright 2010-2018, Acid Media
   *
   */

  function autoInit(selector, Component, hasRefresh) {
      if (isBrowser) {
          $$2(function () {

              $$2(selector).each(function () {
                  new Component(this);
              });

              $$2(document).on('mbsc-enhance', function (ev, settings) {
                  if ($$2(ev.target).is(selector)) {
                      new Component(ev.target, settings);
                  } else {
                      $$2(selector, ev.target).each(function () {
                          new Component(this, settings);
                      });
                  }
              });

              if (hasRefresh) {
                  $$2(document).on('mbsc-refresh', function (ev) {
                      var inst;

                      if ($$2(ev.target).is(selector)) {
                          inst = instances[ev.target.id];
                          if (inst) {
                              inst.refresh();
                          }
                      } else {
                          $$2(selector, ev.target).each(function () {
                              inst = instances[this.id];
                              if (inst) {
                                  inst.refresh();
                              }
                          });
                      }
                  });
              }
          });
      }
  }

  var ms;
  var $$2 = mobiscroll$3.$;
  var id = +new Date();
  var instances = {};
  var classes = {};
  var util = {
      getCoord: getCoord,
      preventClick: preventClick,
      vibrate: vibrate
  };
  var extend$1 = $$2.extend;

  ms = extend$1(mobiscroll$3, {
      $: $$2,
      version: '4.0.0',
      autoTheme: 'mobiscroll',
      themes: {
          form: {},
          page: {},
          frame: {},
          scroller: {},
          listview: {},
          navigation: {},
          progress: {},
          card: {}
      },
      platform: {
          name: os,
          majorVersion: majorVersion,
          minorVersion: minorVersion
      },
      i18n: {},
      instances: instances,
      classes: classes,
      util: util,
      settings: {},
      setDefaults: function setDefaults(o) {
          extend$1(this.settings, o);
      },
      customTheme: function customTheme(name, baseTheme) {
          var i,
              themes = mobiscroll$3.themes,
              comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];

          for (i = 0; i < comps.length; i++) {
              themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {
                  baseTheme: baseTheme
              });
          }
      }
  });

  var Base = function Base(el, settings) {
      var lang,
          preset,
          s,
          theme,
          themeName,
          trigger,
          defaults$$1,
          that = this;

      that.settings = {};

      that._init = noop;

      that._destroy = noop;

      that._processSettings = noop;

      that.init = function (ss) {
          var key;

          // Reset settings object
          for (key in that.settings) {
              delete that.settings[key];
          }

          s = that.settings;

          // Update original user settings
          extend$1(settings, ss);

          // Load user defaults
          if (that._hasDef) {
              defaults$$1 = ms.settings;
          }

          // Create settings object
          extend$1(s, that._defaults, defaults$$1, settings);

          // Get theme defaults
          if (that._hasTheme) {

              themeName = s.theme;

              if (themeName == 'auto' || !themeName) {
                  themeName = ms.autoTheme;
              }

              if (themeName == 'default') {
                  themeName = 'mobiscroll';
              }

              settings.theme = themeName;

              theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};
          }

          // Get language defaults
          if (that._hasLang) {
              lang = ms.i18n[s.lang];
          }

          // Update settings object
          extend$1(s, theme, lang, defaults$$1, settings);

          that._processSettings();

          // Load preset settings
          if (that._presets) {

              preset = that._presets[s.preset];

              if (preset) {
                  preset = preset.call(el, that);
                  extend$1(s, preset, settings);
              }
          }

          that._init(ss);

          trigger('onInit');
      };

      that.destroy = function () {
          if (that) {
              that._destroy();
              trigger('onDestroy');

              // Delete scroller instance
              delete instances[el.id];

              that = null;
          }
      };

      /**
       * Attach tap event to the given element.
       */
      that.tap = function (el, handler, prevent, tolerance, time) {
          tap(that, el, handler, prevent, tolerance, time);
      };

      /**
       * Triggers an event
       */
      that.trigger = function (name, ev) {
          var ret,
              i,
              v,
              s = [defaults$$1, theme, preset, settings];

          for (i = 0; i < 4; i++) {
              v = s[i];
              if (v && v[name]) {
                  ret = v[name].call(el, ev || {}, that);
              }
          }

          return ret;
      };

      /**
       * Sets one ore more options.
       */
      that.option = function (opt, value) {
          var obj = {},

          // preserve settings that are possible to change runtime
          dynamic = ['data', 'invalid', 'valid', 'marked', 'labels', 'colors', 'readonly'];

          if ((typeof opt === 'undefined' ? 'undefined' : _typeof(opt)) === 'object') {
              obj = opt;
          } else {
              obj[opt] = value;
          }

          dynamic.forEach(function (v) {
              settings[v] = s[v];
          });

          that.init(obj);
      };

      /**
       * Returns the mobiscroll instance.
       */
      that.getInst = function () {
          return that;
      };

      settings = settings || {};
      trigger = that.trigger;

      function construct() {
          $$2(el).addClass('mbsc-comp');

          // Autogenerate id
          if (!el.id) {
              el.id = 'mobiscroll' + ++id;
          } else if (instances[el.id]) {
              instances[el.id].destroy();
          }

          // Save instance
          instances[el.id] = that;
          that.__ready = true;
      }

      if (!that.__ready) {
          construct();
      }
  };

  var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
              }
          }
      }return target;
  };

  var _class;
  var _temp;
  var _initialiseProps;
  var _class4;
  var _temp3;
  var _class5;
  var _temp5;

  function _objectWithoutProperties(obj, keys) {
      var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
      }return target;
  }

  var boolType = PropTypes.bool;
  var stringType = PropTypes.string;
  var funcType = PropTypes.func;
  var numType = PropTypes.number;
  var objType = PropTypes.object;
  var numOrArray = PropTypes.oneOfType([numType, PropTypes.arrayOf(numType)]);

  /** Mixin for enumerating the core PropTypes */
  var CorePropTypes = {
      theme: stringType,
      lang: stringType,
      rtl: boolType,
      context: PropTypes.oneOfType([stringType, objType])
  };

  var FramePropTypes = {
      anchor: PropTypes.oneOfType([stringType, objType]),
      animate: PropTypes.oneOfType([boolType, PropTypes.oneOf(['fade', 'flip', 'pop', 'swing', 'slidevertical', 'slidehorizontal', 'slidedown', 'slideup'])]),
      buttons: PropTypes.array,
      closeOnOverlayTap: boolType,
      cssClass: stringType,
      disabled: boolType,
      display: PropTypes.oneOf(['top', 'bottom', 'bubble', 'inline', 'center']),
      focusOnClose: PropTypes.oneOfType([boolType, stringType, objType]),
      focusTrap: boolType,
      headerText: PropTypes.oneOfType([boolType, stringType, funcType]),
      showOnFocus: boolType,
      showOnTap: boolType,
      onBeforeClose: funcType,
      onBeforeShow: funcType,
      onCancel: funcType,
      onClose: funcType,
      onDestroy: funcType,
      onMarkupReady: funcType,
      onPosition: funcType,
      onShow: funcType
  };

  var ScrollerPropTypes = {
      circular: PropTypes.oneOfType([boolType, PropTypes.arrayOf(boolType)]),
      height: numType,
      layout: PropTypes.oneOf(['liquid', 'fixed']),
      maxWidth: numOrArray,
      minWidth: numOrArray,
      multiline: numType,
      readOnly: PropTypes.oneOfType([boolType, PropTypes.arrayOf(boolType)]),
      rows: numType,
      showLabel: boolType,
      showScrollArrows: boolType,
      wheels: PropTypes.array,
      width: numType,
      onChange: funcType,
      validate: funcType,
      onSet: funcType,
      onItemTap: funcType,
      onClear: funcType,
      cancelText: stringType,
      clearText: stringType,
      selectedText: stringType,
      setText: stringType,
      formatValue: funcType,
      parseValue: funcType
  };

  var DatetimePropTypes = {
      defaultValue: objType,
      invalid: PropTypes.array,
      max: objType,
      min: objType,
      steps: PropTypes.shape({
          hour: numType,
          minute: numType,
          second: numType,
          zeroBased: boolType
      }),
      valid: PropTypes.array,
      ampmText: stringType,
      amText: stringType,
      dateFormat: stringType,
      dateWheels: stringType,
      dayNames: PropTypes.arrayOf(stringType),
      dayNamesShort: PropTypes.arrayOf(stringType),
      dayText: stringType,
      hourText: stringType,
      minuteText: stringType,
      monthNames: PropTypes.arrayOf(stringType),
      monthNamesShort: PropTypes.arrayOf(stringType),
      monthSuffix: stringType,
      monthText: stringType,
      nowText: stringType,
      pmText: stringType,
      secText: stringType,
      timeFormat: stringType,
      timeWheels: stringType,
      yearSuffix: stringType,
      yearText: stringType
  };

  var CalbasePropTypes = {
      calendarHeight: numType,
      calendarScroll: PropTypes.oneOf(['horizontal', 'vertical']),
      calendarWidth: numType,
      counter: boolType,
      defaultValue: PropTypes.oneOfType([objType, PropTypes.array]),
      events: PropTypes.arrayOf(PropTypes.shape({
          start: objType,
          end: objType,
          d: PropTypes.oneOfType([objType, numType, stringType]),
          text: stringType,
          color: stringType,
          background: stringType,
          cssClass: stringType
      })),
      labels: PropTypes.arrayOf(PropTypes.shape({
          start: objType,
          end: objType,
          d: PropTypes.oneOfType([objType, numType, stringType]),
          text: stringType,
          color: stringType,
          background: stringType,
          cssClass: stringType
      })),
      marked: PropTypes.arrayOf(PropTypes.oneOfType([objType, stringType, PropTypes.shape({
          d: PropTypes.oneOfType([objType, stringType, numType]),
          color: stringType,
          background: stringType,
          cssClass: stringType
      })])),
      colors: PropTypes.arrayOf(PropTypes.shape({
          d: PropTypes.oneOfType([objType, stringType, numType]),
          background: stringType,
          cssClass: stringType
      })),
      months: numType,
      weeks: numType,
      outerMonthChange: boolType,
      showOuterDays: boolType,
      tabs: boolType,
      weekCounter: PropTypes.oneOf(['year', 'month']),
      weekDays: PropTypes.oneOf(['full', 'short', 'min']),
      yearChange: boolType,
      dateText: stringType,
      dayNames: PropTypes.arrayOf(stringType),
      dayNamesMin: PropTypes.arrayOf(stringType),
      firstDay: numType,
      timeText: stringType,
      onTabChange: funcType,
      onDayChange: funcType,
      onMonthChange: funcType,
      onMonthLoading: funcType,
      onMonthLoaded: funcType,
      onPageChange: funcType,
      onPageLoading: funcType,
      onPageLoaded: funcType
  };

  function updateCssClasses(currentClasses, nextClasses) {
      var node = ReactDOM.findDOMNode(this);
      var currentNormal = currentClasses.replace(/\s+/g, ' ').trim();
      var nextNormal = nextClasses.replace(/\s+/g, ' ').trim();
      if (currentNormal) {
          node.classList.remove.apply(node.classList, currentNormal.split(' '));
      }
      if (nextNormal) {
          node.classList.add.apply(node.classList, nextNormal.split(' '));
      }
  }

  function deepCompare(a, b) {
      var leftChain = [],
          rightChain = [];

      function compare2Objects(x, y) {
          var p;

          // remember that NaN === NaN returns false
          // and isNaN(undefined) returns true
          if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {
              return true;
          }

          // Compare primitives and functions.     
          // Check if both arguments link to the same object.
          // Especially useful on step when comparing prototypes
          if (x === y) {
              return true;
          }

          // Works in case when functions are created in constructor.
          // Comparing dates is a common scenario. Another built-ins?
          // We can even handle functions passed across iframes
          if (typeof x === 'function' && typeof y === 'function' || x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || x instanceof String && y instanceof String || x instanceof Number && y instanceof Number) {
              return x.toString() === y.toString();
          }

          // At last checking prototypes as good a we can
          if (!(x instanceof Object && y instanceof Object)) {
              return false;
          }

          if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {
              return false;
          }

          if (x.constructor !== y.constructor) {
              return false;
          }

          if (x.prototype !== y.prototype) {
              return false;
          }

          // Check for infinitive linking loops
          if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {
              return false;
          }

          // Quick checking of one object beeing a subset of another.
          // todo: cache the structure of arguments[0] for performance
          for (p in y) {
              if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                  return false;
              } else if (_typeof(y[p]) !== _typeof(x[p])) {
                  return false;
              }
          }

          for (p in x) {
              if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                  return false;
              } else if (_typeof(y[p]) !== _typeof(x[p])) {
                  return false;
              }

              switch (_typeof(x[p])) {
                  case 'object':
                  case 'function':

                      leftChain.push(x);
                      rightChain.push(y);

                      if (!compare2Objects(x[p], y[p])) {
                          return false;
                      }

                      leftChain.pop();
                      rightChain.pop();
                      break;

                  default:
                      if (x[p] !== y[p]) {
                          return false;
                      }
                      break;
              }
          }
          return true;
      }

      return compare2Objects(a, b);
  }

  var MbscInit = (_temp = _class = function (_React$Component) {
      inherits(MbscInit, _React$Component);

      function MbscInit(props) {
          classCallCheck(this, MbscInit);

          // the initial css class will not change this way, and wont trigger any re-render. We will handle the className changes in the componentWillReceive function
          // Note: every render function should use the this.initialCssClass instead of passing through the className prop 

          var _this = possibleConstructorReturn(this, (MbscInit.__proto__ || Object.getPrototypeOf(MbscInit)).call(this, props));

          _initialiseProps.call(_this);

          _this.initialCssClass = _this.props.className || '';

          // set Initial State
          var options = _this.getSettingsFromProps(props);
          _this.state = {
              options: options,
              value: props.value,
              data: props.data,
              cssClasses: props.className
          };
          return _this;
      }

      // Dummy render function


      // updates the state when new props are received


      // generates the mobiscroll options object based on the props passed


      // cleans up on unmount


      return MbscInit;
  }(React.Component), _initialiseProps = function _initialiseProps() {
      var _this2 = this;

      this.render = function () {
          return null;
      };

      this.componentWillReceiveProps = function (nextProps) {
          var options = _this2.getSettingsFromProps(nextProps);

          if (_this2.state.cssClasses !== nextProps.className) {
              updateCssClasses.call(_this2, _this2.state.cssClasses, nextProps.className);
          }

          _this2.setState({
              options: options,
              value: nextProps.value,
              data: nextProps.data,
              cssClasses: nextProps.className
          });
      };

      this.getSettingsFromProps = function (props) {
          var optionObj = {};
          if (props !== undefined) {
              // support individual properties and options object property for settings
              // the value should not be part of the options object
              // data should not be part of the options object 

              /* eslint-disable no-unused-vars */
              // justification: the variables 'value', 'data', 'children' and 'className' are declared due to object decomposition
              var options = props.options,
                  children = props.children,
                  value = props.value,
                  data = props.data,
                  className = props.className,
                  other = _objectWithoutProperties(props, ['options', 'children', 'value', 'data', 'className']);

              /* eslint-enable no-unused-vars */

              var optionStr = options || '{}';
              optionObj = options || {};
              if (options !== undefined && typeof optionStr === 'string') {
                  // when options are passed as string we need to create an object from it
                  optionObj = new Function('return ' + optionStr + ';')();
              }

              // the priority of the options passed (later will have higher prio): 
              // 1. options property
              // 2. individual properties
              optionObj = extend$1({}, optionObj, other);
          }
          return optionObj;
      };

      this.componentWillUnmount = function () {
          _this2.instance.destroy();
          // Also need to delete reference to the instance
          delete _this2.instance;
      };
  }, _temp);

  /** The base class for the mobiscroll components
   * Generates the Mobiscroll options object from the react component properties
   * Setting initial state 
   * Updating state based on new props 
   * Updating mobiscroll based on state */
  var MbscBase = function (_MbscInit) {
      inherits(MbscBase, _MbscInit);

      function MbscBase(props) {
          classCallCheck(this, MbscBase);

          var _this3 = possibleConstructorReturn(this, (MbscBase.__proto__ || Object.getPrototypeOf(MbscBase)).call(this, props));

          _this3.componentDidUpdate = function () {
              var settings = extend$1({}, _this3.state.options);
              if (_this3.optimizeUpdate) {
                  if (_this3.optimizeUpdate.updateOptions) {
                      _this3.instance.option(settings);
                  }
                  if (_this3.optimizeUpdate.updateValue && _this3.state.value !== undefined && !deepCompare(_this3.state.value, _this3.instance.getVal())) {
                      _this3.instance.setVal(_this3.state.value, true);
                  }
              } else {
                  _this3.instance.option(settings);
                  if (_this3.state.value !== undefined) {
                      _this3.instance.setVal(_this3.state.value, true);
                  }
              }
          };
          return _this3;
      }

      // updates mobiscroll with new options


      return MbscBase;
  }(MbscInit);

  var MbscOptimized = function (_MbscBase) {
      inherits(MbscOptimized, _MbscBase);

      function MbscOptimized(props) {
          classCallCheck(this, MbscOptimized);

          var _this4 = possibleConstructorReturn(this, (MbscOptimized.__proto__ || Object.getPrototypeOf(MbscOptimized)).call(this, props));

          _this4.shouldComponentUpdate = function (nextProps, nextState) {
              // check if the options or the value changed
              var updateOptions = !deepCompare(nextState.options, _this4.state.options),
                  updateValue = !deepCompare(nextState.value, _this4.state.value),
                  updateChildren = !deepCompare(nextProps.children, _this4.props.children);
              // save what should be updated inside mobiscroll
              _this4.optimizeUpdate = {
                  updateOptions: updateOptions,
                  updateValue: updateValue,
                  updateChildren: updateChildren
              };
              // component should update if the options or the value changed
              return updateOptions || updateValue || updateChildren;
          };
          return _this4;
      }

      return MbscOptimized;
  }(MbscBase);

  /** Class for the generic mobiscroll components */
  var MbscInputBase = (_temp3 = _class4 = function (_MbscOptimized) {
      inherits(MbscInputBase, _MbscOptimized);

      function MbscInputBase() {
          var _ref;

          var _this5, _ret;

          classCallCheck(this, MbscInputBase);

          var _temp2;

          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
          }

          return _ret = (_temp2 = (_this5 = possibleConstructorReturn(this, (_ref = MbscInputBase.__proto__ || Object.getPrototypeOf(MbscInputBase)).call.apply(_ref, [this].concat(args))), _this5), _this5.render = function () {
              // passing through some of the element properties to its children
              var _props = _this5.props,
                  type = _props.type,
                  readOnly = _props.readOnly,
                  disabled = _props.disabled,
                  placeholder = _props.placeholder;

              // default input type if there are no children components

              type = type || "text";
              // default to input if there are no childrens
              if (_this5.props.children) {
                  return _this5.props.children;
              } else {
                  return React.createElement('input', { className: _this5.initialCssClass, type: type, readOnly: readOnly, disabled: disabled, placeholder: placeholder });
              }
          }, _this5.componentDidMount = function () {
              // get settings from state
              var settings = extend$1({}, _this5.mbscInit, _this5.state.options);
              // initialize the mobiscroll
              _this5.instance = new classes[_this5.mbscInit.component || 'Scroller'](ReactDOM.findDOMNode(_this5), settings);
              if (_this5.props.value !== undefined) {
                  _this5.instance.setVal(_this5.props.value, true);
              }
          }, _temp2), possibleConstructorReturn(_this5, _ret);
      }

      return MbscInputBase;
  }(MbscOptimized), _class4.propTypes = _extends({}, CorePropTypes, FramePropTypes), _temp3);

  /** Class for the list based mobiscroll components */
  var MbscListsBase = (_temp5 = _class5 = function (_MbscOptimized2) {
      inherits(MbscListsBase, _MbscOptimized2);

      function MbscListsBase() {
          var _ref2;

          var _this6, _ret2;

          classCallCheck(this, MbscListsBase);

          var _temp4;

          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
          }

          return _ret2 = (_temp4 = (_this6 = possibleConstructorReturn(this, (_ref2 = MbscListsBase.__proto__ || Object.getPrototypeOf(MbscListsBase)).call.apply(_ref2, [this].concat(args))), _this6), _this6.render = function () {
              return React.createElement('ul', { className: _this6.initialCssClass + ' mbsc-cloak' }, _this6.props.children);
          }, _this6.componentDidMount = function () {
              // get settings from state
              var settings = extend$1({}, _this6.mbscInit, _this6.state.options);
              // get the DOM node
              var DOMNode = ReactDOM.findDOMNode(_this6);

              // initialize the mobiscroll
              _this6.instance = new classes[_this6.mbscInit.component || 'Scroller'](DOMNode, settings);

              if (_this6.props.value !== undefined) {
                  _this6.instance.setVal(_this6.props.value, true);
              }

              // Stop Propagation of click events to avoid the same data-reactid js error when inline mode
              // the _markup does not exist for components that are not derived from Mobiscroll Frame (listview, menustrip, forms)
              // we can use the original dom node for these non-frame components, because they dont clone the markup
              (_this6.instance._markup || $$2(DOMNode)).on('click', function (event) {
                  event.stopPropagation();
              });
          }, _this6.componentDidUpdate = function () {
              if (!_this6.optimizeUpdate.updateOptions && _this6.optimizeUpdate.updateChildren) {
                  _this6.instance.option(_this6.state.options); // the option needs to be called because of the children changes - the list components might need a refresh method
              }

              // Stop Propagation of click events to avoid the same data-reactid js error when inline mode
              // the _markup does not exist for components that are not derived from Mobiscroll Frame (listview, menustrip, forms)
              // we can use the original dom node for these non-frame components, because they dont clone the markup
              var DOMNode = ReactDOM.findDOMNode(_this6);
              (_this6.instance._markup || $$2(DOMNode)).on('click', function (event) {
                  event.stopPropagation();
              });
          }, _temp4), possibleConstructorReturn(_this6, _ret2);
      }

      return MbscListsBase;
  }(MbscOptimized), _class5.propTypes = _extends({}, CorePropTypes, FramePropTypes, ScrollerPropTypes), _temp5);

  function testProps(props) {
      var i;
      for (i in props) {
          if (mod[props[i]] !== undefined) {
              return true;
          }
      }
      return false;
  }

  function testPrefix() {
      var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
          p;

      for (p in prefixes) {
          if (testProps([prefixes[p] + 'Transform'])) {
              return '-' + prefixes[p].toLowerCase() + '-';
          }
      }
      return '';
  }

  function testTouch(e, elm) {
      if (e.type == 'touchstart') {
          $$2(elm).attr('data-touch', '1');
      } else if ($$2(elm).attr('data-touch')) {
          $$2(elm).removeAttr('data-touch');
          return false;
      }
      return true;
  }

  function getPosition(t, vertical) {
      var style = getComputedStyle(t[0]),
          matrix,
          px;

      $$2.each(['t', 'webkitT', 'MozT', 'OT', 'msT'], function (i, v) {
          if (style[v + 'ransform'] !== undefined) {
              matrix = style[v + 'ransform'];
              return false;
          }
      });
      matrix = matrix.split(')')[0].split(', ');
      px = vertical ? matrix[13] || matrix[5] : matrix[12] || matrix[4];

      return px;
  }

  var animEnd;
  var mod;
  var cssPrefix;
  var jsPrefix;

  if (isBrowser) {
      mod = document.createElement('modernizr').style;
      cssPrefix = testPrefix();
      jsPrefix = cssPrefix.replace(/^\-/, '').replace(/\-$/, '').replace('moz', 'Moz');
      animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';
  }

  var events = ['touchstart', 'touchmove', 'touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];
  var defaults$1 = {
      tap: true
  };

  var $active = void 0;

  function getControlType($elm) {
      var elm = $elm[0];
      var role = $elm.attr('data-role');

      var type = $elm.attr('type') || elm.nodeName.toLowerCase();

      if (/(switch|range|rating|segmented|stepper)/.test(role)) {
          type = role;
      }

      return type;
  }

  function getRipple(theme) {
      var ripple = mobiscroll$3.themes.form[theme];
      return ripple && ripple.addRipple ? ripple : null;
  }

  var FormControl = function () {
      function FormControl(elm, settings) {
          var _this = this;

          classCallCheck(this, FormControl);


          var s = extend$1({}, defaults$1, mobiscroll$3.settings, settings);
          var $elm = $$2(elm);
          var $p = $elm.parent();
          var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p;
          // Check for inline mobiscroll components
          var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;
          var type = getControlType($elm);

          if ($frame) {
              $frame.insertAfter($parent);
          }

          wrapLabel($parent, type);

          $elm.addClass('mbsc-control');

          // Attach events
          // Prevent 300ms click latency
          events.forEach(function (ev) {
              elm.addEventListener(ev, _this);
          });

          this.settings = s;

          this._type = type;
          this._elm = elm;
          this._$elm = $elm;
          this._$parent = $parent;
          this._$frame = $frame;
          this._ripple = getRipple(s.theme);

          elm.mbscInst = this;
      }

      createClass(FormControl, [{
          key: 'destroy',
          value: function destroy() {
              var _this2 = this;

              this._$elm.removeClass('mbsc-control');
              events.forEach(function (ev) {
                  _this2._elm.removeEventListener(ev, _this2);
              });
              delete this._elm.mbscInst;
          }
      }, {
          key: 'option',
          value: function option(s) {
              extend$1(this.settings, s);
              this._ripple = getRipple(this.settings.theme);
          }
      }, {
          key: 'handleEvent',
          value: function handleEvent(ev) {
              switch (ev.type) {
                  case 'touchstart':
                  case 'mousedown':
                      this._onStart(ev);
                      break;
                  case 'touchmove':
                  case 'mousemove':
                      this._onMove(ev);
                      break;
                  case 'touchend':
                  case 'touchcancel':
                  case 'mouseup':
                  case 'mouseleave':
                      this._onEnd(ev);
              }
          }
      }, {
          key: '_addRipple',
          value: function _addRipple(ev) {
              if (this._ripple && this._$rippleElm) {
                  this._ripple.addRipple(this._$rippleElm, ev);
              }
          }
      }, {
          key: '_removeRipple',
          value: function _removeRipple() {
              if (this._ripple && this._$rippleElm) {
                  this._ripple.removeRipple();
              }
          }
      }, {
          key: '_onStart',
          value: function _onStart(ev) {
              var elm = this._elm;

              if (testTouch(ev, elm)) {
                  this._startX = getCoord(ev, 'X');
                  this._startY = getCoord(ev, 'Y');

                  if ($active) {
                      $active.removeClass('mbsc-active');
                  }

                  if (!elm.disabled) {
                      this._isActive = true;
                      $active = this._$elm;
                      $active.addClass('mbsc-active');
                      this._addRipple(ev);
                  }
              }
          }
      }, {
          key: '_onMove',
          value: function _onMove(ev) {
              // If movement is more than 9px, don't fire the click event handler
              if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {
                  this._$elm.removeClass('mbsc-active');
                  this._removeRipple();
                  this._isActive = false;
              }
          }
      }, {
          key: '_onEnd',
          value: function _onEnd(ev) {
              var _this3 = this;

              var control = this._elm;
              var type = this._type;

              if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {
                  control.focus();

                  if (/(button|submit|checkbox|switch|radio)/.test(type)) {
                      ev.preventDefault();
                  }

                  if (!/select/.test(type)) {
                      triggerClick(ev, control);
                  }
              }

              if (this._isActive) {
                  setTimeout(function () {
                      _this3._$elm.removeClass('mbsc-active');
                      _this3._removeRipple();
                  }, 100);
              }

              this._isActive = false;

              $active = null;
          }
      }]);
      return FormControl;
  }();

  var Input = function (_FormControl) {
      inherits(Input, _FormControl);

      function Input(elm, settings) {
          classCallCheck(this, Input);

          var _this = possibleConstructorReturn(this, (Input.__proto__ || Object.getPrototypeOf(Input)).call(this, elm, settings));

          addIconToggle(_this, _this._$parent, _this._$elm);
          _this._$parent.addClass('mbsc-input');
          return _this;
      }

      createClass(Input, [{
          key: 'destroy',
          value: function destroy() {
              get(Input.prototype.__proto__ || Object.getPrototypeOf(Input.prototype), 'destroy', this).call(this);
              this._$parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();
          }
      }]);
      return Input;
  }(FormControl);

  var Button = function (_FormControl) {
      inherits(Button, _FormControl);

      function Button(elm, settings) {
          classCallCheck(this, Button);

          var _this = possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).call(this, elm, settings));

          var $elm = _this._$elm;
          var hasIcon = $elm.attr('data-icon');

          $elm.addClass('mbsc-btn').find('.mbsc-btn-ic').remove();

          if (hasIcon) {
              $elm.prepend('<span class="mbsc-btn-ic mbsc-ic mbsc-ic-' + hasIcon + '"></span>');
              if ($elm.text() === "") {
                  $elm.addClass('mbsc-btn-icon-only');
              }
          }

          _this._$rippleElm = $elm;
          return _this;
      }

      return Button;
  }(FormControl);

  var CheckBox = function (_FormControl) {
      inherits(CheckBox, _FormControl);

      function CheckBox(elm, settings) {
          classCallCheck(this, CheckBox);

          var _this = possibleConstructorReturn(this, (CheckBox.__proto__ || Object.getPrototypeOf(CheckBox)).call(this, elm, settings));

          _this._$parent.prepend(_this._$elm).addClass('mbsc-checkbox mbsc-control-w').find('.mbsc-checkbox-box').remove();

          _this._$elm.after('<span class="mbsc-checkbox-box"></span>');
          return _this;
      }

      return CheckBox;
  }(FormControl);

  var Radio = function (_FormControl) {
      inherits(Radio, _FormControl);

      function Radio(elm, settings) {
          classCallCheck(this, Radio);

          var _this = possibleConstructorReturn(this, (Radio.__proto__ || Object.getPrototypeOf(Radio)).call(this, elm, settings));

          _this._$parent.addClass('mbsc-radio mbsc-control-w').find('.mbsc-radio-box').remove();

          _this._$elm.after('<span class="mbsc-radio-box"><span></span></span>');
          return _this;
      }

      return Radio;
  }(FormControl);

  var Select = function (_Input) {
      inherits(Select, _Input);

      function Select(elm, settings) {
          classCallCheck(this, Select);

          var _this = possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, elm, settings));

          var $elm = _this._$elm;
          var $parent = _this._$parent;
          var $existing = $parent.find('input.mbsc-control');
          var $input = $existing.length ? $existing : $$2('<input tabindex="-1" class="mbsc-control" readonly>');

          _this._$input = $input;

          $parent.addClass('mbsc-select' + (_this._$frame ? ' mbsc-select-inline' : ''));

          $elm.after($input);

          $input.after('<span class="mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5"></span>');

          // Check if select and mobiscroll select was not initialized
          if (!$elm.hasClass('mbsc-comp')) {
              elm.addEventListener('change', _this);
              _this._setText();
          }
          return _this;
      }

      createClass(Select, [{
          key: 'destroy',
          value: function destroy() {
              get(Select.prototype.__proto__ || Object.getPrototypeOf(Select.prototype), 'destroy', this).call(this);
              this._$parent.find('.mbsc-select-ic').remove();
              this._elm.removeEventListener('change', this);
          }
      }, {
          key: 'handleEvent',
          value: function handleEvent(ev) {
              get(Select.prototype.__proto__ || Object.getPrototypeOf(Select.prototype), 'handleEvent', this).call(this, ev);

              if (ev.type == 'change') {
                  this._setText();
              }
          }
      }, {
          key: '_setText',
          value: function _setText() {
              var elm = this._elm;
              if (!this._$elm.hasClass('mbsc-comp')) {
                  this._$input.val(elm.selectedIndex != -1 ? elm.options[elm.selectedIndex].text : '');
              }
          }
      }]);
      return Select;
  }(Input);

  var events$1 = ['keydown', 'input', 'scroll'];

  var sizeDebounce = void 0;

  function sizeTextAreas() {
      clearTimeout(sizeDebounce);
      sizeDebounce = setTimeout(function () {
          $$2('textarea.mbsc-control').each(function () {
              sizeTextArea(this);
          });
      }, 100);
  }

  function sizeTextArea(control) {
      var height = void 0,
          lineNr = void 0,
          line = void 0,
          rowNr = $$2(control).attr('rows') || 6;

      if (control.offsetHeight) {
          control.style.height = '';

          line = control.scrollHeight - control.offsetHeight;
          height = control.offsetHeight + (line > 0 ? line : 0);
          lineNr = Math.round(height / 24);

          if (lineNr > rowNr) {
              control.scrollTop = height;
              height = 24 * rowNr + (height - lineNr * 24);
              $$2(control).addClass('mbsc-textarea-scroll');
          } else {
              $$2(control).removeClass('mbsc-textarea-scroll');
          }

          if (height) {
              control.style.height = height + 'px';
          }
      }
  }

  function scrollTextArea(elm) {
      var $elm = $$2(elm);

      if (!$elm.hasClass('mbsc-textarea-scroll')) {
          var line = elm.scrollHeight - elm.offsetHeight,
              height = elm.offsetHeight + line;

          elm.scrollTop = 0;
          elm.style.height = height + 'px';
      }
  }

  if (isBrowser) {
      // Set height of textareas on viewport size changes
      $$2(window).on('resize orientationchange', sizeTextAreas);
  }

  var TextArea = function (_Input) {
      inherits(TextArea, _Input);

      function TextArea(elm, settings) {
          classCallCheck(this, TextArea);

          var _this = possibleConstructorReturn(this, (TextArea.__proto__ || Object.getPrototypeOf(TextArea)).call(this, elm, settings));

          _this._$parent.addClass('mbsc-textarea');

          events$1.forEach(function (ev) {
              _this._elm.addEventListener(ev, _this);
          });

          sizeTextArea(elm);
          return _this;
      }

      createClass(TextArea, [{
          key: 'destroy',
          value: function destroy() {
              var _this2 = this;

              get(TextArea.prototype.__proto__ || Object.getPrototypeOf(TextArea.prototype), 'destroy', this).call(this);
              events$1.forEach(function (ev) {
                  _this2._elm.removeEventListener(ev, _this2);
              });
          }
      }, {
          key: 'handleEvent',
          value: function handleEvent(ev) {
              get(TextArea.prototype.__proto__ || Object.getPrototypeOf(TextArea.prototype), 'handleEvent', this).call(this, ev);

              switch (ev.type) {
                  case 'keydown':
                  case 'input':
                      this._onInput(ev);
                      break;
                  case 'scroll':
                      scrollTextArea(this._elm);
              }
          }
      }, {
          key: '_onInput',
          value: function _onInput() {
              var _this3 = this;

              clearTimeout(this._debounce);
              this._debounce = setTimeout(function () {
                  sizeTextArea(_this3._elm);
              }, 100);
          }
      }]);
      return TextArea;
  }(Input);

  var SegmentedItem = function (_FormControl) {
      inherits(SegmentedItem, _FormControl);

      function SegmentedItem(elm, settings) {
          classCallCheck(this, SegmentedItem);

          var _this = possibleConstructorReturn(this, (SegmentedItem.__proto__ || Object.getPrototypeOf(SegmentedItem)).call(this, elm, settings));

          var $segmentCont = void 0;
          var $segment = void 0;

          var $elm = _this._$elm;
          var $parent = _this._$parent;

          if (!$parent.hasClass('mbsc-segmented-item-ready')) {
              $segmentCont = $$2('<div class="mbsc-segmented"></div>');

              $parent.after($segmentCont);
              $parent.parent().find('input[name="' + $elm.attr('name') + '"]').each(function () {
                  var $input = $$2(this);

                  $segment = $input.parent().addClass('mbsc-segmented-item mbsc-segmented-item-ready');

                  $$2('<span class="mbsc-segmented-content">' + ($input.attr('data-icon') ? '<span class="mbsc-ic mbsc-ic-' + $input.attr('data-icon') + '"></span>' : '') + '</span>').append($segment.contents()).appendTo($segment);

                  $segment.prepend($input);

                  $segmentCont.append($segment);
              });
          }

          _this._$rippleElm = $elm.next();
          return _this;
      }

      return SegmentedItem;
  }(FormControl);

  function createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {
      var $btn,
          changed,
          index,
          running,
          startX,
          startY,
          step,
          timer,
          check = isReadOnly || noop;

      function onBtnStart(ev) {
          var proceed;

          $btn = $$2(this);

          step = +$btn.attr('data-step');
          index = +$btn.attr('data-index');
          changed = true;

          if (stopProp) {
              ev.stopPropagation();
          }

          if (ev.type == 'mousedown') {
              // Prevent focus
              ev.preventDefault();
          }

          if (ev.type != 'keydown') {
              //e.preventDefault();
              startX = getCoord(ev, 'X');
              startY = getCoord(ev, 'Y');
              proceed = testTouch(ev, this);
          } else {
              proceed = ev.keyCode === 32;
          }

          if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {
              if (start(index, step)) {
                  $btn.addClass('mbsc-active');
                  if (ripple) {
                      ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);
                  }
              }

              if (ev.type == 'mousedown') {
                  $$2(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);
              }
          }
      }

      function onBtnMove(ev) {
          if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {
              changed = true;
              stop();
          }
      }

      function onBtnEnd(ev) {
          if (ev.type == 'touchend') {
              // Prevents iOS scroll on double tap
              ev.preventDefault();
          }

          stop();

          if (ev.type == 'mouseup') {
              $$2(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);
          }
      }

      function stop() {
          running = false;
          clearInterval(timer);
          if ($btn) {
              $btn.removeClass('mbsc-active');
              if (ripple) {
                  setTimeout(function () {
                      ripple.removeRipple();
                  }, 100);
              }
          }
      }

      function start(i, st) {
          if (!running && !check(i)) {
              index = i;
              step = st;
              running = true;
              changed = false;
              setTimeout(tick, 100);
          }
          return running;
      }

      function tick() {
          if ($btn && $btn.hasClass('mbsc-disabled')) {
              stop();
              return;
          }
          if (running || !changed) {
              changed = true;
              action(index, step, tick);
          }
          if (running && delay) {
              clearInterval(timer);
              timer = setInterval(function () {
                  action(index, step);
              }, delay);
          }
      }

      function destroy() {
          $elm.off('touchstart mousedown keydown', onBtnStart).off('touchmove', onBtnMove).off('touchend touchcancel keyup', onBtnEnd);
      }

      $elm.on('touchstart mousedown keydown', onBtnStart).on('touchmove', onBtnMove).on('touchend touchcancel keyup', onBtnEnd);

      return {
          start: start,
          stop: stop,
          destroy: destroy
      };
  }

  var Stepper = function Stepper(control, settings) {
      var $btnPlus,
          $btnMinus,
          $controls,
          displayValue,
          max,
          min,
          ripple,
          step,
          stepper,
          s,
          theme,
          val,
          that = this,
          $control = $$2(control),
          ready,
          $parent,
          old = val;

      function onChange() {
          var v;

          if (!control.disabled) {
              v = parseFloat($$2(this).val());
              setValue(isNaN(v) ? val : v);
          }
      }

      function checkDisabled() {
          return control.disabled;
      }

      function stepValue(index, dir) {
          setValue(val + dir * step);
      }

      function setValue(v, fill, change) {

          old = val;

          if (fill === undefined) {
              fill = true;
          }

          if (change === undefined) {
              change = fill;
          }

          val = Math.min(max, Math.max(Math.round(v / step) * step, min));

          $controls.removeClass('mbsc-disabled');

          if (fill) {
              $control.val(val);
          }

          if (val == min) {
              $btnMinus.addClass('mbsc-disabled');
          } else if (val == max) {
              $btnPlus.addClass('mbsc-disabled');
          }

          if (val !== old && change) {
              $control.trigger('change');
          }
      }

      function getAttr(attr, def) {
          var v = $control.attr(attr);
          return v === undefined || v === '' ? def : +v;
      }

      // Call the parent constructor
      Base.call(this, control, settings, true);

      /* TRIALFUNC */

      that.getVal = function () {
          var v = parseFloat($control.val());
          v = isNaN(v) ? val : v;
          return Math.min(max, Math.max(Math.round(v / step) * step, min));
      };

      that.setVal = function (v, fill, change) {
          v = parseFloat(v);
          setValue(isNaN(v) ? val : v, fill, change);
      };

      that._init = function (ss) {
          ready = $control.parent().hasClass('mbsc-stepper');
          $parent = ready ? $control.closest('.mbsc-stepper-cont') : $control.parent();

          s = that.settings;

          min = ss.min === undefined ? getAttr('min', s.min) : ss.min;
          max = ss.max === undefined ? getAttr('max', s.max) : ss.max;
          step = ss.step === undefined ? getAttr('step', s.step) : ss.step;
          displayValue = $control.attr('data-val') || s.val;
          val = Math.min(max, Math.max(Math.round(+control.value / step) * step || 0, min));

          theme = mobiscroll$3.themes.form[s.theme];
          ripple = theme && theme.addRipple ? theme : null;

          if (!ready) {
              $parent.addClass('mbsc-stepper-cont mbsc-control-w').append('<span class="mbsc-segmented mbsc-stepper"></span>').find('.mbsc-stepper').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-minus ' + (val == min ? 'mbsc-disabled' : '') + '" data-step="-1" tabindex="0"><span class="mbsc-segmented-content"><span class="mbsc-ic mbsc-ic-minus"></span></span></span>').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-plus ' + (val == max ? 'mbsc-disabled' : '') + '"  data-step="1" tabindex="0"><span class="mbsc-segmented-content"> <span class="mbsc-ic mbsc-ic-plus"></span></span></span>').prepend($control);
          }

          $btnMinus = $$2('.mbsc-stepper-minus', $parent);
          $btnPlus = $$2('.mbsc-stepper-plus', $parent);
          $controls = $$2('.mbsc-stepper-control', $parent);

          if (!ready) {
              if (displayValue == 'left') {
                  $parent.addClass('mbsc-stepper-val-left');
                  $control.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
              } else if (displayValue == 'right') {
                  $parent.addClass('mbsc-stepper-val-right');
                  $btnPlus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
              } else {
                  $btnMinus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content mbsc-stepper-val"></span></span>');
              }
          }

          if (!stepper) {
              $control.on('change', onChange);
              stepper = createStepper($controls, stepValue, 150, checkDisabled, false, ripple);
          }

          $control.val(val).attr('data-role', 'stepper').attr('min', min).attr('max', max).attr('step', step).addClass('mbsc-control');

          control.mbscInst = that;
      };

      that._destroy = function () {
          $control.removeClass('mbsc-control').off('change', onChange);
          stepper.destroy();
          delete control.mbscInst;
      };

      that.init(settings);
  };

  Stepper.prototype = {
      _class: 'stepper',
      _hasDef: true,
      _defaults: {
          min: 0,
          max: 100,
          step: 1
      }
  };

  classes.Stepper = Stepper;

  var ProgressBase = function ProgressBase(elm, settings, inherit) {
          var $elm,
              $parent,
              cssClass,
              s,
              that = this;

          // Call the parent constructor
          Base.call(this, elm, settings, true);

          that.__init = noop;

          that.__destroy = noop;

          that._init = function (ss) {

                  var wasInit;

                  s = that.settings;

                  $elm = $$2(elm);

                  // Check if the element was already initialized
                  wasInit = !!$parent;

                  $parent = $elm.parent();
                  $parent = $parent.hasClass('mbsc-input-wrap') ? $parent.parent() : $parent;

                  that._$parent = $parent;

                  if (cssClass) {
                          $parent.removeClass(cssClass);
                  }

                  cssClass = that._css + ' mbsc-progress-w mbsc-control-w mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');

                  $parent.addClass(cssClass);

                  $elm.addClass('mbsc-control');

                  that.__init(ss);

                  if (!wasInit) {
                          that._attachChange();
                  }

                  // Show initial value
                  that.refresh();

                  elm.mbscInst = that;
          };

          that._destroy = function () {

                  that.__destroy();

                  $parent.removeClass(cssClass);

                  $elm.removeClass('mbsc-control');

                  delete elm.mbscInst;
          };

          if (!inherit) {
                  that.init(settings);
          }
  };

  var SliderBase = function SliderBase(elm, settings, inherit) {
      var $elm,
          $handle,
          $handleCont,
          $handles,
          $listener,
          $parent,
          $track,
          action,
          base,
          changed,
          diffX,
          diffY,
          diff,
          endX,
          endY,
          handleIndex,
          isHover,
          isPressed,
          isRtl,
          live,
          max,
          min,
          moved,
          multiple,
          oldValue,
          step,
          s,
          scale,
          startX,
          startY,
          stepDecimal,
          timer,
          totalWidth,
          value,
          that = this,
          lastUpdate = new Date();

      function onStart(ev) {
          if (ev.type === 'mousedown') {
              ev.preventDefault();
          }

          if (testTouch(ev, this) && (!action || isHover) && !elm.disabled && !elm.readOnly /* TRIALCOND */) {
                  if (s.stopProp) {
                      ev.stopPropagation();
                  }

                  action = true;
                  moved = false;
                  changed = false;
                  startX = getCoord(ev, 'X');
                  startY = getCoord(ev, 'Y');
                  endX = startX;

                  $track.removeClass('mbsc-progress-anim');
                  $handle = multiple ? $$2('.mbsc-slider-handle', this) : $handles;

                  if ($handleCont) {
                      $handleCont.removeClass('mbsc-handle-curr');
                  }

                  $handleCont = $handle.parent().addClass('mbsc-active mbsc-handle-curr');
                  $elm.addClass('mbsc-active');

                  handleIndex = +$handle.attr('data-index');
                  totalWidth = $track[0].offsetWidth;
                  diff = $track[0].getBoundingClientRect().left;

                  if (ev.type === 'mousedown') {
                      isPressed = true;
                      $$2(document).on('mousemove', onMove).on('mouseup', onEnd);
                  }

                  if (ev.type === 'mouseenter') {
                      isHover = true;
                      $$2(document).on('mousemove', onMove);
                  }
              }
      }

      function onMove(ev) {
          if (action) {
              endX = getCoord(ev, 'X');
              endY = getCoord(ev, 'Y');
              diffX = endX - startX;
              diffY = endY - startY;

              if (Math.abs(diffX) > 5) {
                  moved = true;
              }

              if (moved || isPressed || isHover) {
                  if (Math.abs(lastUpdate - new Date()) > 50) {
                      lastUpdate = new Date();
                      updateSlider(endX, s.round, live && (!isHover || isPressed));
                  }
              }

              if (moved) {
                  ev.preventDefault();
              } else if (Math.abs(diffY) > 7 && ev.type == 'touchmove') {
                  cleanUp(ev);
              }
          }
      }

      function onEnd(ev) {
          if (action) {
              ev.preventDefault();

              if (!multiple) {
                  $track.addClass('mbsc-progress-anim');
              }

              if (isHover && !isPressed) {
                  updateValue(value[handleIndex], handleIndex, false, false, true);
              } else {
                  updateSlider(endX, true, true);
              }

              if (!moved && !changed) {

                  if (ev.type == 'touchend') {
                      // Prevent ghost click
                      preventClick();
                  }

                  that._onTap(value[handleIndex]);
              }

              if (ev.type == 'mouseup') {
                  isPressed = false;
              }

              if (ev.type == 'mouseleave') {
                  isHover = false;
              }

              if (!isHover) {
                  cleanUp();
              }
          }
      }

      function onCancel() {
          if (action) {
              cleanUp();
          }
      }

      function onChange() {
          var v = that._readValue($$2(this)),
              i = +$$2(this).attr('data-index');

          if (v !== value[i]) {
              value[i] = v;
              oldValue[i] = v;
              updateValue(v, i);
          }
      }

      function onClick(ev) {
          // Prevent propagating click to label
          ev.stopPropagation();
      }

      function onLabelClick(ev) {
          // Prevent change on label click for swithes
          ev.preventDefault();
      }

      function onKeyDown(ev) {
          var dir;

          if (!elm.disabled) {

              switch (ev.keyCode) {
                  case 38:
                  case 39:
                      dir = 1;
                      break;
                  case 40:
                  case 37:
                      dir = -1;
                      break;
              }

              if (dir) {
                  ev.preventDefault();

                  if (!timer) {

                      handleIndex = +$$2(this).attr('data-index');

                      updateValue(value[handleIndex] + step * dir, handleIndex, true);

                      timer = setInterval(function () {
                          updateValue(value[handleIndex] + step * dir, handleIndex, true);
                      }, 200);
                  }
              }
          }
      }

      function onKeyUp(ev) {
          ev.preventDefault();
          clearInterval(timer);
          timer = null;
      }

      function cleanUp() {
          action = false;
          $handleCont.removeClass('mbsc-active');
          $elm.removeClass('mbsc-active');

          // Detach document events
          $$2(document).off('mousemove', onMove).off('mouseup', onEnd);
      }

      function updateSlider(pos, round, fill) {
          var percent = round ? Math.min(Math[that._rounding || 'round'](Math.max((pos - diff) * 100 / totalWidth, 0) / scale / step) * step * 100 / (max - min + base), 100) : Math.max(0, Math.min((pos - diff) * 100 / totalWidth, 100));

          if (isRtl) {
              percent = 100 - percent;
          }

          updateValue(Math.round((min - base + percent / scale) * stepDecimal) / stepDecimal, handleIndex, fill, percent);
      }

      function updateValue(v, index, fill, percent, refresh, change) {
          var $handle = $handles.eq(index),
              $handleCont = $handle.parent();

          v = Math.min(max, Math.max(v, min));

          if (change === undefined) {
              change = fill;
          }

          if (that._update) {
              v = that._update(v, value, index, percent, multiple, refresh, $handleCont);
          } else {
              $handleCont.css({
                  left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
                  right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
              });
          }

          if (v > min) {
              $handleCont.removeClass('mbsc-slider-start');
          } else if (value[index] > min || refresh) {
              $handleCont.addClass('mbsc-slider-start');
          }

          // Check if value changed
          if (fill && oldValue[index] != v) {
              changed = true;

              oldValue[index] = v;

              // Store new value
              value[index] = v;

              // Set new value to the input
              that._fillValue(v, index, change);
          }

          $handle.attr('aria-valuenow', v);
      }

      // Call the parent constructor
      ProgressBase.call(this, elm, settings, true);

      that._onTap = noop;

      that.___init = noop;

      that.___destroy = noop;

      that._attachChange = function () {
          $elm.on(s.changeEvent, onChange);
      };

      that.__init = function (ss) {
          var wasInit;

          if ($handles) {
              wasInit = true;
              $handles.parent().remove();
          }

          that.___init(ss);

          $parent = that._$parent;
          $track = that._$track;
          $elm = $parent.find('input');

          s = that.settings;
          min = that._min;
          max = that._max;
          base = that._base || 0;
          step = that._step;
          live = that._live;
          stepDecimal = step % 1 !== 0 ? 100 / (+(step % 1).toFixed(2) * 100) : 1;
          scale = 100 / (max - min + base) || 100;
          multiple = $elm.length > 1;
          isRtl = s.rtl;
          value = [];
          oldValue = [];

          // Read values
          $elm.each(function (i) {
              value[i] = that._readValue($$2(this));
              $$2(this).attr('data-index', i);
          });

          $handles = $parent.find('.mbsc-slider-handle');
          $listener = $parent.find(multiple ? '.mbsc-slider-handle-cont' : '.mbsc-progress-cont');

          // Attach events
          $handles.on('keydown', onKeyDown).on('keyup', onKeyUp).on('blur', onKeyUp);

          $listener.on('touchstart mousedown' + (s.hover ? ' mouseenter' : ''), onStart).on('touchmove', onMove).on('touchend touchcancel' + (s.hover ? ' mouseleave' : ''), onEnd).on('pointercancel', onCancel);

          if (!wasInit) {
              $elm.on('click', onClick);

              $parent.on('click', onLabelClick);
          }
      };

      that.__destroy = function () {
          $parent.off('click', onLabelClick);

          $elm.off(s.changeEvent, onChange).off('click', onClick);

          $handles.off('keydown', onKeyDown).off('keyup', onKeyUp).off('blur', onKeyUp);

          $listener.off('touchstart mousedown mouseenter', onStart).off('touchmove', onMove).off('touchend touchcancel mouseleave', onEnd).off('pointercancel', onCancel);

          that.___destroy();
      };

      that.refresh = function () {
          $elm.each(function (i) {
              updateValue(that._readValue($$2(this)), i, true, false, true, false);
          });
      };

      that.getVal = function () {
          return multiple ? value.slice(0) : value[0];
      };

      that.setVal = that._setVal = function (val, fill, change) {
          if (!$$2.isArray(val)) {
              val = [val];
          }

          $$2.each(val, function (i, v) {
              value[i] = v;
          });

          $$2.each(val, function (i, v) {
              updateValue(v, i, true, false, true, change);
          });
      };

      if (!inherit) {
          that.init(settings);
      }
  };

  var Switch = function Switch(elm, settings) {
      var $elm,
          $parent,
          s,
          formControl,
          that = this;

      settings = settings || {};

      extend$1(settings, {
          changeEvent: 'click',
          round: false
      });

      // Call the parent constructor
      SliderBase.call(this, elm, settings, true);

      that._readValue = function () {
          return elm.checked ? 1 : 0;
      };

      that._fillValue = function (v, index, change) {
          $elm.prop('checked', !!v);

          if (change) {
              $elm.trigger('change');
          }
      };

      that._onTap = function (v) {
          that._setVal(v ? 0 : 1);
      };

      that.___init = function () {
          s = that.settings;
          $elm = $$2(elm);
          $parent = $elm.parent();

          $parent.find('.mbsc-switch-track').remove();
          $parent.prepend($elm);

          $elm.attr('data-role', 'switch').after('<span class="mbsc-progress-cont mbsc-switch-track">' + '<span class="mbsc-progress-track mbsc-progress-anim">' + '<span class="mbsc-slider-handle-cont">' + '<span class="mbsc-slider-handle mbsc-switch-handle" data-index="0">' + '<span class="mbsc-switch-txt-off">' + s.offText + '</span>' + '<span class="mbsc-switch-txt-on">' + s.onText + '</span>' + '</span></span></span></span>');

          if (formControl) {
              formControl.destroy();
          }

          formControl = new FormControl(elm, s);

          that._$track = $parent.find('.mbsc-progress-track');
          that._min = 0;
          that._max = 1;
          that._step = 1;
      };

      that.___destroy = function () {
          formControl.destroy();
      };

      that.getVal = function () {
          return elm.checked;
      };

      that.setVal = function (val, fill, change) {
          that._setVal(val ? 1 : 0, fill, change);
      };

      that.init(settings);
  };

  Switch.prototype = {
      _class: 'switch',
      _css: 'mbsc-switch',
      _hasTheme: true,
      _hasLang: true,
      _hasDef: true,
      _defaults: {
          stopProp: true,
          offText: 'Off',
          onText: 'On'
      }
  };

  classes.Switch = Switch;

  /* eslint-disable no-unused-vars */
  /* eslint-enable no-unused-vars */
  var Progress = function Progress(elm, settings, inherit) {
      var $display,
          $elm,
          $parent,
          $progress,
          $target,
          $track,
          min,
          max,
          s,
          template,
          value,
          valueText,
          that = this;

      function onChange() {
          var v = getAttr('value', min);
          if (v !== value) {
              updateValue(v);
          }
      }

      function getAttr(attr, def) {
          var v = $elm.attr(attr);
          return v === undefined || v === '' ? def : +v;
      }

      function updateValue(v, refresh, fill, change) {
          v = /* TRIALCONDREV */Math.min(max, Math.max(v, min));

          $progress.css('width', (v - min) * 100 / (max - min) + '%');

          if (fill === undefined) {
              fill = true;
          }

          if (change === undefined) {
              change = fill;
          }

          if (v !== value || refresh) {
              // Display value
              that._display(v);
          }

          if (v !== value) {
              // Set new value
              value = v;

              // Put new value in the progress element
              if (fill) {
                  $elm.attr('value', value);
              }

              // Trigger change on the element
              if (change) {
                  $elm.trigger('change');
              }
          }
      }

      // Call the parent constructor
      ProgressBase.call(this, elm, settings, true);

      that._display = function (v) {
          valueText = template && s.returnAffix ? template.replace(/\{value\}/, v).replace(/\{max\}/, max) : v;

          if ($target) {
              $target.html(valueText);
          }

          if ($display) {
              $display.html(valueText);
          }
      };

      that._attachChange = function () {
          $elm.on('change', onChange);
      };

      that.__init = function (ss) {

          var displayValue, i, stepLabels, wasInit;

          s = that.settings;

          $elm = $$2(elm);

          // Check if the element was already initialized
          wasInit = !!$parent;

          $parent = that._$parent;

          // Read settings from data attributes or settings object
          min = that._min = ss.min === undefined ? getAttr('min', s.min) : ss.min;
          max = that._max = ss.max === undefined ? getAttr('max', s.max) : ss.max;
          value = getAttr('value', min);
          displayValue = $elm.attr('data-val') || s.val;
          stepLabels = $elm.attr('data-step-labels');
          stepLabels = stepLabels ? JSON.parse(stepLabels) : s.stepLabels;
          template = $elm.attr('data-template') || (max == 100 && !s.template ? '{value}%' : s.template);

          if (!wasInit) {
              wrapLabel($parent);

              addIcon($elm);

              // Generate track and progress
              $parent.find('.mbsc-input-wrap').append('<span class="mbsc-progress-cont"><span class="mbsc-progress-track mbsc-progress-anim"><span class="mbsc-progress-bar"></span></span></span>');

              $progress = that._$progress = $parent.find('.mbsc-progress-bar');
              $track = that._$track = $parent.find('.mbsc-progress-track');
          } else {
              if (displayValue) {
                  $display.remove();
                  $parent.removeClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left'));
              }

              if (stepLabels) {
                  $$2('.mbsc-progress-step-label', $track).remove();
              }
          }

          // Set attributes
          $elm.attr('min', min).attr('max', max);

          // Generate value container on left or right side
          if (displayValue) {
              $display = $$2('<span class="mbsc-progress-value"></span>');
              $parent.addClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left')).find('.mbsc-input-wrap').append($display);
          }

          // Generate step labels
          if (stepLabels) {
              for (i = 0; i < stepLabels.length; ++i) {
                  $track.append('<span class="mbsc-progress-step-label" style="' + (s.rtl ? 'right' : 'left') + ': ' + (stepLabels[i] - min) * 100 / (max - min) + '%" >' + stepLabels[i] + '</span>');
              }
          }

          $target = $$2($elm.attr('data-target') || s.target);
      };

      that.__destroy = function () {

          $parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-progress-cont').remove();

          $parent.find('.mbsc-input-ic').remove();

          $elm.off('change', onChange);
      };

      that.refresh = function () {
          updateValue(getAttr('value', min), true, false);
      };

      that.getVal = function () {
          return value;
      };

      that.setVal = function (v, fill, change) {
          updateValue(v, true, fill, change);
      };

      if (!inherit) {
          that.init(settings);
      }
  };

  Progress.prototype = {
      _class: 'progress',
      _css: 'mbsc-progress',
      _hasTheme: true,
      _hasLang: true,
      _hasDef: true,
      _defaults: {
          min: 0,
          max: 100,
          returnAffix: true
      }
  };

  classes.Progress = Progress;

  var Slider = function Slider(elm, settings, inherit) {
      var $elm,
          $parent,
          $progress,
          $tooltips,
          $track,
          hasProgress,
          hasTooltip,
          isRange,
          isRtl,
          max,
          min,
          step,
          s,
          that = this;

      // Call the parent constructor
      Progress.call(this, elm, settings, true);

      var progressInit = that.__init,
          progressDestroy = that.__destroy;

      SliderBase.call(this, elm, settings, true);

      var sliderInit = that.__init,
          sliderDestroy = that.__destroy;

      // ---

      that.__init = function (ss) {
          progressInit(ss);
          sliderInit(ss);
      };

      that.__destroy = function () {
          progressDestroy();
          sliderDestroy();
      };

      that._update = function (v, value, index, percent, multiple, refresh, $handleCont) {
          if (isRange) {
              if (index === 0) {
                  v = Math.min(v, value[1]);
                  $progress.css({
                      width: getPercent(value[1], min, max) - getPercent(v, min, max) + '%',
                      left: isRtl ? 'auto' : getPercent(v, min, max) + '%',
                      right: isRtl ? getPercent(v, min, max) + '%' : 'auto'
                  });
              } else {
                  v = Math.max(v, value[0]);
                  $progress.css({
                      width: getPercent(v, min, max) - getPercent(value[0], min, max) + '%'
                  });
              }
          } else if (multiple || !hasProgress) {
              $handleCont.css({
                  left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
                  right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
              });
          } else {
              $progress.css('width', (percent || getPercent(v, min, max)) + '%');
          }

          if (hasTooltip) {
              $tooltips.eq(index).html(v);
          }

          // Display value in the specified container(s)
          if (!multiple && (value[index] != v || refresh)) {
              that._display(v);
          }

          // Return validated value
          return v;
      };

      that._readValue = function ($elm) {
          return +$elm.val();
      };

      that._fillValue = function (v, index, change) {
          $elm.eq(index).val(v);

          if (change) {
              $elm.eq(index).trigger('change');
          }
      };

      that._markupReady = function () {
          var i, stepNr;

          if (hasTooltip) {
              $parent.addClass('mbsc-slider-has-tooltip');
          }

          // Generate step marks
          if (step != 1) {
              stepNr = (max - min) / step;
              for (i = 0; i <= stepNr; ++i) {
                  $track.append('<span class="mbsc-slider-step" style="' + (isRtl ? 'right' : 'left') + ':' + 100 / stepNr * i + '%"></span>');
              }
          }

          // Generate slider handles
          $elm.each(function (i) {
              if (this.type == 'range') {
                  // Set min / max / step properties for all inputs
                  $$2(this).attr('min', min).attr('max', max).attr('step', step);
              }

              (hasProgress ? $progress : $track).append('<span class="mbsc-slider-handle-cont' + (isRange && !i ? ' mbsc-slider-handle-left' : '') + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="' + i + '"></span>' + (hasTooltip ? '<span class="mbsc-slider-tooltip"></span>' : '') + '</span>');
          });

          $tooltips = $parent.find('.mbsc-slider-tooltip');
      };

      that.___init = function (ss) {
          if ($parent) {
              $parent.removeClass('mbsc-slider-has-tooltip');
              if (step != 1) {
                  $$2('.mbsc-slider-step', $track).remove();
              }
          }

          $parent = that._$parent;
          $track = that._$track;
          $progress = that._$progress;
          $elm = $parent.find('input');

          s = that.settings;
          min = that._min;
          max = that._max;
          that._step = step = ss.step === undefined ? +$elm.attr('step') || s.step : ss.step;
          that._live = getBoolAttr('data-live', s.live, $elm);
          hasTooltip = getBoolAttr('data-tooltip', s.tooltip, $elm);
          hasProgress = getBoolAttr('data-highlight', s.highlight, $elm) && $elm.length < 3;
          isRange = hasProgress && $elm.length == 2;
          isRtl = s.rtl;

          that._markupReady();
      };

      if (!inherit) {
          that.init(settings);
      }
  };

  Slider.prototype = {
      _class: 'progress',
      _css: 'mbsc-progress mbsc-slider',
      _hasTheme: true,
      _hasLang: true,
      _hasDef: true,
      _defaults: {
          changeEvent: 'change',
          stopProp: true,
          min: 0,
          max: 100,
          step: 1,
          live: true,
          highlight: true,
          round: true,
          returnAffix: true
      }
  };

  classes.Slider = Slider;

  var Rating = function Rating(elm, settings, inherit) {
      var $progress,
          $track,
          max,
          min,
          empty,
          filled,
          s,
          that = this,
          $elm = $$2(elm);

      // Call the parent constructor
      Slider.call(this, elm, settings, true);

      that._update = function (v, value, index, percent, multiple, refresh) {
          $progress.css('width', getPercent(v, 0, max) + '%');

          // Display value in the specified container(s)
          if (!multiple && (value[index] != v || refresh)) {
              that._display(v);
          }

          // Return validated value
          return v;
      };

      that._markupReady = function () {
          var i,
              emptyString = '',
              filledString = '';

          $track = that._$track;
          $progress = that._$progress;

          s = that.settings;
          min = that._min;
          max = that._max;
          that._base = min;
          that._rounding = s.rtl ? 'floor' : 'ceil';
          empty = $elm.attr('data-empty') || s.empty;
          filled = $elm.attr('data-filled') || s.filled;

          for (i = 0; i < max; ++i) {
              emptyString += '<span class="mbsc-ic mbsc-ic-' + empty + '"></span>';
              filledString += '<span class="mbsc-ic mbsc-ic-' + filled + '"></span>';
          }

          $track.html(emptyString);
          $track.append($progress);
          $progress.html(filledString);

          $track.append('<span class="mbsc-rating-handle-cont' + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="0"></span>' + '</span>');
      };

      if (!inherit) {
          that.init(settings);
      }
  };

  Rating.prototype = {
      _class: 'progress',
      _css: 'mbsc-progress mbsc-rating',
      _hasTheme: true,
      _hasLang: true,
      _hasDef: true,
      _defaults: {
          changeEvent: 'change',
          stopProp: true,
          min: 1,
          max: 5,
          step: 1,
          live: true,
          round: true,
          hover: true,
          highlight: true,
          returnAffix: true,
          empty: 'star',
          filled: 'star3'
      }
  };

  classes.Rating = Rating;

  var id$1 = 0;

  var wrapClass = 'mbsc-input-wrap';

  function addIcon($control, ic) {
      var icons = {},
          $parent = $control.parent(),
          errorMsg = $parent.find('.mbsc-err-msg'),
          align = $control.attr('data-icon-align') || 'left',
          icon = $control.attr('data-icon');

      if ($parent.hasClass(wrapClass)) {
          $parent = $parent.parent();
      } else {
          // Wrap input
          $$2('<span class="' + wrapClass + '"></span>').insertAfter($control).append($control);
      }

      if (errorMsg) {
          $parent.find('.' + wrapClass).append(errorMsg);
      }

      if (icon) {
          if (icon.indexOf('{') !== -1) {
              icons = JSON.parse(icon);
          } else {
              icons[align] = icon;
          }
      }

      if (icon || ic) {
          extend$1(icons, ic);

          $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append(icons.left ? '<span class="mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '"></span>' : '').append(icons.right ? '<span class="mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '"></span>' : '');
      }
  }

  function addIconToggle(that, $parent, $control) {
      var icons = {},
          control = $control[0],
          toggle = $control.attr('data-password-toggle'),
          iconShow = $control.attr('data-icon-show') || 'eye',
          iconHide = $control.attr('data-icon-hide') || 'eye-blocked';

      if (toggle) {
          icons.right = control.type == 'password' ? iconShow : iconHide;
      }

      addIcon($control, icons);

      if (toggle) {
          tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {
              if (control.type == "text") {
                  control.type = "password";
                  $$2(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);
              } else {
                  control.type = "text";
                  $$2(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);
              }
          });
      }
  }

  function wrapLabel($parent, type) {
      // Wrap non-empty text nodes in span with mbsc-label class
      if (type != 'button' && type != 'submit' && type != 'segmented') {
          $parent.addClass('mbsc-control-w').find('label').addClass('mbsc-label');
          $parent.contents().filter(function () {
              return this.nodeType == 3 && this.nodeValue && /\S/.test(this.nodeValue);
          }).each(function () {
              $$2('<span class="mbsc-label"></span>').insertAfter(this).append(this);
          });
      }
  }

  function initControls($ctx, controls, s, shallow) {
      $$2('input,select,textarea,progress,button', $ctx).each(function () {
          var control = this,
              $control = $$2(control),

          //$parent = $control.parent(),
          type = getControlType($control);

          // Skip elements with data-enhance="false"
          if ($control.attr('data-enhance') != 'false' /* TRIALCOND */) {

                  if ($control.hasClass('mbsc-control')) {
                      if (control.mbscInst) {
                          control.mbscInst.option({
                              theme: s.theme,
                              lang: s.lang,
                              rtl: s.rtl,
                              onText: s.onText,
                              offText: s.offText,
                              stopProp: s.stopProp
                          });
                      }
                  } else {

                      if (!control.id) {
                          control.id = 'mbsc-form-control-' + ++id$1;
                      }

                      switch (type) {
                          case 'button':
                          case 'submit':
                              controls[control.id] = new Button(control, {
                                  theme: s.theme,
                                  tap: s.tap
                              });
                              break;
                          case 'switch':
                              controls[control.id] = new Switch(control, {
                                  theme: s.theme,
                                  lang: s.lang,
                                  rtl: s.rtl,
                                  tap: s.tap,
                                  onText: s.onText,
                                  offText: s.offText,
                                  stopProp: s.stopProp
                              });
                              break;
                          case 'checkbox':
                              controls[control.id] = new CheckBox(control, {
                                  tap: s.tap
                              });
                              break;
                          case 'range':
                              if (!$$2(control).parent().hasClass('mbsc-slider')) {
                                  controls[control.id] = new Slider(control, {
                                      theme: s.theme,
                                      lang: s.lang,
                                      rtl: s.rtl,
                                      stopProp: s.stopProp
                                  });
                              }
                              break;
                          case 'rating':
                              controls[control.id] = new Rating(control, {
                                  theme: s.theme,
                                  lang: s.lang,
                                  rtl: s.rtl,
                                  stopProp: s.stopProp
                              });
                              break;

                          case 'progress':
                              controls[control.id] = new Progress(control, {
                                  theme: s.theme,
                                  lang: s.lang,
                                  rtl: s.rtl
                              });
                              break;
                          case 'radio':
                              controls[control.id] = new Radio(control, {
                                  tap: s.tap
                              });
                              break;
                          case 'select':
                          case 'select-one':
                          case 'select-multiple':
                              controls[control.id] = new Select(control, {
                                  tap: s.tap
                              });
                              break;
                          case 'textarea':
                              controls[control.id] = new TextArea(control, {
                                  tap: s.tap
                              });
                              break;
                          case 'segmented':
                              controls[control.id] = new SegmentedItem(control, {
                                  theme: s.theme,
                                  tap: s.tap
                              });
                              break;
                          case 'stepper':
                              controls[control.id] = new Stepper(control, {
                                  theme: s.theme
                              });
                              break;
                          case 'hidden':
                              return;
                          default:
                              controls[control.id] = new Input(control, {
                                  tap: s.tap
                              });
                              break;
                      }
                  }
              }
      });

      // Set initial height for textareas
      if (!shallow) {
          sizeTextAreas();
      }
  }

  var $activeElm;
  var preventShow;
  var themes = mobiscroll$3.themes;
  var needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7;
  var isAndroid = os == 'android';
  var isIOS = os == 'ios';
  var isIOS8 = isIOS && majorVersion == 8;
  var halfBorder$1 = isIOS && majorVersion > 7;
  var prevdef = function prevdef(ev) {
      ev.preventDefault();
  };

  var Frame = function Frame(el, settings, inherit) {
      var //$ariaDiv,
      $ctx,
          $header,
          $lock,
          $markup,
          $overlay,
          $persp,
          $popup,
          $wnd,
          $wrapper,
          buttons,
          btn,
          ctx,
          doAnim,
          hasContext,
          isModal,
          isInserted,
          markup,
          modalWidth,
          modalHeight,
          needsDimensions,
          needsLock,
          overlay,
          popup,
          posDebounce,
          posEvents,
          preventPos,
          s,
          scrollLeft,
          scrollLock,
          scrollTop,
          touched,
          trigger,
          wndWidth,
          wndHeight,
          that = this,
          $elm = $$2(el),
          elmList = [],
          lastFocus = new Date();

      function onBtnStart(ev) {
          // Can't call preventDefault here, it kills page scroll
          if (btn) {
              btn.removeClass('mbsc-active');
          }

          btn = $$2(this);

          // Active button
          if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {
              btn.addClass('mbsc-active');
          }

          if (ev.type === 'mousedown') {
              $$2(document).on('mouseup', onBtnEnd);
          } else if (ev.type === 'pointerdown') {
              $$2(document).on('pointerup', onBtnEnd);
          }
      }

      function onBtnEnd(ev) {
          if (btn) {
              btn.removeClass('mbsc-active');
              btn = null;
          }

          if (ev.type === 'mouseup') {
              $$2(document).off('mouseup', onBtnEnd);
          } else if (ev.type === 'pointerup') {
              $$2(document).off('pointerup', onBtnEnd);
          }
      }

      function onWndKeyDown(ev) {
          if (ev.keyCode == 13) {
              that.select();
          } else if (ev.keyCode == 27) {
              that.cancel();
          }
      }

      function onShow(prevFocus) {
          if (!prevFocus && !isAndroid) {
              //overlay.focus();
              that._activeElm.focus();
          }
          //that.ariaMessage(s.ariaMessage);
      }

      function onHide(prevAnim) {
          var $activeEl = $activeElm,
              focus = s.focusOnClose;

          that._markupRemove();

          $markup.remove();

          if (isModal) {
              ctx.mbscModals--;

              if (s.scrollLock) {
                  ctx.mbscLock--;
              }

              if (!ctx.mbscLock) {
                  $lock.removeClass('mbsc-fr-lock');
              }

              // The follwing should be done only if no other
              // instance was opened during the hide animation
              if (!ctx.mbscModals) {
                  $lock.removeClass('mbsc-fr-lock-ios mbsc-fr-lock-ctx');
                  if (needsLock) {
                      $ctx.css({
                          top: '',
                          left: ''
                      });
                      $wnd.scrollLeft(scrollLeft);
                      $wnd.scrollTop(scrollTop);
                  }
                  // Put focus back to the last active element
                  if (!prevAnim) {
                      if (!$activeEl) {
                          $activeEl = $elm;
                      }
                      setTimeout(function () {
                          if (focus === undefined || focus === true) {
                              preventShow = true;
                              $activeEl[0].focus();
                          } else if (focus) {
                              $$2(focus)[0].focus();
                          }
                      }, 200);
                  }
              }
          }

          that._isVisible = false;

          isInserted = false;

          trigger('onHide');
      }

      function onPosition(ev) {
          clearTimeout(posDebounce);
          posDebounce = setTimeout(function () {
              that.position(true);
              if (ev.type == 'orientationchange') {
                  // Trigger reflow, needed on iOS9 (only?) for the scroll to work
                  popup.style.display = 'none';
                  popup.offsetHeight;
                  popup.style.display = '';
              }
          }, 200);
      }

      function onFocus(ev) {
          if (ev.target.nodeType && !overlay.contains(ev.target) && lastFocus - new Date() > 100) {
              overlay.focus();
              lastFocus = new Date();
          }
      }

      function insertMarkup(prevAnim, prevFocus) {

          function onAnimEnd() {
              $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);
              onShow(prevFocus);
          }

          // Show
          if (isModal) {
              $markup.appendTo($ctx);
          } else if ($elm.is('div') && !that._hasContent) {
              // Insert inside the element on which was initialized
              $elm.empty().append($markup);
          } else {
              // Insert after the element
              if ($elm.hasClass('mbsc-control')) {
                  var $wrap = $elm.closest('.mbsc-control-w');
                  $markup.insertAfter($wrap);
                  if ($wrap.hasClass('mbsc-select')) {
                      $wrap.addClass('mbsc-select-inline');
                  }
              } else {
                  $markup.insertAfter($elm);
              }
          }

          isInserted = true;

          that._markupInserted($markup);

          trigger('onMarkupInserted', {
              target: markup
          });

          $markup.on('selectstart mousedown', prevdef) // Prevents blue highlight on Android and text selection in IE
          .on('click', '.mbsc-fr-btn-e', prevdef).on('keydown', '.mbsc-fr-btn-e', function (ev) {
              if (ev.keyCode == 32) {
                  // Space
                  ev.preventDefault();
                  ev.stopPropagation();
                  this.click();
              }
          }).on('keydown', function (ev) {
              // Trap focus inside modal
              if (ev.keyCode == 32) {
                  // Space
                  ev.preventDefault();
              } else if (ev.keyCode == 9 && isModal && s.focusTrap) {
                  // Tab
                  var $focusable = $markup.find('[tabindex="0"]').filter(function () {
                      return this.offsetWidth > 0 || this.offsetHeight > 0;
                  }),
                      index = $focusable.index($$2(':focus', $markup)),
                      i = $focusable.length - 1,
                      target = 0;

                  if (ev.shiftKey) {
                      i = 0;
                      target = -1;
                  }

                  if (index === i) {
                      $focusable.eq(target)[0].focus();
                      ev.preventDefault();
                  }
              }
          }).on('touchstart mousedown pointerdown', '.mbsc-fr-btn-e', onBtnStart).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);

          $$2('input,select,textarea', $markup).on('selectstart mousedown', function (ev) {
              ev.stopPropagation();
          }).on('keydown', function (ev) {
              if (ev.keyCode == 32) {
                  // Space
                  ev.stopPropagation();
              }
          });

          // Need event capture for this
          markup.addEventListener('touchstart', function () {
              if (!touched) {
                  touched = true;
                  $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
              }
          }, true);

          // Init buttons
          $$2.each(buttons, function (i, b) {
              that.tap($$2('.mbsc-fr-btn' + i, $markup), function (ev) {
                  b = isString(b) ? that.buttons[b] : b;
                  (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);
              }, true);
          });

          that._attachEvents($markup);

          // Set position
          that.position();

          $wnd.on(posEvents, onPosition);

          if (isModal) {
              if (doAnim && !prevAnim) {
                  $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
              } else {
                  onShow(prevFocus);
              }
          }

          trigger('onShow', {
              target: markup,
              valueText: that._tempValue
          });
      }

      function show(beforeShow, $elm) {
          if (beforeShow) {
              beforeShow();
          }

          if (that.show() !== false) {
              $activeElm = $elm;
          }
      }

      function set() {
          that._fillValue();
          trigger('onSet', {
              valueText: that._value
          });
      }

      function cancel() {
          trigger('onCancel', {
              valueText: that._value
          });
      }

      function clear() {
          that.setVal(null, true);
      }

      // Call the parent constructor
      Base.call(this, el, settings, true);

      /**
       * Positions the scroller on the screen.
       */
      that.position = function (check) {
          var anchor,
              anchorWidth,
              anchorHeight,
              anchorPos,
              anchorTop,
              anchorLeft,
              arrow,
              arrowWidth,
              arrowHeight,
              docHeight,
              docWidth,
              isWrapped,
              newHeight,
              newWidth,
              width,
              top,
              left,
              css = {},
              scrollLeft = 0,
              scrollTop = 0,
              minWidth = 0,
              totalWidth = 0;

          if (preventPos || !isInserted) {
              return;
          }

          that._position($markup);

          newHeight = markup.offsetHeight;
          newWidth = markup.offsetWidth;

          if (wndWidth === newWidth && wndHeight === newHeight && check) {
              return;
          }

          if (that._isFullScreen || /top|bottom/.test(s.display)) {
              // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)
              $popup.width(newWidth);
          } else if (isModal) {
              // Reset width
              $wrapper.addClass('mbsc-fr-pos').width('');
          }

          // Call position for nested mobiscroll components
          $$2('.mbsc-comp', $markup).each(function () {
              var inst = instances[this.id];
              if (inst && inst !== that && inst.position) {
                  inst.position();
              }
          });

          if (!that._isFullScreen && /center|bubble/.test(s.display)) {
              $$2('.mbsc-w-p', $markup).each(function () {
                  // Need fractional values here, so offsetWidth is not ok
                  width = this.getBoundingClientRect().width;
                  totalWidth += width;
                  minWidth = width > minWidth ? width : minWidth;
              });

              isWrapped = totalWidth > newWidth - 16 || s.tabs === true;

              $wrapper.removeClass('mbsc-fr-pos').css({
                  'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),
                  'white-space': isWrapped ? '' : 'nowrap'
              });
          }

          if (trigger('onPosition', {
              target: markup,
              popup: popup,
              hasTabs: isWrapped,
              windowWidth: newWidth,
              windowHeight: newHeight
          }) === false || !isModal) {
              return;
          }

          // Set / unset liquid layout based on screen width, but only if not set explicitly by the user
          // if (that._isLiquid && s.layout !== 'liquid') {
          //     if (newWidth < 415) {
          //         $markup.addClass('mbsc-fr-liq');
          //     } else {
          //         $markup.removeClass('mbsc-fr-liq');
          //     }
          // }

          modalWidth = popup.offsetWidth;
          modalHeight = popup.offsetHeight;

          scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;

          if (needsDimensions) {
              scrollLeft = $wnd.scrollLeft();
              scrollTop = $wnd.scrollTop();
          }

          if (s.display == 'center') {
              left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);
              top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);
          } else if (s.display == 'bubble') {
              anchor = s.anchor === undefined ? $elm : $$2(s.anchor);

              arrow = $$2('.mbsc-fr-arr-i', $markup)[0];
              anchorPos = anchor.offset();
              anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);
              anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);

              anchorWidth = anchor[0].offsetWidth;
              anchorHeight = anchor[0].offsetHeight;

              arrowWidth = arrow.offsetWidth;
              arrowHeight = arrow.offsetHeight;

              // Horizontal positioning
              left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3);

              // Vertical positioning
              // Above the input
              top = anchorTop - modalHeight - arrowHeight / 2;
              // If doesn't fit above or the input is out of the screen
              if (top < scrollTop || anchorTop > scrollTop + newHeight) {
                  $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');
                  // Below the input
                  top = anchorTop + anchorHeight + arrowHeight / 2;
              } else {
                  $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top');
              }

              // Set arrow position
              $$2('.mbsc-fr-arr', $markup).css({
                  left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)
              });

              // Lock scroll only if popup is entirely in the viewport
              scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;
          } else {
              left = scrollLeft;
              top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);
          }

          if (needsDimensions) {
              // If top + modal height > doc height, increase doc height
              docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$2(document).height());
              docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$2(document).width());
              $persp.css({
                  width: docWidth,
                  height: docHeight
              });

              // Check if scroll needed
              if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {
                  preventPos = true;
                  setTimeout(function () {
                      preventPos = false;
                  }, 300);
                  $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));
              }
          }

          css.top = Math.floor(top);
          css.left = Math.floor(left);

          $popup.css(css);

          wndWidth = newWidth;
          wndHeight = newHeight;
      };

      /**
       * Show mobiscroll on focus and click event of the parameter.
       * @param {HTMLElement} elm - Events will be attached to this element.
       * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
       */
      that.attachShow = function (elm, beforeShow) {
          var $label,
              $elm = $$2(elm),
              readOnly = $elm.prop('readonly');

          if (s.display !== 'inline') {
              if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {
                  $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {
                      // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
                      ev.preventDefault();
                  }).on('focus.mbsc', function () {
                      if (that._isVisible) {
                          // Don't allow input focus if mobiscroll is being opened
                          this.blur();
                      }
                  });

                  $label = $$2('label[for="' + $elm.attr('id') + '"]');

                  if (!$label.length) {
                      $label = $elm.closest('label');
                  }
              }

              if ($elm.is('select')) {
                  return;
              }

              if (s.showOnFocus) {
                  $elm.on('focus.mbsc', function () {
                      if (!preventShow) {
                          show(beforeShow, $elm);
                      } else {
                          preventShow = false;
                      }
                  });
              }

              if (s.showOnTap) {
                  $elm.on('keydown.mbsc', function (ev) {
                      if (ev.keyCode == 32 || ev.keyCode == 13) {
                          // Space or Enter
                          ev.preventDefault();
                          ev.stopPropagation();
                          show(beforeShow, $elm);
                      }
                  });

                  that.tap($elm, function (ev) {
                      if (ev.type == 'touchend') {
                          touched = true;
                      }
                      show(beforeShow, $elm);
                  });

                  if ($label && $label.length) {
                      that.tap($label, function () {
                          show(beforeShow, $elm);
                      });
                  }
              }

              elmList.push({
                  readOnly: readOnly,
                  el: $elm,
                  lbl: $label
              });
          }
      };

      /**
       * Set button handler.
       */
      that.select = function () {
          if (isModal) {
              that.hide(false, 'set', false, set);
          } else {
              set();
          }
      };

      /**
       * Cancel and hide the scroller instance.
       */
      that.cancel = function () {
          if (isModal) {
              that.hide(false, 'cancel', false, cancel);
          } else {
              cancel();
          }
      };

      /**
       * Clear button handler.
       */
      that.clear = function () {
          that._clearValue();
          trigger('onClear');
          if (isModal && that._isVisible && !that.live) {
              that.hide(false, 'clear', false, clear);
          } else {
              clear();
          }
      };

      /**
       * Enables the scroller and the associated input.
       */
      that.enable = function () {
          s.disabled = false;
          if (that._isInput) {
              $elm.prop('disabled', false);
          }
      };

      /**
       * Disables the scroller and the associated input.
       */
      that.disable = function () {
          s.disabled = true;
          if (that._isInput) {
              $elm.prop('disabled', true);
          }
      };

      /**
       * Shows the scroller instance.
       * @param {Boolean} prevAnim - Prevent animation if true
       * @param {Boolean} prevFocus - Prevent focusing if true
       */
      that.show = function (prevAnim, prevFocus) {
          var hasButtons, html;

          if (s.disabled || that._isVisible) {
              return;
          }

          // Parse value from input
          that._readValue();

          if (trigger('onBeforeShow') === false) {
              return false;
          }

          $activeElm = null;

          doAnim = s.animate;
          buttons = s.buttons || [];

          needsDimensions = hasContext || s.display == 'bubble';
          needsLock = needsFixed && !needsDimensions && s.scrollLock;

          hasButtons = buttons.length > 0;

          //touched = false;

          if (doAnim !== false) {
              if (s.display == 'top') {
                  doAnim = doAnim || 'slidedown';
              } else if (s.display == 'bottom') {
                  doAnim = doAnim || 'slideup';
              } else if (s.display == 'center' || s.display == 'bubble') {
                  doAnim = doAnim || 'pop';
              }
          }

          if (isModal) {
              scrollTop = Math.max(0, $wnd.scrollTop());
              scrollLeft = Math.max(0, $wnd.scrollLeft());
              wndWidth = 0;
              wndHeight = 0;

              if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {
                  //$lock.scrollTop(0);
                  $ctx.css({
                      top: -scrollTop + 'px',
                      left: -scrollLeft + 'px'
                  });
              }

              $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : ''));

              // Hide virtual keyboard
              if ($$2(document.activeElement).is('input,textarea')) {
                  document.activeElement.blur();
              }

              // Hide active instance
              if (mobiscroll$3.activeInstance) {
                  mobiscroll$3.activeInstance.hide();
              }

              // Set active instance
              mobiscroll$3.activeInstance = that;
              ctx.mbscModals = ctx.mbscModals || 0;
              ctx.mbscLock = ctx.mbscLock || 0;
              ctx.mbscModals++;
              if (s.scrollLock) {
                  ctx.mbscLock++;
              }
          }

          // Create wheels containers
          html = '<div lang="' + s.lang + '" class="mbsc-fr mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (halfBorder$1 ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + (needsLock ? ' mbsc-platform-ios' : '') + (hasButtons ? buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '' : ' mbsc-fr-nobtn') + '">' + (isModal ? '<div class="mbsc-fr-persp"><div class="mbsc-fr-overlay"></div><div role="dialog" tabindex="-1" class="mbsc-fr-scroll">' : '') + // Overlay
          '<div class="mbsc-fr-popup' + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '">' + ( // Popup
          s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + // Bubble arrow
          '<div class="mbsc-fr-w">' + ( // Popup content
          //'<div aria-live="assertive" class="mbsc-fr-aria mbsc-fr-hdn"></div>' +
          s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
          '<div class="mbsc-fr-c">'; // Wheel group container

          html += that._generateContent();

          html += '</div>';

          if (hasButtons) {
              var b,
                  i,
                  j,
                  l = buttons.length;

              html += '<div class="mbsc-fr-btn-cont">';
              for (i = 0; i < buttons.length; i++) {
                  j = s.btnReverse ? l - i - 1 : i;
                  b = buttons[j];
                  b = isString(b) ? that.buttons[b] : b;

                  if (b.handler === 'set') {
                      b.parentClass = 'mbsc-fr-btn-s';
                  }

                  if (b.handler === 'cancel') {
                      b.parentClass = 'mbsc-fr-btn-c';
                  }

                  html += '<div' + (s.btnWidth ? ' style="width:' + 100 / buttons.length + '%"' : '') + ' class="mbsc-fr-btn-w ' + (b.parentClass || '') + '">' + '<div tabindex="0" role="button" class="mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' + (b.cssClass === undefined ? s.btnClass : b.cssClass) + (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '">' + (b.text || '') + '</div></div>';
              }
              html += '</div>';
          }
          html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');

          $markup = $$2(html);
          $persp = $$2('.mbsc-fr-persp', $markup);
          $overlay = $$2('.mbsc-fr-scroll', $markup);
          $wrapper = $$2('.mbsc-fr-w', $markup);
          $popup = $$2('.mbsc-fr-popup', $markup);
          $header = $$2('.mbsc-fr-hdr', $markup);
          //$ariaDiv = $('.mbsc-fr-aria', $markup);

          markup = $markup[0];
          overlay = $overlay[0];
          popup = $popup[0];

          that._activeElm = overlay;
          that._markup = $markup;
          that._isVisible = true;

          posEvents = 'orientationchange resize';

          that._markupReady($markup);

          trigger('onMarkupReady', {
              target: markup
          });

          // Attach events
          if (isModal) {
              // Enter / ESC
              $$2(window).on('keydown', onWndKeyDown);

              // Prevent scroll if not specified otherwise
              if (s.scrollLock) {
                  $markup.on('touchmove mousewheel wheel', function (ev) {
                      if (scrollLock) {
                          ev.preventDefault();
                      }
                  });
              }

              if (s.focusTrap) {
                  $wnd.on('focusin', onFocus);
              }

              if (s.closeOnOverlayTap) {
                  var moved, target, startX, startY;

                  $overlay.on('touchstart mousedown', function (ev) {
                      if (!target && ev.target == $overlay[0]) {
                          target = true;
                          moved = false;
                          startX = getCoord(ev, 'X');
                          startY = getCoord(ev, 'Y');
                      }
                  }).on('touchmove mousemove', function (ev) {
                      if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {
                          moved = true;
                      }
                  }).on('touchcancel', function () {
                      target = false;
                  }).on('touchend touchcancel mouseup', function (ev) {
                      if (target && !moved) {
                          that.cancel();
                          if (ev.type != 'mouseup') {
                              preventClick();
                          }
                      }
                      target = false;
                  });
              }
          }

          if (isModal && needsLock) {
              // Wait for the toolbar and addressbar to appear on iOS
              setTimeout(function () {
                  insertMarkup(prevAnim, prevFocus);
              }, 100);
          } else {
              insertMarkup(prevAnim, prevFocus);
          }
      };

      /**
       * Hides the scroller instance.
       */
      that.hide = function (prevAnim, btn, force, callback) {

          function onAnimEnd() {
              $markup.off(animEnd, onAnimEnd);
              onHide(prevAnim);
          }

          // If onClose handler returns false, prevent hide
          if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {
              valueText: that._tempValue,
              button: btn
          }) === false) {
              return false;
          }

          if (isModal) {
              if ($$2(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {
                  document.activeElement.blur();
              }
              $$2(window).off('keydown', onWndKeyDown);
              delete mobiscroll$3.activeInstance;
          }

          // Hide wheels and overlay
          if ($markup) {
              if (isModal && doAnim && !prevAnim) {
                  $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
              } else {
                  onHide(prevAnim);
              }

              that._detachEvents($markup);

              // Stop positioning on window resize
              $wnd.off(posEvents, onPosition).off('focusin', onFocus);
          }

          if (callback) {
              callback();
          }

          // For validation
          $elm.trigger('blur');

          trigger('onClose', {
              valueText: that._value
          });
      };

      // that.ariaMessage = function (txt) {
      //     $ariaDiv.html('');
      //     setTimeout(function () {
      //         $ariaDiv.html(txt);
      //     }, 100);
      // };

      /**
       * Return true if the scroller is currently visible.
       */
      that.isVisible = function () {
          return that._isVisible;
      };

      // Protected functions to override

      that.setVal = noop;

      that.getVal = noop;

      that._generateContent = noop;

      that._attachEvents = noop;

      that._detachEvents = noop;

      that._readValue = noop;

      that._clearValue = noop;

      that._fillValue = noop;

      that._markupReady = noop;

      that._markupInserted = noop;

      that._markupRemove = noop;

      that._position = noop;

      that.__processSettings = noop;

      that.__init = noop;

      that.__destroy = noop;

      // Generic frame functions

      /**
       * Destroys the mobiscroll instance.
       */
      that._destroy = function () {
          // Force hide without animation
          that.hide(true, false, true);

          $elm.off('.mbsc');

          // Remove all events from elements
          $$2.each(elmList, function (i, v) {
              v.el.off('.mbsc').prop('readonly', v.readOnly);
              if (v.lbl) {
                  v.lbl.off('.mbsc');
              }
          });

          that.__destroy();
      };

      that._updateHeader = function () {
          var t = s.headerText;
          $header.html(t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\{value\}/i, that._tempValue) : '');
      };

      that._processSettings = function () {
          var b, i;

          that.__processSettings();

          // Add default buttons
          s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []);

          // Hide header text in inline mode by default
          s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;

          buttons = s.buttons || [];
          isModal = s.display !== 'inline';
          hasContext = s.context != 'body';
          $ctx = $$2(s.context);
          $lock = hasContext ? $ctx : $$2('body,html');
          ctx = $ctx[0];

          that._$window = $wnd = $$2(hasContext ? s.context : window);
          that.live = true;

          // If no set button is found, live mode is activated
          for (i = 0; i < buttons.length; i++) {
              b = buttons[i];
              if (b == 'ok' || b == 'set' || b.handler == 'set') {
                  that.live = false;
              }
          }

          that.buttons.set = {
              text: s.setText,
              icon: s.setIcon,
              handler: 'set'
          };

          that.buttons.cancel = {
              text: s.cancelText,
              icon: s.cancelIcon,
              handler: 'cancel'
          };

          that.buttons.close = {
              text: s.closeText,
              icon: s.closeIcon,
              handler: 'cancel'
          };

          that.buttons.clear = {
              text: s.clearText,
              icon: s.clearIcon,
              handler: 'clear'
          };

          that._isInput = $elm.is('input');
      };

      /**
       * Scroller initialization.
       */
      that._init = function () {

          if (that._isVisible) {
              that.hide(true, false, true);
          }

          // Unbind all events (if re-init)
          $elm.off('.mbsc');

          that.__init();

          that._isLiquid = s.layout == 'liquid';

          if (isModal) {
              that._readValue();
              if (!that._hasContent) {
                  that.attachShow($elm);
              }
          } else {
              that.show();
          }

          $elm.on('change.mbsc', function () {
              if (!that._preventChange) {
                  that.setVal($elm.val(), true, false);
              }
              that._preventChange = false;
          }).removeClass('mbsc-cloak');
      };

      that.buttons = {};
      that.handlers = {
          set: that.select,
          cancel: that.cancel,
          clear: that.clear
      };

      that._value = null;

      that._isValid = true;
      that._isVisible = false;

      // Constructor

      s = that.settings;
      trigger = that.trigger;

      if (!inherit) {
          that.init(settings);
      }
  };

  Frame.prototype._defaults = {
      // Localization
      lang: 'en',
      setText: 'Set',
      selectedText: '{count} selected',
      closeText: 'Close',
      cancelText: 'Cancel',
      clearText: 'Clear',
      // Options
      context: 'body',
      maxPopupWidth: 600,
      disabled: false,
      closeOnOverlayTap: true,
      showOnFocus: isAndroid || isIOS, // Needed for ion-input
      showOnTap: true,
      display: 'center',
      scroll: true,
      scrollLock: true,
      tap: true,
      btnClass: 'mbsc-fr-btn',
      btnWidth: true,
      focusTrap: true,
      focusOnClose: !isIOS8 // Temporary for iOS8
  };

  classes.Frame = Frame;

  themes.frame.mobiscroll = {
      headerText: false,
      btnWidth: false
  };

  themes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {
      rows: 5,
      showLabel: false,
      selectedLineBorder: 1,
      weekDays: 'min',
      checkIcon: 'ion-ios7-checkmark-empty',
      btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
      btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
      btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
      btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'
  });

  if (isBrowser) {
      // Prevent re-show on window focus
      $$2(window).on('focus', function () {
          if ($activeElm) {
              preventShow = true;
          }
      });
  }

  var Widget = function Widget(el, settings, inherit) {

      function addContent($m) {
          /* TRIAL */

          if (!$$2('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c') /* TRIALCOND */) {
                  $$2('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());

                  if (!$$2('.mbsc-w-p', $m).length) {
                      $$2('.mbsc-fr-c', $m).addClass('mbsc-w-p');
                  }
              }
      }

      var s,
          $parent,
          $prev,
          $elm = $$2(el),
          that = this;

      // Call the parent constructor
      Frame.call(this, el, settings, true);

      /* TRIALFUNC */

      that._generateContent = function () {
          return '';
      };

      that._markupReady = function ($m) {
          if (s.display != 'inline') {
              addContent($m);
          }
      };

      that._markupInserted = function ($m) {

          if (s.display == 'inline') {
              addContent($m);
          }

          $m.trigger('mbsc-enhance', [{
              theme: s.theme,
              lang: s.lang
          }]);
      };

      that._markupRemove = function () {
          $elm.hide();

          if ($parent) {
              $parent.prepend($elm);
          } else {
              $prev.after($elm);
          }
      };

      that.__processSettings = function () {
          s = that.settings;

          that.buttons.ok = {
              text: s.okText,
              icon: s.okIcon,
              handler: 'set'
          };

          s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);

          if (!$parent && !$prev) {
              $prev = $elm.prev();

              if (!$prev.length) {
                  $parent = $elm.parent();
              }
          }

          $elm.hide();
      };

      that.__init = function () {
          s.cssClass = (s.cssClass || '') + ' mbsc-wdg';
      };

      // Constructor
      if (!inherit) {
          that.init(settings);
      }
  };

  Widget.prototype = {
      _hasDef: true,
      _hasTheme: true,
      _hasContent: true,
      _hasLang: true,
      _class: 'widget',
      _defaults: extend$1({}, Frame.prototype._defaults, {
          okText: 'OK',
          headerText: false
      })
  };

  classes.Widget = Widget;

  mobiscroll$3.themes.widget = mobiscroll$3.themes.frame;

  var hasPromise = isBrowser && !!window.Promise;
  var popupQueue = [];
  var notificationQueue = [];

  function showPopup(popup) {
      if (!popupQueue.length) {
          popup.show();
      }
      popupQueue.push(popup);
  }

  function showNotification(notification) {
      var isAny = notificationQueue.length;
      notificationQueue.push(notification);
      // Only show notification if no popup is visible
      // otherwise postpone it until popup is closed
      if (!popupQueue.length) {
          // If there's a visible notification, hide it.
          // The notification will be shown after hide animation is complete
          if (isAny) {
              notificationQueue[0].hide();
          } else {
              // Prevent focus on show for notifications
              notification.show(false, true);
          }
      }
  }

  function getSettings(queue, settings, resolve, more) {
      //const active = mobiscroll.activeInstance;
      return extend$1({
          display: settings.display || 'center',
          cssClass: 'mbsc-alert',
          okText: settings.okText,
          cancelText: settings.cancelText,
          context: settings.context,
          theme: settings.theme,
          closeOnOverlayTap: false,
          onBeforeClose: function onBeforeClose() {
              queue.shift();
          },
          onBeforeShow: function onBeforeShow() {
              // If there's an active mobiscroll picker on screen,
              // prevent from being hidden when 
              // popup is shown
              mobiscroll$3.activeInstance = null;
          },
          onHide: function onHide(ev, inst) {
              //mobiscroll.activeInstance = active;
              if (resolve) {
                  resolve(inst._resolve);
              }
              if (settings.callback) {
                  settings.callback(inst._resolve);
              }
              if (inst) {
                  inst.destroy();
              }
              // Show next
              if (popupQueue.length) {
                  popupQueue[0].show();
              } else if (notificationQueue.length) {
                  // Prevent focus on show for notifications
                  notificationQueue[0].show(false, true);
              }
          }
      }, more);
  }

  function getMessage(settings) {
      return (settings.title ? '<h2>' + settings.title + '</h2>' : '') + '<p>' + (settings.message || '') + '</p>';
  }

  function showAlert(widget, settings, resolve) {
      var inst = new Widget(widget, getSettings(popupQueue, settings, resolve));
      showPopup(inst);
  }

  function showConfirm(widget, settings, resolve) {
      var inst = new Widget(widget, getSettings(popupQueue, settings, resolve, {
          buttons: ['cancel', 'ok'],
          onSet: function onSet() {
              inst._resolve = true;
          }
      }));
      inst._resolve = false;
      showPopup(inst);
  }

  function showPrompt(widget, settings, resolve) {
      var input = void 0;
      var inst = new Widget(widget, getSettings(popupQueue, settings, resolve, {
          buttons: ['cancel', 'ok'],
          onMarkupReady: function onMarkupReady(event, inst) {
              input = inst._markup.find('input')[0];
              setTimeout(function () {
                  input.focus();
                  input.setSelectionRange(0, input.value.length);
              }, 300);
          },
          onSet: function onSet() {
              inst._resolve = input.value;
          }
      }));
      inst._resolve = null;
      showPopup(inst);
  }

  function showSnackbar(widget, settings, resolve, cssClass, animation) {
      var notificationTimer = void 0;
      var inst = new Widget(widget, getSettings(notificationQueue, settings, resolve, {
          display: 'bottom',
          animate: animation,
          cssClass: cssClass || 'mbsc-snackbar',
          scrollLock: false,
          focusTrap: false,
          buttons: [],
          onShow: function onShow(ev, inst) {
              if (settings.duration !== false) {
                  notificationTimer = setTimeout(function () {
                      if (inst) {
                          inst.hide();
                      }
                  }, settings.duration || 3000);
              }
              if (settings.button) {
                  inst.tap($$2('.mbsc-snackbar-btn', ev.target), function () {
                      inst.hide();
                      if (settings.button.action) {
                          settings.button.action.call(this);
                      }
                  });
              }
          },
          onClose: function onClose() {
              clearTimeout(notificationTimer);
          }
      }));
      showNotification(inst);
  }

  function showToast(widget, settings, resolve) {
      showSnackbar(widget, settings, resolve, 'mbsc-toast', 'fade');
  }

  function show(func, widget, settings) {
      var p = void 0;
      if (hasPromise) {
          p = new Promise(function (resolve) {
              func(widget, settings, resolve);
          });
      } else {
          func(widget, settings);
      }
      return p;
  }

  mobiscroll$3.alert = function (settings) {
      var widget = document.createElement('div');
      widget.innerHTML = getMessage(settings);
      return show(showAlert, widget, settings);
  };

  mobiscroll$3.confirm = function (settings) {
      var widget = document.createElement('div');
      widget.innerHTML = getMessage(settings);
      return show(showConfirm, widget, settings);
  };

  mobiscroll$3.prompt = function (settings) {
      var widget = document.createElement('div');
      widget.innerHTML = getMessage(settings) + '<label class="mbsc-input">' + (settings.label ? '<span class="mbsc-label">' + settings.label + '</span>' : '') + '<input tabindex="0" type="' + (settings.inputType || 'text') + '" placeholder="' + (settings.placeholder || '') + '" value="' + (settings.value || '') + '">' + '</label>';
      return show(showPrompt, widget, settings);
  };

  mobiscroll$3.snackbar = function (settings) {
      var widget = document.createElement('div');
      widget.innerHTML = '<div class="mbsc-snackbar-cont"><div class="mbsc-snackbar-msg">' + (settings.message || '') + '</div>' + (settings.button ? '<button class="mbsc-snackbar-btn mbsc-btn mbsc-btn-flat">' + (settings.button.text || '') + '</button>' : '') + '</div>';
      return show(showSnackbar, widget, settings);
  };

  mobiscroll$3.toast = function (settings) {
      var widget = document.createElement('div');
      widget.innerHTML = '<div class="mbsc-toast-msg">' + (settings.message || '') + '</div>';
      return show(showToast, widget, settings);
  };

  var halfBorder = os == 'ios' && majorVersion > 7;

  var Form = function Form(el, settings) {

      var s,
          cssClass = '',
          $ctx = $$2(el),
          controls = {},
          that = this;

      function touched() {
          $ctx.removeClass('mbsc-no-touch');
      }

      // Call the parent constructor
      Base.call(this, el, settings, true);

      that.refresh = function (shallow) {
          initControls($ctx, controls, s, shallow);
      };

      /**
       * Form initialization.
       */
      that._init = function () {
          if (!mobiscroll$3.themes.form[s.theme]) {
              s.theme = 'mobiscroll';
          }

          if (!$ctx.hasClass('mbsc-form')) {
              $ctx.on('touchstart', touched).show();
          }

          if (cssClass) {
              $ctx.removeClass(cssClass);
          }

          // --- TRIAL SERVER CODE START ---
          cssClass = 'mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
          // --- TRIAL SERVER CODE END ---

          $ctx.addClass(cssClass).removeClass('mbsc-cloak');

          that.refresh();
      };

      /**
       * Destroys the mobiscroll instance.
       */
      that._destroy = function () {
          $ctx.removeClass(cssClass).off('touchstart', touched);

          for (var id in controls) {
              controls[id].destroy();
          }
      };

      // Constructor

      s = that.settings;

      that.init(settings);
  };

  // Extend defaults
  Form.prototype = {
      _hasDef: true,
      _hasTheme: true,
      _hasLang: true,
      _class: 'form',
      _defaults: {
          tap: true,
          stopProp: true,
          // Localization
          lang: 'en'
      }
  };

  mobiscroll$3.themes.form.mobiscroll = {};

  classes.Form = Form;

  // Init mbsc-form elements on page load
  autoInit('[mbsc-enhance],[mbsc-form]', Form, true);

  // Page
  // ---

  var Page = function Page(el, settings) {
      var cssClass = '',
          $elm = $$2(el),
          that = this,
          s = that.settings;

      // Call the parent constructor
      Base.call(this, el, settings, true);

      /**
       * Page initialization.
       */
      that._init = function () {
          var ctx = s.context,
              $ctx = $$2(ctx),
              $topMenu = $ctx.find('.mbsc-ms-top .mbsc-ms'),
              $bottomMenu = $ctx.find('.mbsc-ms-bottom .mbsc-ms'),
              css = {};

          if (ctx == 'body') {
              $$2('body,html').addClass('mbsc-page-ctx');
          } else {
              $ctx.addClass('mbsc-page-ctx');
          }

          if (cssClass) {
              $elm.removeClass(cssClass);
          }

          if ($topMenu.length) {
              css.paddingTop = $topMenu[0].offsetHeight;
          }

          if ($bottomMenu.length) {
              css.paddingBottom = $bottomMenu[0].offsetHeight;
          }

          cssClass = 'mbsc-page mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');

          $elm.addClass(cssClass).removeClass('mbsc-cloak').css(css);
      };

      /**
       * Destroys the mobiscroll instance.
       */
      that._destroy = function () {
          $elm.removeClass(cssClass);
      };

      // Constructor

      s = that.settings;

      that.init(settings);
  };

  // Extend defaults
  Page.prototype = {
      _hasDef: true,
      _hasTheme: true,
      _hasLang: true,
      _class: 'page',
      _defaults: {
          context: 'body'
      }
  };

  classes.Page = Page;

  mobiscroll$3.themes.page.mobiscroll = {};

  // ---
  // Page end

  // Init mbsc-page elements on page load or when mbsc-enhance event is triggeres
  autoInit('[mbsc-page]', Page);

  var _class2$1;
  var _temp$2;

  var _extends$3 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
              }
          }
      }return target;
  };

  var MbscPage = function (_MbscOptimized) {
      inherits(MbscPage, _MbscOptimized);

      function MbscPage(props) {
          classCallCheck(this, MbscPage);

          var _this = possibleConstructorReturn(this, (MbscPage.__proto__ || Object.getPrototypeOf(MbscPage)).call(this, props));

          _this.componentDidMount = function () {
              // get settings from state
              var settings = extend$1({}, _this.state.options);
              // initialize the mobiscroll
              _this.instance = new Page(ReactDOM.findDOMNode(_this), settings);
          };

          _this.render = function () {
              return React.createElement('div', { className: _this.initialCssClass }, _this.props.children);
          };
          return _this;
      }

      return MbscPage;
  }(MbscOptimized);

  MbscPage.propTypes = _extends$3({}, MbscPage.propTypes, CorePropTypes, {
      onInit: PropTypes.func
  });

  var MbscNote = (_temp$2 = _class2$1 = function (_React$Component) {
      inherits(MbscNote, _React$Component);

      function MbscNote(props) {
          classCallCheck(this, MbscNote);

          var _this2 = possibleConstructorReturn(this, (MbscNote.__proto__ || Object.getPrototypeOf(MbscNote)).call(this, props));

          _this2.render = function () {
              var className = 'mbsc-note mbsc-note-' + _this2.props.color;
              return React.createElement('div', { className: className }, _this2.props.children);
          };
          return _this2;
      }

      return MbscNote;
  }(React.Component), _class2$1.propTypes = {
      color: PropTypes.string
  }, _class2$1.defaultProps = {
      color: 'primary'
  }, _temp$2);
  var MbscAvatar = function (_React$Component2) {
      inherits(MbscAvatar, _React$Component2);

      function MbscAvatar(props) {
          classCallCheck(this, MbscAvatar);

          var _this3 = possibleConstructorReturn(this, (MbscAvatar.__proto__ || Object.getPrototypeOf(MbscAvatar)).call(this, props));

          _this3.render = function () {
              return React.createElement('img', { className: 'mbsc-avatar', src: _this3.props.src, alt: _this3.props.alt });
          };
          return _this3;
      }

      return MbscAvatar;
  }(React.Component);

  mobiscroll$3.Page = MbscPage;
  mobiscroll$3.Note = MbscNote;
  mobiscroll$3.Avatar = MbscAvatar;

  var _extends$2 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
              }
          }
      }return target;
  };

  var _class$1;
  var _temp$1;
  var _class2;
  var _temp2;
  var _class3;
  var _temp3$1;
  var _class4$1;
  var _temp4;
  var _class5$1;
  var _temp5$1;
  var _class6;
  var _temp6;
  var _class7;
  var _temp7;
  var _class8;
  var _temp8;
  var _class9;
  var _temp9;
  var _class10;
  var _temp10;
  var _class11;
  var _temp11;
  var _class12;
  var _temp12;
  var _class13;
  var _temp13;

  function _objectWithoutProperties$1(obj, keys) {
      var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
      }return target;
  }

  var reactNumber = PropTypes.number;
  var reactString = PropTypes.string;
  var reactFunc = PropTypes.func;
  var reactBool = PropTypes.bool;

  /** PropTypes for Form components */
  var StepperPropTypes = {
      onInit: reactFunc,
      onChange: reactFunc,
      value: reactNumber,
      disabled: reactBool,
      min: reactNumber,
      max: reactNumber,
      step: reactNumber,
      val: PropTypes.oneOf(['left', 'right'])
  };

  var SwitchPropTypes = {
      onInit: reactFunc,
      onChange: reactFunc,
      checked: reactBool,
      disabled: reactBool,
      value: reactBool
  };

  var MbscForm = (_temp$1 = _class$1 = function (_MbscOptimized) {
      inherits(MbscForm, _MbscOptimized);

      function MbscForm(props) {
          classCallCheck(this, MbscForm);

          var _this = possibleConstructorReturn(this, (MbscForm.__proto__ || Object.getPrototypeOf(MbscForm)).call(this, props));

          _this.componentDidMount = function () {
              // get settings from state
              var settings = extend$1({}, _this.state.options);
              // initialize the mobiscroll
              _this.instance = new Form(ReactDOM.findDOMNode(_this), settings);
          };

          _this.componentDidUpdate = function () {
              if (!_this.optimizeUpdate.updateOptions && _this.optimizeUpdate.updateChildren) {
                  _this.instance.refresh(true);
              } else if (_this.optimizeUpdate.updateOptions) {
                  var settings = extend$1({}, _this.state.options);
                  _this.instance.option(settings);
              }
          };

          _this.checkFormWrapper = function (component) {
              if (React.Children.count(component.props.children) == 1) {
                  return component.props.children.type == 'form';
              }
              return false;
          };

          _this.render = function () {
              // passing through some of the element properties to its children
              var _props = _this.props,
                  action = _props.action,
                  method = _props.method,
                  noValidate = _props.noValidate,
                  renderForm = _props.renderForm,
                  name = _props.name,
                  target = _props.target,
                  autoComplete = _props.autoComplete,
                  onSubmit = _props.onSubmit;

              if (_this.checkFormWrapper(_this) || !renderForm) {
                  return _this.props.children;
              } else {
                  return React.createElement('form', { className: _this.initialCssClass, action: action, name: name, target: target, method: method, autoComplete: autoComplete, noValidate: noValidate, onSubmit: onSubmit }, _this.props.children);
              }
          };
          return _this;
      }

      return MbscForm;
  }(MbscOptimized), _class$1.defaultProps = {
      renderForm: true
  }, _class$1.propTypes = _extends$2({}, CorePropTypes, {
      onInit: reactFunc
  }), _temp$1);

  mobiscroll$3.Form = MbscForm;

  var MbscLabel = (_temp2 = _class2 = function (_React$Component) {
      inherits(MbscLabel, _React$Component);

      function MbscLabel(props) {
          classCallCheck(this, MbscLabel);

          var _this2 = possibleConstructorReturn(this, (MbscLabel.__proto__ || Object.getPrototypeOf(MbscLabel)).call(this, props));

          _this2.render = function () {
              /* eslint-disable no-unused-vars */
              // justification: variable 'valid' and 'className' is declared due to object decomposition
              var _props2 = _this2.props,
                  valid = _props2.valid,
                  className = _props2.className,
                  color = _props2.color,
                  children = _props2.children,
                  presetName = _props2.presetName,
                  other = _objectWithoutProperties$1(_props2, ['valid', 'className', 'color', 'children', 'presetName']);

              /* eslint-enable */

              var presetClass = '';
              if (color) {
                  presetClass = 'mbsc-' + presetName + '-' + color;
              }
              var cssClass = presetClass + (_this2.initialCssClass ? ' ' : '') + _this2.initialCssClass;
              return React.createElement('label', _extends$2({ className: cssClass }, other), children);
          };

          _this2.componentWillReceiveProps = function (nextProps) {
              var currentClasses = (_this2.state.cssClasses || '') + (_this2.props.valid === undefined || _this2.props.valid ? '' : ' mbsc-err'),
                  nextClasses = (nextProps.className || '') + (_this2.props.valid === undefined || nextProps.valid ? '' : ' mbsc-err');
              if (currentClasses != nextClasses || nextProps.valid != _this2.props.valid) {
                  updateCssClasses.call(_this2, currentClasses, nextClasses);
              }
              if (_this2.state.cssClasses !== nextProps.cssClasses) {
                  _this2.setState({
                      cssClasses: nextProps.className
                  });
              }
          };

          _this2.initialCssClass = (_this2.props.className || '') + (_this2.props.valid === undefined || _this2.props.valid ? '' : ' mbsc-err');
          _this2.state = {
              cssClasses: _this2.props.className || ''
          };
          return _this2;
      }

      return MbscLabel;
  }(React.Component), _class2.propTypes = {
      valid: PropTypes.bool,
      color: PropTypes.string,
      presetName: PropTypes.string
  }, _temp2);

  mobiscroll$3.Form.Label = MbscLabel; // for backward compatibilty
  mobiscroll$3.Label = MbscLabel;

  var MbscInput = (_temp3$1 = _class3 = function (_MbscInit) {
      inherits(MbscInput, _MbscInit);

      function MbscInput(props) {
          classCallCheck(this, MbscInput);

          var _this3 = possibleConstructorReturn(this, (MbscInput.__proto__ || Object.getPrototypeOf(MbscInput)).call(this, props));

          _this3.componentDidMount = function () {
              var settings = extend$1({}, _this3.state.options);
              _this3.instance = new Input(_this3.inputNode, settings);
          };

          _this3.inputMounted = function (input) {
              _this3.inputNode = input;
          };

          _this3.render = function () {
              var _props3 = _this3.props,
                  valid = _props3.valid,
                  errorMessage = _props3.errorMessage,
                  type = _props3.type,
                  icon = _props3.icon,
                  iconAlign = _props3.iconAlign,
                  passwordToggle = _props3.passwordToggle,
                  iconShow = _props3.iconShow,
                  iconHide = _props3.iconHide,
                  children = _props3.children,
                  other = _objectWithoutProperties$1(_props3, ['valid', 'errorMessage', 'type', 'icon', 'iconAlign', 'passwordToggle', 'iconShow', 'iconHide', 'children']);

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              }

              type = type || 'text';

              return React.createElement(MbscLabel, { valid: valid }, children, React.createElement('span', { className: 'mbsc-input-wrap' }, React.createElement('input', _extends$2({ ref: _this3.inputMounted, type: type, 'data-icon': icon, 'data-icon-align': iconAlign, 'data-password-toggle': passwordToggle, 'data-icon-show': iconShow, 'data-icon-hide': iconHide }, other)), error));
          };
          return _this3;
      }

      return MbscInput;
  }(MbscInit), _class3.propTypes = {
      disabled: PropTypes.bool,
      valid: PropTypes.bool,
      errorMessage: PropTypes.string,
      type: PropTypes.string,
      icon: PropTypes.string,
      iconAlign: PropTypes.string,
      passwordToggle: PropTypes.bool,
      iconShow: PropTypes.string,
      iconHide: PropTypes.string,
      name: PropTypes.string
  }, _temp3$1);

  mobiscroll$3.Input = MbscInput;

  var MbscTextArea = (_temp4 = _class4$1 = function (_MbscInit2) {
      inherits(MbscTextArea, _MbscInit2);

      function MbscTextArea(props) {
          classCallCheck(this, MbscTextArea);

          var _this4 = possibleConstructorReturn(this, (MbscTextArea.__proto__ || Object.getPrototypeOf(MbscTextArea)).call(this, props));

          _this4.componentDidMount = function () {
              var settings = extend$1({}, _this4.state.options);
              _this4.instance = new TextArea(_this4.inputNode, settings);
          };

          _this4.textMounted = function (input) {
              _this4.inputNode = input;
          };

          _this4.render = function () {
              var _props4 = _this4.props,
                  valid = _props4.valid,
                  errorMessage = _props4.errorMessage,
                  icon = _props4.icon,
                  iconAlign = _props4.iconAlign,
                  children = _props4.children,
                  other = _objectWithoutProperties$1(_props4, ['valid', 'errorMessage', 'icon', 'iconAlign', 'children']);

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              }

              return React.createElement(MbscLabel, { valid: valid }, children, React.createElement('span', { className: 'mbsc-input-wrap' }, React.createElement('textarea', _extends$2({ ref: _this4.textMounted, 'data-icon': icon, 'data-icon-align': iconAlign }, other)), error));
          };
          return _this4;
      }

      return MbscTextArea;
  }(MbscInit), _class4$1.propTypes = {
      disabled: PropTypes.bool,
      valid: PropTypes.bool,
      errorMessage: PropTypes.string,
      icon: PropTypes.string,
      iconAlign: PropTypes.string,
      name: PropTypes.string
  }, _temp4);

  mobiscroll$3.Textarea = MbscTextArea;

  var MbscDropdown = (_temp5$1 = _class5$1 = function (_MbscInit3) {
      inherits(MbscDropdown, _MbscInit3);

      function MbscDropdown(props) {
          classCallCheck(this, MbscDropdown);

          var _this5 = possibleConstructorReturn(this, (MbscDropdown.__proto__ || Object.getPrototypeOf(MbscDropdown)).call(this, props));

          _this5.componentDidMount = function () {
              var settings = extend$1({}, _this5.state.options);
              _this5.instance = new Select(_this5.selectNode, settings);
          };

          _this5.selectMounted = function (select) {
              _this5.selectNode = select;
          };

          _this5.componentDidUpdate = function () {
              _this5.instance._setText();
          };

          _this5.render = function () {
              var _props5 = _this5.props,
                  label = _props5.label,
                  valid = _props5.valid,
                  errorMessage = _props5.errorMessage,
                  icon = _props5.icon,
                  iconAlign = _props5.iconAlign,
                  children = _props5.children,
                  other = _objectWithoutProperties$1(_props5, ['label', 'valid', 'errorMessage', 'icon', 'iconAlign', 'children']);

              var error = null;
              if (errorMessage && !valid) {
                  error = React.createElement('span', { className: 'mbsc-err-msg' }, errorMessage);
              } else {
                  error = React.createElement('span', null);
              }

              return React.createElement(MbscLabel, { valid: valid }, label, React.createElement('span', { className: 'mbsc-input-wrap' }, React.createElement('select', _extends$2({ ref: _this5.selectMounted, 'data-icon': icon, 'data-icon-align': iconAlign }, other), children), error));
          };
          return _this5;
      }

      return MbscDropdown;
  }(MbscInit), _class5$1.propTypes = {
      label: PropTypes.string,
      disabled: PropTypes.bool,
      valid: PropTypes.bool,
      errorMessage: PropTypes.string,
      icon: PropTypes.string,
      iconAlign: PropTypes.string,
      name: PropTypes.string
  }, _temp5$1);

  mobiscroll$3.Dropdown = MbscDropdown;

  var MbscButton = (_temp6 = _class6 = function (_MbscInit4) {
      inherits(MbscButton, _MbscInit4);

      function MbscButton(props) {
          classCallCheck(this, MbscButton);

          var _this6 = possibleConstructorReturn(this, (MbscButton.__proto__ || Object.getPrototypeOf(MbscButton)).call(this, props));

          _this6.componentDidMount = function () {
              var settings = extend$1({}, _this6.state.options);
              _this6.instance = new Button(_this6.btnNode, settings);
          };

          _this6.btnMounted = function (btn) {
              _this6.btnNode = btn;
          };

          _this6.render = function () {
              var _props6 = _this6.props,
                  type = _props6.type,
                  children = _props6.children,
                  color = _props6.color,
                  flat = _props6.flat,
                  block = _props6.block,
                  outline = _props6.outline,
                  icon = _props6.icon,
                  other = _objectWithoutProperties$1(_props6, ['type', 'children', 'color', 'flat', 'block', 'outline', 'icon']);

              type = type || 'button';

              var cssClass = '';
              if (flat) {
                  cssClass += ' mbsc-btn-flat';
              }
              if (block) {
                  cssClass += ' mbsc-btn-block';
              }
              if (outline) {
                  cssClass += ' mbsc-btn-outline';
              }
              if (color) {
                  cssClass += ' mbsc-btn-' + color;
              }
              if (_this6.initialCssClass) {
                  cssClass += ' ' + _this6.initialCssClass;
              }
              cssClass = cssClass.trim();

              return React.createElement('button', _extends$2({ className: cssClass, ref: _this6.btnMounted, type: type, 'data-icon': icon }, other), children);
          };
          return _this6;
      }

      return MbscButton;
  }(MbscInit), _class6.propTypes = {
      type: PropTypes.string,
      color: PropTypes.string,
      flat: PropTypes.bool,
      block: PropTypes.bool,
      outline: PropTypes.bool,
      icon: PropTypes.string,
      disabled: PropTypes.bool,
      name: PropTypes.string
  }, _temp6);

  mobiscroll$3.Button = MbscButton;

  var MbscCheckbox = (_temp7 = _class7 = function (_MbscInit5) {
      inherits(MbscCheckbox, _MbscInit5);

      function MbscCheckbox(props) {
          classCallCheck(this, MbscCheckbox);

          var _this7 = possibleConstructorReturn(this, (MbscCheckbox.__proto__ || Object.getPrototypeOf(MbscCheckbox)).call(this, props));

          _this7.componentDidMount = function () {
              var settings = extend$1({}, _this7.state.options);
              _this7.instance = new CheckBox(_this7.inputNode, settings);
          };

          _this7.inputMounted = function (inp) {
              _this7.inputNode = inp;
          };

          _this7.render = function () {
              var _props7 = _this7.props,
                  color = _props7.color,
                  children = _props7.children,
                  other = _objectWithoutProperties$1(_props7, ['color', 'children']);

              return React.createElement(MbscLabel, { color: color, presetName: 'checkbox' }, React.createElement('input', _extends$2({ ref: _this7.inputMounted, type: 'checkbox' }, other)), children);
          };
          return _this7;
      }

      return MbscCheckbox;
  }(MbscInit), _class7.propTypes = {
      color: PropTypes.string,
      disabled: PropTypes.bool,
      name: PropTypes.string
  }, _temp7);

  mobiscroll$3.Checkbox = MbscCheckbox;

  var MbscRadio = (_temp8 = _class8 = function (_MbscInit6) {
      inherits(MbscRadio, _MbscInit6);

      function MbscRadio(props) {
          classCallCheck(this, MbscRadio);

          var _this8 = possibleConstructorReturn(this, (MbscRadio.__proto__ || Object.getPrototypeOf(MbscRadio)).call(this, props));

          _this8.componentDidMount = function () {
              var settings = extend$1({}, _this8.state.options);
              _this8.instance = new Radio(_this8.inputNode, settings);
          };

          _this8.inputMounted = function (inp) {
              _this8.inputNode = inp;
          };

          _this8.render = function () {
              var _props8 = _this8.props,
                  color = _props8.color,
                  children = _props8.children,
                  other = _objectWithoutProperties$1(_props8, ['color', 'children']);

              return React.createElement(MbscLabel, { color: color, presetName: 'radio' }, React.createElement('input', _extends$2({ ref: _this8.inputMounted, type: 'radio' }, other)), children);
          };
          return _this8;
      }

      return MbscRadio;
  }(MbscInit), _class8.propTypes = {
      color: PropTypes.string,
      name: PropTypes.string,
      disabled: PropTypes.bool
  }, _temp8);

  mobiscroll$3.Radio = MbscRadio;

  var MbscSegmented = (_temp9 = _class9 = function (_MbscInit7) {
      inherits(MbscSegmented, _MbscInit7);

      function MbscSegmented(props) {
          classCallCheck(this, MbscSegmented);

          var _this9 = possibleConstructorReturn(this, (MbscSegmented.__proto__ || Object.getPrototypeOf(MbscSegmented)).call(this, props));

          _this9.componentDidMount = function () {
              var settings = extend$1({}, _this9.state.options);
              _this9.instance = new SegmentedItem(_this9.inputNode, settings);
          };

          _this9.inputMounted = function (inp) {
              _this9.inputNode = inp;
          };

          _this9.render = function () {
              var _props9 = _this9.props,
                  color = _props9.color,
                  children = _props9.children,
                  multiSelect = _props9.multiSelect,
                  icon = _props9.icon,
                  other = _objectWithoutProperties$1(_props9, ['color', 'children', 'multiSelect', 'icon']);

              var type = multiSelect ? 'checkbox' : 'radio';
              return React.createElement(MbscLabel, { color: color, presetName: 'segmented' }, React.createElement('input', _extends$2({ ref: _this9.inputMounted, type: type, 'data-icon': icon, 'data-role': 'segmented' }, other)), children);
          };
          return _this9;
      }

      return MbscSegmented;
  }(MbscInit), _class9.propTypes = {
      color: PropTypes.string,
      name: PropTypes.string,
      disabled: PropTypes.bool,
      multiSelect: PropTypes.bool,
      icon: PropTypes.string
  }, _temp9);

  mobiscroll$3.Segmented = MbscSegmented;

  var MbscFormBase = (_temp10 = _class10 = function (_MbscOptimized2) {
      inherits(MbscFormBase, _MbscOptimized2);

      function MbscFormBase(props, presetName) {
          classCallCheck(this, MbscFormBase);

          var _this10 = possibleConstructorReturn(this, (MbscFormBase.__proto__ || Object.getPrototypeOf(MbscFormBase)).call(this, props));

          _this10.componentDidMount = function () {
              // get settings from state
              var settings = extend$1({}, _this10.mbscInit, _this10.state.options);

              // initialize the mobiscroll
              _this10.instance = new classes[_this10.mbscInit.component || 'Scroller'](_this10.inputNode, settings);

              if (_this10.state.value !== undefined) {
                  _this10.instance.setVal(_this10.state.value, true);
              }

              // Add change event listener if handler is passed
              $$2(_this10.inputNode).on('change', _this10.props.onChange || function () {});
          };

          _this10.inputMounted = function (input) {
              _this10.inputNode = input;
          };

          _this10.render = function () {
              /* eslint-disable no-unused-vars */
              // justification: variables 'value', 'onChange' and 'className' are declared due to object decomposition
              var _props10 = _this10.props,
                  className = _props10.className,
                  children = _props10.children,
                  value = _props10.value,
                  onChange = _props10.onChange,
                  name = _props10.name,
                  color = _props10.color,
                  other = _objectWithoutProperties$1(_props10, ['className', 'children', 'value', 'onChange', 'name', 'color']);

              /* eslint-enable no-unused-vars */

              var presetClass = '';
              if (color) {
                  presetClass = 'mbsc-' + _this10.presetName + '-' + color;
              }
              var type = _this10.inputType || 'text';

              return React.createElement('div', { className: presetClass + (_this10.initialCssClass ? ' ' + _this10.initialCssClass : '') }, children, React.createElement('input', _extends$2({ ref: _this10.inputMounted, type: type, 'data-role': name }, other)));
          };

          _this10.presetName = presetName;
          return _this10;
      }

      return MbscFormBase;
  }(MbscOptimized), _class10.propTypes = _extends$2({}, CorePropTypes, {
      color: reactString
  }), _temp10);
  var MbscSwitch = function (_MbscFormBase) {
      inherits(MbscSwitch, _MbscFormBase);

      function MbscSwitch(props) {
          classCallCheck(this, MbscSwitch);

          var _this11 = possibleConstructorReturn(this, (MbscSwitch.__proto__ || Object.getPrototypeOf(MbscSwitch)).call(this, props, 'switch'));

          _this11.mbscInit = {
              component: 'Switch'
          };
          _this11.inputType = 'checkbox';
          return _this11;
      }

      return MbscSwitch;
  }(MbscFormBase);

  MbscSwitch.propTypes = _extends$2({}, MbscSwitch.propTypes, SwitchPropTypes);

  mobiscroll$3.Switch = MbscSwitch;

  var MbscStepper = function (_MbscFormBase2) {
      inherits(MbscStepper, _MbscFormBase2);

      function MbscStepper(props) {
          classCallCheck(this, MbscStepper);

          var _this12 = possibleConstructorReturn(this, (MbscStepper.__proto__ || Object.getPrototypeOf(MbscStepper)).call(this, props, 'stepper'));

          _this12.mbscInit = {
              component: 'Stepper'
          };
          return _this12;
      }

      return MbscStepper;
  }(MbscFormBase);

  MbscStepper.propTypes = _extends$2({}, MbscStepper.propTypes, StepperPropTypes);

  mobiscroll$3.Stepper = MbscStepper;

  // progress

  var MbscProgress = (_temp11 = _class11 = function (_MbscOptimized3) {
      inherits(MbscProgress, _MbscOptimized3);

      function MbscProgress(props) {
          classCallCheck(this, MbscProgress);

          var _this13 = possibleConstructorReturn(this, (MbscProgress.__proto__ || Object.getPrototypeOf(MbscProgress)).call(this, props));

          _this13.componentDidMount = function () {
              // get settings from state
              var settings = extend$1({}, _this13.state.options);
              // initialize the mobiscroll
              _this13.instance = new Progress(_this13.progressNode, settings);
              if (_this13.state.value !== undefined) {
                  _this13.instance.setVal(_this13.state.value, true);
              }
          };

          _this13.progressMounted = function (progress) {
              _this13.progressNode = progress;
          };

          _this13.render = function () {
              /* eslint-disable no-unused-vars */
              // justification: variable 'value' and 'className' is defined due to object decomposotion
              var _props11 = _this13.props,
                  className = _props11.className,
                  children = _props11.children,
                  value = _props11.value,
                  color = _props11.color,
                  other = _objectWithoutProperties$1(_props11, ['className', 'children', 'value', 'color']);

              /* eslint-enable no-unused-vars */

              var presetClass = '';
              if (color) {
                  presetClass = 'mbsc-progress-' + color;
              }
              var cssClass = presetClass + (_this13.initialCssClass ? ' ' + _this13.initialCssClass : '');
              return React.createElement('div', { className: cssClass }, children, React.createElement('progress', _extends$2({ ref: _this13.progressMounted }, other)));
          };
          return _this13;
      }

      return MbscProgress;
  }(MbscOptimized), _class11.propTypes = _extends$2({}, CorePropTypes, {
      "data-icon": reactString,
      "data-icon-align": PropTypes.oneOf(['left', 'right']),
      val: PropTypes.oneOf(['left', 'right']),
      disabled: reactBool,
      max: reactNumber,
      value: reactNumber,
      color: reactString
  }), _temp11);

  mobiscroll$3.Progress = MbscProgress;

  // slider
  var MbscSlider = (_temp12 = _class12 = function (_MbscOptimized4) {
      inherits(MbscSlider, _MbscOptimized4);

      function MbscSlider(props) {
          classCallCheck(this, MbscSlider);

          var _this14 = possibleConstructorReturn(this, (MbscSlider.__proto__ || Object.getPrototypeOf(MbscSlider)).call(this, props));

          _this14.componentDidMount = function () {
              // get settings from state 
              var settings = extend$1({}, _this14.state.options);
              // initialize the mobiscroll
              _this14.instance = new Slider(_this14.firstInput, settings);

              if (_this14.state.value !== undefined) {
                  _this14.instance.setVal(_this14.state.value, true);
              }
              var that = _this14;
              // our own change handler - to receive the change event
              $$2(_this14.label).on('change', function () {
                  if (that.props.onChange) {
                      var values = that.instance.getVal();
                      that.props.onChange(values);
                  }
              });
          };

          _this14.firstInputMounted = function (input) {
              _this14.firstInput = input;
          };

          _this14.parentMounted = function (label) {
              _this14.label = label;
          };

          _this14.onValueChanged = function () {
              // this is not triggered - or the event propagation is stopped somewhere on the line
              // to counter this we attach our own change handler in the `componentDidMount` function 
          };

          _this14.render = function () {
              /* eslint-disable no-unused-vars */
              // justification: variable 'onChange' and 'className' is defined due to object decomposotion
              var _props12 = _this14.props,
                  children = _props12.children,
                  value = _props12.value,
                  onChange = _props12.onChange,
                  className = _props12.className,
                  icon = _props12.icon,
                  live = _props12.live,
                  stepLabels = _props12.stepLabels,
                  tooltip = _props12.tooltip,
                  color = _props12.color,
                  other = _objectWithoutProperties$1(_props12, ['children', 'value', 'onChange', 'className', 'icon', 'live', 'stepLabels', 'tooltip', 'color']),
                  values = value || [];

              live = live || _this14.props['data-live'] || false;
              icon = icon || _this14.props['data-icon'];
              /* eslint-enable no-unused-vars */

              if (value !== undefined && !Array.isArray(value)) {
                  values = [value];
              }

              var presetClass = '';
              if (color) {
                  presetClass = 'mbsc-slider-' + color;
              }
              var cssClass = presetClass + (_this14.initialCssClass ? ' ' + _this14.initialCssClass : '');

              return React.createElement('label', { ref: _this14.parentMounted, className: cssClass }, children, values.map(function (item, index) {
                  if (index === 0) {
                      return React.createElement('input', _extends$2({ ref: this.firstInputMounted, 'data-icon': icon, 'data-live': live, key: index, type: 'range' }, other));
                  }
                  return React.createElement('input', { key: index, type: 'range', 'data-live': live, 'data-index': index });
              }, _this14));
          };
          return _this14;
      }

      return MbscSlider;
  }(MbscOptimized), _class12.propTypes = _extends$2({}, CorePropTypes, {
      highlight: reactBool,
      live: reactBool,
      stepLabels: PropTypes.arrayOf(reactNumber),
      "data-icon": reactString,
      tooltip: reactBool,
      val: PropTypes.oneOf(['left', 'right']),
      disabled: reactBool,
      max: reactNumber,
      min: reactNumber,
      step: reactNumber,
      values: reactNumber,
      color: reactString
  }), _temp12);

  mobiscroll$3.Slider = MbscSlider;

  var MbscRating = (_temp13 = _class13 = function (_MbscOptimized5) {
      inherits(MbscRating, _MbscOptimized5);

      function MbscRating(props) {
          classCallCheck(this, MbscRating);

          var _this15 = possibleConstructorReturn(this, (MbscRating.__proto__ || Object.getPrototypeOf(MbscRating)).call(this, props));

          _this15.componentDidMount = function () {
              // get settings from state
              var settings = extend$1({}, _this15.state.options);
              // initialize the mobiscroll
              _this15.instance = new Rating(_this15.inputNode, settings);
              if (_this15.state.value !== undefined) {
                  _this15.instance.setVal(_this15.state.value, true);
              }

              $$2(_this15.label).on('change', function () {
                  if (_this15.props.onChange) {
                      var value = _this15.instance.getVal();
                      _this15.props.onChange(value);
                  }
              });
          };

          _this15.inputMounted = function (input) {
              _this15.inputNode = input;
          };

          _this15.parentMounted = function (label) {
              _this15.label = label;
          };

          _this15.render = function () {
              /* eslint-disable no-unused-vars */
              // justification: variable 'value' and 'className' is defined due to object decomposotion
              var _props13 = _this15.props,
                  className = _props13.className,
                  children = _props13.children,
                  onChange = _props13.onChange,
                  value = _props13.value,
                  empty = _props13.empty,
                  filled = _props13.filled,
                  template = _props13.template,
                  val = _props13.val,
                  color = _props13.color,
                  other = _objectWithoutProperties$1(_props13, ['className', 'children', 'onChange', 'value', 'empty', 'filled', 'template', 'val', 'color']);
              /* eslint-enable no-unused-vars */

              var presetClass = '';
              if (color) {
                  presetClass = 'mbsc-rating-' + color;
              }
              var cssClass = presetClass + (_this15.initialCssClass ? ' ' + _this15.initialCssClass : '');

              return React.createElement('label', { className: cssClass, ref: _this15.parentMounted }, children, React.createElement('input', _extends$2({ type: 'rating', 'data-role': 'rating', 'data-val': val, 'data-template': template, 'data-empty': empty, 'data-filled': filled, ref: _this15.inputMounted }, other)));
          };
          return _this15;
      }

      return MbscRating;
  }(MbscOptimized), _class13.propTypes = _extends$2({}, CorePropTypes, {
      val: PropTypes.oneOf(['left', 'right']),
      disabled: reactBool,
      max: reactNumber,
      min: reactNumber,
      step: reactNumber,
      template: reactString,
      empty: reactString,
      filled: reactString,
      value: reactNumber,
      color: reactString
  }), _temp13);

  mobiscroll$3.Rating = MbscRating;

  /* eslint-disable no-unused-vars */
  /* eslint-enable no-unused-vars */
  var isIOS$1 = os == 'ios';

  var ScrollViewBase = function ScrollViewBase(el, settings, inherit) {
      var $btn,
          btnTimer,
          contSize,
          diffX,
          diffY,
          diff,
          dir,
          easing,
          elastic,
          endX,
          endY,
          eventObj,
          isBtn,
          maxScroll,
          maxSnapScroll,
          minScroll,
          move,
          moving,
          nativeScroll,
          rafID,

      //rafMoveID,
      rafRunning,
          scrolled,
          scrollDebounce,
          scrollTimer,
          snap,
          snapPoints,
          startPos,
          startTime,
          startX,
          startY,
          style,
          target,
          transTimer,
          threshold,
          trigger,
          vertical,
          that = this,
          currPos,
          currSnap = 0,
          currSnapDir = 1,
          s = settings,
          $elm = $$2(el);

      function onStart(ev) {

          trigger('onStart', {
              domEvent: ev
          });

          // Better performance if there are tap events on document
          if (s.stopProp) {
              ev.stopPropagation();
          }

          //if (s.prevDef || ev.type == 'mousedown') {
          if (s.prevDef) {
              // Prevent touch highlight and focus
              ev.preventDefault();
          }

          if (s.readonly || s.lock && moving) {
              return;
          }

          if (testTouch(ev, this) && !move) {

              if ($btn) {
                  $btn.removeClass('mbsc-active');
              }

              // Highlight button
              isBtn = false;

              if (!moving) {
                  $btn = $$2(ev.target).closest('.mbsc-btn-e', this);

                  if ($btn.length && !$btn.hasClass('mbsc-disabled')) {
                      isBtn = true;
                      btnTimer = setTimeout(function () {
                          $btn.addClass('mbsc-active');
                      }, 100);
                  }
              }

              move = true;
              scrolled = false;
              nativeScroll = false;

              that.scrolled = moving;

              startX = getCoord(ev, 'X');
              startY = getCoord(ev, 'Y');
              endX = startX;
              diffX = 0;
              diffY = 0;
              diff = 0;

              startTime = new Date();

              startPos = +getPosition(target, vertical) || 0;

              // Stop scrolling animation, 1ms is needed for Android 4.0
              if (moving) {
                  scroll(startPos, isIOS$1 ? 0 : 1);
              }

              if (ev.type === 'mousedown') {
                  $$2(document).on('mousemove', onMove).on('mouseup', onEnd);
              }
          }
      }

      function onMove(ev) {
          if (move) {
              if (s.stopProp) {
                  ev.stopPropagation();
              }

              endX = getCoord(ev, 'X');
              endY = getCoord(ev, 'Y');
              diffX = endX - startX;
              diffY = endY - startY;
              diff = vertical ? diffY : diffX;

              if (isBtn && (Math.abs(diffY) > s.thresholdY || Math.abs(diffX) > s.thresholdX)) {
                  clearTimeout(btnTimer);
                  $btn.removeClass('mbsc-active');
                  isBtn = false;
              }

              if (that.scrolled || !nativeScroll && Math.abs(diff) > threshold) {

                  if (!scrolled) {
                      trigger('onGestureStart', eventObj);
                  }

                  that.scrolled = scrolled = true;

                  if (!rafRunning) {
                      rafRunning = true;
                      rafID = raf(onMoving);
                  }
              }

              if (vertical || s.scrollLock) {
                  // Always prevent native scroll, if vertical
                  ev.preventDefault();
              } else {
                  if (that.scrolled) {
                      // Prevent native scroll
                      ev.preventDefault();
                  } else if (Math.abs(diffY) > 7) {
                      nativeScroll = true;
                      that.scrolled = true;
                      $elm.trigger('touchend');
                  }
              }
          }
      }

      function onMoving() {
          //var time = new Date();

          if (maxSnapScroll) {
              diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
          }

          scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic));

          //if (s.momentum) {
          //    startTime = time;
          //    lastX = endX;
          //}

          rafRunning = false;
      }

      function onEnd(ev) {
          if (move) {
              var speed,
                  time = new Date() - startTime;

              // Better performance if there are tap events on document
              if (s.stopProp) {
                  ev.stopPropagation();
              }

              rafc(rafID);
              rafRunning = false;

              if (!nativeScroll && that.scrolled) {
                  // Calculate momentum distance
                  if (s.momentum && time < 300) {
                      speed = diff / time;
                      //speed = Math.abs(lastX - endX) / time;
                      diff = Math.max(Math.abs(diff), speed * speed / s.speedUnit) * (diff < 0 ? -1 : 1);
                  }

                  finalize(diff);
              }

              if (isBtn) {
                  clearTimeout(btnTimer);
                  $btn.addClass('mbsc-active');
                  setTimeout(function () {
                      $btn.removeClass('mbsc-active');
                  }, 100);

                  if (!nativeScroll && !that.scrolled) {
                      trigger('onBtnTap', {
                          target: $btn[0],
                          domEvent: ev
                      });
                  }
              }

              // Detach document events
              if (ev.type == 'mouseup') {
                  $$2(document).off('mousemove', onMove).off('mouseup', onEnd);
              }

              move = false;
          }
      }

      function onScroll(ev) {
          ev = ev.originalEvent || ev;

          diff = vertical ? ev.deltaY || ev.wheelDelta || ev.detail : ev.deltaX;

          trigger('onStart', {
              domEvent: ev
          });

          if (s.stopProp) {
              ev.stopPropagation();
          }

          if (diff) {

              ev.preventDefault();

              //diff = diff < 0 ? 20 : -20;

              if (ev.deltaMode && ev.deltaMode == 1) {
                  diff *= 5;
              }

              diff = constrain(-diff, -20, 20);

              startPos = currPos;

              if (s.readonly || startPos + diff < minScroll || startPos + diff > maxScroll) {
                  return;
              }

              if (!scrolled) {
                  eventObj = {
                      posX: vertical ? 0 : currPos,
                      posY: vertical ? currPos : 0,
                      originX: vertical ? 0 : startPos,
                      originY: vertical ? startPos : 0,
                      direction: diff > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180
                  };
                  trigger('onGestureStart', eventObj);
              }

              if (!rafRunning) {
                  rafRunning = true;
                  rafID = raf(onMoving);
              }

              scrolled = true;

              clearTimeout(scrollDebounce);
              scrollDebounce = setTimeout(function () {
                  rafc(rafID);
                  rafRunning = false;
                  scrolled = false;

                  finalize(diff);
              }, 200);
          }
      }

      function finalize(diff) {
          var i, time, newPos;

          // Limit scroll to snap size
          if (maxSnapScroll) {
              diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
          }

          // Calculate snap and limit between min and max
          newPos = constrain(Math.round((startPos + diff) / snap) * snap, minScroll, maxScroll);
          currSnap = Math.round(newPos / snap);

          // Snap to nearest element
          if (snapPoints) {
              if (diff < 0) {
                  for (i = snapPoints.length - 1; i >= 0; i--) {
                      if (Math.abs(newPos) + contSize >= snapPoints[i].breakpoint) {
                          currSnap = i;
                          currSnapDir = 2;
                          newPos = snapPoints[i].snap2;
                          break;
                      }
                  }
              } else if (diff >= 0) {
                  for (i = 0; i < snapPoints.length; i++) {
                      if (Math.abs(newPos) <= snapPoints[i].breakpoint) {
                          currSnap = i;
                          currSnapDir = 1;
                          newPos = snapPoints[i].snap1;
                          break;
                      }
                  }
              }
              newPos = constrain(newPos, minScroll, maxScroll);
          }

          time = s.time || (currPos < minScroll || currPos > maxScroll ? 1000 : Math.max(1000, Math.abs(newPos - currPos) * s.timeUnit));

          eventObj.destinationX = vertical ? 0 : newPos;
          eventObj.destinationY = vertical ? newPos : 0;
          eventObj.duration = time;
          eventObj.transitionTiming = easing;

          trigger('onGestureEnd', eventObj);

          // Scroll to the calculated position
          scroll(newPos, time);
      }

      function scroll(pos, time, tap$$1, callback) {
          var changed = pos != currPos,
              anim = time > 1,
              done = function done() {
              clearInterval(scrollTimer);
              clearTimeout(transTimer);
              //rafc(rafMoveID);

              moving = false;
              currPos = pos;
              eventObj.posX = vertical ? 0 : pos;
              eventObj.posY = vertical ? pos : 0;

              if (changed) {
                  trigger('onMove', eventObj);
              }

              if (anim) {
                  //that.scrolled = false;
                  trigger('onAnimationEnd', eventObj);
              }

              if (callback) {
                  callback();
              }
          };

          eventObj = {
              posX: vertical ? 0 : currPos,
              posY: vertical ? currPos : 0,
              originX: vertical ? 0 : startPos,
              originY: vertical ? startPos : 0,
              direction: pos - currPos > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180
          };

          currPos = pos;

          if (anim) {
              eventObj.destinationX = vertical ? 0 : pos;
              eventObj.destinationY = vertical ? pos : 0;
              eventObj.duration = time;
              eventObj.transitionTiming = easing;

              trigger('onAnimationStart', eventObj);
          }

          style[jsPrefix + 'Transition'] = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '';
          style[jsPrefix + 'Transform'] = 'translate3d(' + (vertical ? '0,' + pos + 'px,' : pos + 'px,' + '0,') + '0)';

          if (!changed && !moving || !time || time <= 1) {
              done();
          } else if (time) {
              moving = !tap$$1;

              clearInterval(scrollTimer);
              scrollTimer = setInterval(function () {
                  //rafMoveID = raf(function () {
                  var p = +getPosition(target, vertical) || 0;
                  eventObj.posX = vertical ? 0 : p;
                  eventObj.posY = vertical ? p : 0;
                  trigger('onMove', eventObj);
                  // Trigger done if close to the end
                  if (Math.abs(p - pos) < 2) {
                      done();
                  }
                  //});
              }, 100);

              clearTimeout(transTimer);
              transTimer = setTimeout(function () {
                  done();
                  //style[pr + 'Transition'] = '';
              }, time);

              // target.off(transEnd).on(transEnd, function (e) {
              //     if (e.target === target[0]) {
              //         target.off(transEnd);
              //         style[pr + 'Transition'] = '';
              //         done();
              //     }
              // });
          }

          if (s.sync) {
              s.sync(pos, time, easing);
          }
      }

      // Call the parent constructor
      Base.call(this, el, settings, true);

      that.scrolled = false;

      /**
       * Scroll to the given position or element
       */
      that.scroll = function (pos, time, tap$$1, callback) {
          // If position is not numeric, scroll to element
          if (!isNumeric(pos)) {
              pos = Math.ceil(($$2(pos, el).length ? Math.round(target.offset()[dir] - $$2(pos, el).offset()[dir]) : currPos) / snap) * snap;
          } else {
              pos = Math.round(pos / snap) * snap;
          }

          pos = constrain(pos, minScroll, maxScroll);

          currSnap = Math.round(pos / snap);

          startPos = currPos;

          scroll(pos, time, tap$$1, callback);
      };

      that.refresh = function (noScroll) {
          var tempScroll;

          contSize = s.contSize === undefined ? vertical ? $elm.height() : $elm.width() : s.contSize;
          minScroll = s.minScroll === undefined ? Math.min(0, vertical ? contSize - target.height() : contSize - target.width()) : s.minScroll;
          maxScroll = s.maxScroll === undefined ? 0 : s.maxScroll;
          snapPoints = null;

          if (!vertical && s.rtl) {
              tempScroll = maxScroll;
              maxScroll = -minScroll;
              minScroll = -tempScroll;
          }

          if (isString(s.snap)) {
              snapPoints = [];
              target.find(s.snap).each(function () {
                  var offset = vertical ? this.offsetTop : this.offsetLeft,
                      size = vertical ? this.offsetHeight : this.offsetWidth;

                  snapPoints.push({
                      breakpoint: offset + size / 2,
                      snap1: -offset,
                      snap2: contSize - offset - size
                  });
              });
          }

          snap = isNumeric(s.snap) ? s.snap : 1;
          maxSnapScroll = s.snap ? s.maxSnapScroll : 0;
          easing = s.easing;
          elastic = s.elastic ? isNumeric(s.snap) ? snap : isNumeric(s.elastic) ? s.elastic : 0 : 0; // && s.snap ? snap : 0;

          if (currPos === undefined) {
              currPos = s.initialPos;
              currSnap = Math.round(currPos / snap);
          }

          if (!noScroll) {
              that.scroll(s.snap ? snapPoints ? snapPoints[currSnap]['snap' + currSnapDir] : currSnap * snap : currPos);
          }
      };

      that._processSettings = function () {
          vertical = s.axis == 'Y';
          dir = vertical ? 'top' : 'left';
          target = s.moveElement || $elm.children().eq(0);
          style = target[0].style;
          threshold = vertical ? s.thresholdY : s.thresholdX;
      };

      that._init = function () {
          that.refresh();

          $elm.on('touchstart mousedown', onStart).on('touchmove', onMove).on('touchend touchcancel', onEnd);

          if (s.mousewheel) {
              $elm.on('wheel mousewheel', onScroll);
          }

          if (el.addEventListener) {
              el.addEventListener('click', function (ev) {
                  if (that.scrolled) {
                      that.scrolled = false;
                      ev.stopPropagation();
                      ev.preventDefault();
                  }
              }, true);
          }

          //el.addEventListener('touchend', function (ev) {
          //    if (scrolled) {
          //        ev.stopPropagation();
          //    }
          //}, true);
      };

      /**
       * Destroy
       */
      that._destroy = function () {
          clearInterval(scrollTimer);

          $elm.off('touchstart mousedown', onStart).off('touchmove', onMove).off('touchend touchcancel', onEnd).off('wheel mousewheel', onScroll);
      };

      // Constructor

      s = that.settings;
      trigger = that.trigger;

      if (!inherit) {
          that.init(settings);
      }
  };

  ScrollViewBase.prototype = {
      _defaults: {
          speedUnit: 0.0022,
          //timeUnit: 0.8,
          timeUnit: 3,
          initialPos: 0,
          axis: 'Y',
          thresholdX: 10,
          thresholdY: 5,
          //easing: 'ease-out',
          easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
          stopProp: true,
          momentum: true,
          mousewheel: true,
          elastic: true
      }
  };

  /* eslint-disable no-unused-vars */
  /* eslint-enable no-unused-vars */
  var presets = {};
  var css = isBrowser ? window.CSS : null;
  var has3d = css && css.supports && css.supports("(transform-style: preserve-3d)");
  var force2D = !has3d || os == 'wp' || os == 'android';

  var Scroller = function Scroller(el, settings, inherit) {
      var $markup,
          batchSize3d,
          batchSize = 40,
          animTime = 1000,
          scroll3dAngle,
          scroll3d,
          selectedClass,
          showScrollArrows,
          stepper,
          tempWheelArray,
          itemHeight,
          itemHeight3d,
          isValidating,
          s,
          trigger,
          lines,
          wheels,
          wheelsMap,
          that = this,
          $elm = $$2(el);

      // Event handlers

      function onKeyDown(ev) {
          var i = $$2(this).attr('data-index'),
              handle,
              direction;

          if (ev.keyCode == 38) {
              // Up
              handle = true;
              direction = -1;
          } else if (ev.keyCode == 40) {
              // Down
              handle = true;
              direction = 1;
          } else if (ev.keyCode == 32) {
              // Space
              handle = true;
              onItemTap(i, wheels[i]._$markup.find('.mbsc-sc-itm[data-val="' + tempWheelArray[i] + '"]'));
          }

          if (handle) {
              ev.stopPropagation();
              ev.preventDefault();

              if (direction) {
                  stepper.start(i, direction);
              }
          }
      }

      function onKeyUp() {
          stepper.stop();
      }

      function onItemTap(i, $item) {
          var wheel = wheels[i],
              idx = +$item.attr('data-index'),
              val = getValue(wheel, idx),
              selected = that._tempSelected[i],
              maxSelect = isNumeric(wheel.multiple) ? wheel.multiple : Infinity;

          if (trigger('onItemTap', {
              target: $item[0],
              index: i,
              value: val,
              selected: $item.hasClass('mbsc-sc-itm-sel')
          }) !== false) {

              // Select item on tap
              if (wheel.multiple && !wheel._disabled[val]) {
                  if (selected[val] !== undefined) {
                      $item.removeClass(selectedClass).removeAttr('aria-selected');
                      delete selected[val];
                  } else {
                      if (maxSelect == 1) {
                          that._tempSelected[i] = selected = {};
                          wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');
                      }
                      if (objectToArray(selected).length < maxSelect) {
                          $item.addClass(selectedClass).attr('aria-selected', 'true');
                          selected[val] = val;
                      }
                  }
              }

              setWheelValue(wheel, i, idx, animTime, true, true, wheel.multiple);

              if (that.live && !wheel.multiple && (s.setOnTap === true || s.setOnTap[i])) {
                  setTimeout(function () {
                      that.select();
                  }, 200);
              }
          }
      }

      // Private functions

      function getIndex(wheel, val) {
          return (wheel._array ? wheel._map[val] : wheel.getIndex(val, that)) || 0;
      }

      function getItem(wheel, i) {
          var data = wheel.data;

          if (i >= wheel.min && i <= wheel.max) {
              return wheel._array ? wheel.circular ? $$2(data).get(i % wheel._length) : data[i] : $$2.isFunction(data) ? data(i, that) : '';
          }
      }

      function getItemValue(item) {
          return $$2.isPlainObject(item) ? item.value !== undefined ? item.value : item.display : item;
      }

      function getItemText(item) {
          var text = $$2.isPlainObject(item) ? item.display : item;
          return text === undefined ? '' : text;
      }

      function getValue(wheel, i) {
          return getItemValue(getItem(wheel, i));
      }

      function step(index, direction) {
          var wheel = wheels[index];
          setWheelValue(wheel, index, wheel._current + direction, animTime, direction == 1 ? 1 : 2);
      }

      function isReadOnly(i) {
          return $$2.isArray(s.readonly) ? s.readonly[i] : s.readonly;
      }

      function initWheel(w, l, keep) {
          var index = w._index - w._batch;

          w.data = w.data || [];
          w.key = w.key !== undefined ? w.key : l;
          w.label = w.label !== undefined ? w.label : l;

          w._map = {};
          w._array = $$2.isArray(w.data);

          // Map keys to index
          if (w._array) {
              w._length = w.data.length;
              $$2.each(w.data, function (i, v) {
                  w._map[getItemValue(v)] = i;
              });
          }

          w.circular = s.circular === undefined ? w.circular === undefined ? w._array && w._length > s.rows : w.circular : $$2.isArray(s.circular) ? s.circular[l] : s.circular;
          w.min = w._array ? w.circular ? -Infinity : 0 : w.min === undefined ? -Infinity : w.min;
          w.max = w._array ? w.circular ? Infinity : w._length - 1 : w.max === undefined ? Infinity : w.max;

          w._nr = l;
          w._index = getIndex(w, tempWheelArray[l]);
          w._disabled = {};
          w._batch = 0;
          w._current = w._index;
          w._first = w._index - batchSize; //Math.max(w.min, w._current - batchSize);
          w._last = w._index + batchSize; //Math.min(w.max, w._first + 2 * batchSize);
          w._offset = w._first;

          if (keep) {
              w._offset -= w._margin / itemHeight + (w._index - index);
              w._margin += (w._index - index) * itemHeight;
          } else {
              w._margin = 0; //w._first * itemHeight;
          }

          w._refresh = function (noScroll) {
              var maxScroll = -(w.min - w._offset + (w.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight,
                  minScroll = Math.min(maxScroll, -(w.max - w._offset - (w.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight);

              extend$1(w._scroller.settings, {
                  minScroll: minScroll,
                  maxScroll: maxScroll
              });

              w._scroller.refresh(noScroll);
          };

          wheelsMap[w.key] = w;

          return w;
      }

      function generateItems(wheel, index, start, end, is3d) {
          var i,
              css,
              item,
              value,
              text,
              lbl,
              invalid,
              selected,
              html = '',
              checked = that._tempSelected[index],
              disabled = wheel._disabled || {};

          for (i = start; i <= end; i++) {
              item = getItem(wheel, i);
              text = getItemText(item);
              value = getItemValue(item);
              css = item && item.cssClass !== undefined ? item.cssClass : '';
              lbl = item && item.label !== undefined ? item.label : '';
              invalid = item && item.invalid;
              selected = value !== undefined && value == tempWheelArray[index] && !wheel.multiple;

              // TODO: don't generate items with no value (use margin or placeholder instead)
              html += '<div role="option" aria-selected="' + (checked[value] ? true : false) + '" class="mbsc-sc-itm ' + (is3d ? 'mbsc-sc-itm-3d ' : '') + css + ' ' + (selected ? 'mbsc-sc-itm-sel ' : '') + (checked[value] ? selectedClass : '') + (value === undefined ? ' mbsc-sc-itm-ph' : ' mbsc-btn-e') + (invalid ? ' mbsc-sc-itm-inv-h mbsc-disabled' : '') + (disabled[value] ? ' mbsc-sc-itm-inv mbsc-disabled' : '') + '" data-index="' + i + '" data-val="' + value + '"' + (lbl ? ' aria-label="' + lbl + '"' : '') + (selected ? ' aria-selected="true"' : '') + ' style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;' + (is3d ? cssPrefix + 'transform:rotateX(' + (wheel._offset - i) * scroll3dAngle % 360 + 'deg) translateZ(' + itemHeight * s.rows / 2 + 'px);' : '') + '">' + (lines > 1 ? '<div class="mbsc-sc-itm-ml" style="line-height:' + Math.round(itemHeight / lines) + 'px;font-size:' + Math.round(itemHeight / lines * 0.8) + 'px;">' : '') + text + (lines > 1 ? '</div>' : '') + '</div>';
          }

          return html;
      }

      function infinite(wheel, i, pos) {
          var index = Math.round(-pos / itemHeight) + wheel._offset,
              diff = index - wheel._current,
              first = wheel._first,
              last = wheel._last,
              first3d = first + batchSize - batchSize3d + 1,
              last3d = last - batchSize + batchSize3d;

          if (diff) {
              wheel._first += diff;
              wheel._last += diff;

              wheel._current = index;

              // Generate items
              //setTimeout(function () {
              if (diff > 0) {
                  wheel._$scroller.append(generateItems(wheel, i, Math.max(last + 1, first + diff), last + diff));
                  $$2('.mbsc-sc-itm', wheel._$scroller).slice(0, Math.min(diff, last - first + 1)).remove();

                  // 3D
                  if (scroll3d) {
                      wheel._$3d.append(generateItems(wheel, i, Math.max(last3d + 1, first3d + diff), last3d + diff, true));
                      $$2('.mbsc-sc-itm', wheel._$3d).slice(0, Math.min(diff, last3d - first3d + 1)).attr('class', 'mbsc-sc-itm-del');
                  }
              } else if (diff < 0) {
                  wheel._$scroller.prepend(generateItems(wheel, i, first + diff, Math.min(first - 1, last + diff)));
                  $$2('.mbsc-sc-itm', wheel._$scroller).slice(Math.max(diff, first - last - 1)).remove();

                  // 3D
                  if (scroll3d) {
                      wheel._$3d.prepend(generateItems(wheel, i, first3d + diff, Math.min(first3d - 1, last3d + diff), true));
                      $$2('.mbsc-sc-itm', wheel._$3d).slice(Math.max(diff, first3d - last3d - 1)).attr('class', 'mbsc-sc-itm-del');
                  }
              }

              wheel._margin += diff * itemHeight;
              wheel._$scroller.css('margin-top', wheel._margin + 'px');
              //}, 10);
          }
      }

      function getValid(index, val, dir, dis) {
          var counter,
              wheel = wheels[index],
              disabled = dis || wheel._disabled,
              idx = getIndex(wheel, val),
              v1 = val,
              v2 = val,
              dist1 = 0,
              dist2 = 0;

          if (val === undefined) {
              val = getValue(wheel, idx);
          }

          // TODO: what if all items are invalid
          if (disabled[val] === true) {
              counter = 0;
              while (idx - dist1 >= wheel.min && disabled[v1] && counter < 100) {
                  counter++;
                  dist1++;
                  v1 = getValue(wheel, idx - dist1);
              }

              counter = 0;
              while (idx + dist2 < wheel.max && disabled[v2] && counter < 100) {
                  counter++;
                  dist2++;
                  v2 = getValue(wheel, idx + dist2);
              }

              // If we have direction (+/- or mouse wheel), the distance does not count
              if ((dist2 < dist1 && dist2 && dir !== 2 || !dist1 || idx - dist1 < 0 || dir == 1) && !disabled[v2]) {
                  val = v2;
              } else {
                  val = v1;
              }
          }

          return val;
      }

      function scrollToPos(time, index, dir, manual, tap, noscroll) {
          var diff,
              idx,
              offset,
              ret,
              isVisible = that._isVisible;

          isValidating = true;
          ret = s.validate.call(el, {
              values: tempWheelArray.slice(0),
              index: index,
              direction: dir
          }, that) || {};
          isValidating = false;

          if (ret.valid) {
              that._tempWheelArray = tempWheelArray = ret.valid.slice(0);
          }

          if (!noscroll) {
              $$2.each(wheels, function (i, wheel) {
                  if (isVisible) {
                      // Enable all items
                      wheel._$markup.find('.mbsc-sc-itm-inv').removeClass('mbsc-sc-itm-inv mbsc-disabled');
                  }
                  wheel._disabled = {};

                  // Disable invalid items
                  if (ret.disabled && ret.disabled[i]) {
                      $$2.each(ret.disabled[i], function (j, v) {
                          wheel._disabled[v] = true;
                          if (isVisible) {
                              wheel._$markup.find('.mbsc-sc-itm[data-val="' + v + '"]').addClass('mbsc-sc-itm-inv mbsc-disabled');
                          }
                      });
                  }

                  // Get closest valid value
                  tempWheelArray[i] = wheel.multiple ? tempWheelArray[i] : getValid(i, tempWheelArray[i], dir);

                  if (isVisible) {
                      if (!wheel.multiple || index === undefined) {
                          wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');
                      }

                      if (wheel.multiple) {
                          // Add selected styling to selected elements in case of multiselect
                          if (index === undefined) {
                              for (var v in that._tempSelected[i]) {
                                  wheel._$markup.find('.mbsc-sc-itm[data-val="' + v + '"]').addClass(selectedClass).attr('aria-selected', 'true');
                              }
                          }
                      } else {
                          // Mark element as aria selected
                          wheel._$markup.find('.mbsc-sc-itm[data-val="' + tempWheelArray[i] + '"]').addClass('mbsc-sc-itm-sel').attr('aria-selected', 'true');
                      }

                      // Get index of valid value
                      idx = getIndex(wheel, tempWheelArray[i]);

                      diff = idx - wheel._index + wheel._batch;

                      if (Math.abs(diff) > 2 * batchSize + 1) {
                          offset = diff + (2 * batchSize + 1) * (diff > 0 ? -1 : 1);
                          wheel._offset += offset;
                          wheel._margin -= offset * itemHeight;
                          wheel._refresh();
                      }

                      wheel._index = idx + wheel._batch;

                      // Scroll to valid value
                      wheel._scroller.scroll(-(idx - wheel._offset + wheel._batch) * itemHeight, index === i || index === undefined ? time : animTime, tap);
                  }
              });
          }

          trigger('onValidated', { index: index, time: time });

          // Get formatted value
          that._tempValue = s.formatValue.call(el, tempWheelArray, that);

          if (isVisible) {
              that._updateHeader();
          }

          // If in live mode, set and fill value on every move
          if (that.live) {
              that._hasValue = manual || that._hasValue;
              setValue(manual, manual, 0, true);
              if (manual) {
                  trigger('onSet', {
                      valueText: that._value
                  });
              }
          }

          if (manual) {
              trigger('onChange', {
                  index: index,
                  valueText: that._tempValue
              });
          }
      }

      function setWheelValue(wheel, i, idx, time, dir, tap, noscroll) {
          // Get the value at the given index
          var value = getValue(wheel, idx);

          if (value !== undefined) {
              tempWheelArray[i] = value;

              // In case of circular wheels calculate the offset of the current batch
              wheel._batch = wheel._array ? Math.floor(idx / wheel._length) * wheel._length : 0;
              wheel._index = idx;

              setTimeout(function () {
                  scrollToPos(time, i, dir, true, tap, noscroll);
              }, 10);
          }
      }

      function setValue(fill, change, time, noscroll, temp) {
          if (!noscroll) {
              scrollToPos(time);
          } else {
              that._tempValue = s.formatValue.call(el, that._tempWheelArray, that);
          }

          if (!temp) {
              that._wheelArray = [];
              for (var i = 0; i < tempWheelArray.length; i++) {
                  // In case of multiple select wheel take the first selected value,
                  that._wheelArray[i] = wheels[i] && wheels[i].multiple ? Object.keys(that._tempSelected[i])[0] : tempWheelArray[i];
              }
              that._value = that._hasValue ? that._tempValue : null;
              that._selected = extend$1(true, {}, that._tempSelected);
          }

          if (fill) {
              if (that._isInput) {
                  $elm.val(that._hasValue ? that._tempValue : '');
              }

              trigger('onFill', {
                  valueText: that._hasValue ? that._tempValue : '',
                  change: change
              });

              if (change) {
                  that._preventChange = true;
                  $elm.trigger('change');
              }
          }
      }

      // Call the parent constructor
      Frame.call(this, el, settings, true);

      // Public functions

      /**
       * Sets the value of the scroller.
       * @param {Array} val - New value.
       * @param {Boolean} [fill=false] - Set the value of the associated input element.
       * @param {Boolean} [change=false] - Trigger change on the input element.
       * @param {Boolean} [temp=false] - If true, then only set the temporary value (only scroll there but not set the value).
       * @param {Number} [time=0] - Animation time in milliseconds.
       */
      that.setVal = that._setVal = function (val, fill, change, temp, time) {
          that._hasValue = val !== null && val !== undefined;
          that._tempWheelArray = tempWheelArray = $$2.isArray(val) ? val.slice(0) : s.parseValue.call(el, val, that) || [];
          setValue(fill, change === undefined ? fill : change, time, false, temp);
      };

      /**
       * Returns the selected value.
       */
      that.getVal = that._getVal = function (temp) {
          var val = that._hasValue || temp ? that[temp ? '_tempValue' : '_value'] : null;
          return isNumeric(val) ? +val : val;
      };

      /*
       * Sets the wheel values (passed as an array).
       */
      that.setArrayVal = that.setVal;

      /*
       * Returns the selected wheel values as an array.
       */
      that.getArrayVal = function (temp) {
          return temp ? that._tempWheelArray : that._wheelArray;
      };

      that.changeWheel = function (whls, time, manual) {
          var i, w;

          $$2.each(whls, function (key, wheel) {
              w = wheelsMap[key];
              // Check if wheel exists
              if (w) {
                  i = w._nr;

                  extend$1(w, wheel);

                  initWheel(w, i, true);

                  if (that._isVisible) {
                      if (scroll3d) {
                          w._$3d.html(generateItems(w, i, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true));
                      }

                      w._$scroller.html(generateItems(w, i, w._first, w._last)).css('margin-top', w._margin + 'px');

                      w._refresh(isValidating);
                  }
              }
          });

          if (that._isVisible && !that._isLiquid && !isValidating) {
              that.position();
          }

          if (!isValidating) {
              scrollToPos(time, undefined, undefined, manual);
          }
      };

      /**
       * Returns the closest valid value.
       */
      that.getValidValue = getValid;

      // Protected overrides

      that._generateContent = function () {
          var lbl,
              maxPopupWidth = 0,
              html = '',
              style = scroll3d ? cssPrefix + 'transform: translateZ(' + (itemHeight * s.rows / 2 + 3) + 'px);' : '',
              highlight = '<div class="mbsc-sc-whl-l" style="' + style + 'height:' + itemHeight + 'px;margin-top:-' + (itemHeight / 2 + (s.selectedLineBorder || 0)) + 'px;"></div>',
              l = 0;

          $$2.each(s.wheels, function (i, wg) {
              html += '<div class="mbsc-w-p mbsc-sc-whl-gr-c' + (scroll3d ? ' mbsc-sc-whl-gr-3d-c' : '') + (s.showLabel ? ' mbsc-sc-lbl-v' : '') + '">' + highlight + '<div class="mbsc-sc-whl-gr' + (scroll3d ? ' mbsc-sc-whl-gr-3d' : '') + (showScrollArrows ? ' mbsc-sc-cp' : '') + (s.width || s.maxWidth ? '"' : '" style="max-width:' + s.maxPopupWidth + 'px;"') + '>';

              $$2.each(wg, function (j, w) {
                  // Wheels

                  that._tempSelected[l] = extend$1({}, that._selected[l]);

                  // TODO: this should be done on initialization, not on show
                  wheels[l] = initWheel(w, l);

                  maxPopupWidth += s.maxWidth ? s.maxWidth[l] || s.maxWidth : s.width ? s.width[l] || s.width : 0;

                  lbl = w.label !== undefined ? w.label : j;

                  html += '<div class="mbsc-sc-whl-w ' + (w.cssClass || '') + (w.multiple ? ' mbsc-sc-whl-multi' : '') + '" style="' + (s.width ? 'width:' + (s.width[l] || s.width) + 'px;' : (s.minWidth ? 'min-width:' + (s.minWidth[l] || s.minWidth) + 'px;' : '') + (s.maxWidth ? 'max-width:' + (s.maxWidth[l] || s.maxWidth) + 'px;' : '')) + '">' + '<div class="mbsc-sc-whl-o" style="' + style + '"></div>' + highlight + '<div tabindex="0" aria-live="off" aria-label="' + lbl + '"' + (w.multiple ? ' aria-multiselectable="true"' : '') + ' role="listbox" data-index="' + l + '" class="mbsc-sc-whl"' + ' style="' + 'height:' + s.rows * itemHeight * (scroll3d ? 1.1 : 1) + 'px;">' + (showScrollArrows ? '<div data-index="' + l + '" data-step="1" class="mbsc-sc-btn mbsc-sc-btn-plus ' + (s.btnPlusClass || '') + '" style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;"></div>' + // + button
                  '<div data-index="' + l + '" data-step="-1" class="mbsc-sc-btn mbsc-sc-btn-minus ' + (s.btnMinusClass || '') + '" style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;"></div>' : '') + // - button
                  '<div class="mbsc-sc-lbl">' + lbl + '</div>' + // Wheel label
                  '<div class="mbsc-sc-whl-c"' + ' style="height:' + itemHeight3d + 'px;margin-top:-' + (itemHeight3d / 2 + 1) + 'px;' + style + '">' + '<div class="mbsc-sc-whl-sc" style="top:' + (itemHeight3d - itemHeight) / 2 + 'px;">';

                  // Create wheel values
                  html += generateItems(w, l, w._first, w._last) + '</div></div>';

                  if (scroll3d) {
                      html += '<div class="mbsc-sc-whl-3d" style="height:' + itemHeight + 'px;margin-top:-' + itemHeight / 2 + 'px;">';
                      html += generateItems(w, l, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true);
                      html += '</div>';
                  }

                  html += '</div></div>';

                  l++;
              });

              html += '</div></div>';
          });

          if (maxPopupWidth) {
              s.maxPopupWidth = maxPopupWidth;
          }

          return html;
      };

      that._attachEvents = function ($markup) {
          stepper = createStepper($$2('.mbsc-sc-btn', $markup), step, s.delay, isReadOnly, true);

          $$2('.mbsc-sc-whl', $markup).on('keydown', onKeyDown).on('keyup', onKeyUp);
      };

      that._detachEvents = function () {
          for (var i = 0; i < wheels.length; i++) {
              wheels[i]._scroller.destroy();
          }
      };

      that._markupReady = function ($m) {
          $markup = $m;

          $$2('.mbsc-sc-whl-w', $markup).each(function (i) {
              var idx,
                  $wh = $$2(this),
                  wheel = wheels[i],
                  maxScroll = -(wheel.min - wheel._offset + (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight,
                  minScroll = Math.min(maxScroll, -(wheel.max - wheel._offset - (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight);

              wheel._$markup = $wh;
              wheel._$scroller = $$2('.mbsc-sc-whl-sc', this);
              wheel._$3d = $$2('.mbsc-sc-whl-3d', this);

              wheel._scroller = new ScrollViewBase(this, {
                  mousewheel: s.mousewheel,
                  moveElement: wheel._$scroller,
                  initialPos: (wheel._first - wheel._index) * itemHeight,
                  contSize: 0,
                  snap: itemHeight,
                  minScroll: minScroll,
                  maxScroll: maxScroll,
                  maxSnapScroll: batchSize,
                  prevDef: true,
                  stopProp: true,
                  timeUnit: 3,
                  easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
                  sync: function sync(pos, time, easing) {
                      if (scroll3d) {
                          wheel._$3d[0].style[jsPrefix + 'Transition'] = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '';
                          wheel._$3d[0].style[jsPrefix + 'Transform'] = 'rotateX(' + -pos / itemHeight * scroll3dAngle + 'deg)';
                      }
                  },
                  onStart: function onStart(ev, inst) {
                      inst.settings.readonly = isReadOnly(i);
                  },
                  onGestureStart: function onGestureStart() {
                      $wh.addClass('mbsc-sc-whl-a mbsc-sc-whl-anim');

                      trigger('onWheelGestureStart', {
                          index: i
                      });
                  },
                  onGestureEnd: function onGestureEnd(ev) {
                      var dir = ev.direction == 90 ? 1 : 2,
                          time = ev.duration,
                          pos = ev.destinationY;

                      idx = Math.round(-pos / itemHeight) + wheel._offset;

                      setWheelValue(wheel, i, idx, time, dir);
                  },
                  onAnimationStart: function onAnimationStart() {
                      $wh.addClass('mbsc-sc-whl-anim');
                  },
                  onAnimationEnd: function onAnimationEnd() {
                      $wh.removeClass('mbsc-sc-whl-a mbsc-sc-whl-anim');

                      trigger('onWheelAnimationEnd', {
                          index: i
                      });

                      wheel._$3d.find('.mbsc-sc-itm-del').remove();
                  },
                  onMove: function onMove(ev) {
                      infinite(wheel, i, ev.posY);
                  },
                  onBtnTap: function onBtnTap(ev) {
                      onItemTap(i, $$2(ev.target));
                  }
              });
          });

          scrollToPos();
      };

      that._fillValue = function () {
          that._hasValue = true;
          setValue(true, true, 0, true);
      };

      that._clearValue = function () {
          $$2('.mbsc-sc-whl-multi .mbsc-sc-itm-sel', $markup).removeClass(selectedClass).removeAttr('aria-selected');
      };

      that._readValue = function () {
          var v = $elm.val() || '',
              l = 0;

          if (v !== '') {
              that._hasValue = true;
          }

          that._tempWheelArray = tempWheelArray = that._hasValue && that._wheelArray ? that._wheelArray.slice(0) : s.parseValue.call(el, v, that) || [];

          that._tempSelected = extend$1(true, {}, that._selected);

          $$2.each(s.wheels, function (i, wg) {
              $$2.each(wg, function (j, w) {
                  // Wheels
                  wheels[l] = initWheel(w, l);
                  l++;
              });
          });

          setValue(false, false, 0, true);

          trigger('onRead');
      };

      that.__processSettings = function () {
          s = that.settings;
          trigger = that.trigger;
          lines = s.multiline;
          selectedClass = 'mbsc-sc-itm-sel mbsc-ic mbsc-ic-' + s.checkIcon;
      };

      that.__init = function () {
          wheels = [];
          wheelsMap = {};
          showScrollArrows = s.showScrollArrows;
          scroll3d = s.scroll3d && !force2D && !showScrollArrows;
          itemHeight = s.height;
          itemHeight3d = scroll3d ? Math.round((itemHeight - (itemHeight * s.rows / 2 + 3) * 0.03) / 2) * 2 : itemHeight;
          batchSize3d = Math.round(s.rows * 1.8);
          scroll3dAngle = 360 / (batchSize3d * 2);

          // Ensure a minimum number of 3 items if clickpick buttons present
          if (showScrollArrows) {
              s.rows = Math.max(3, s.rows);
          }

          s.cssClass = (s.cssClass || '') + ' mbsc-sc';
      };

      that._getItemValue = getItemValue;

      // Properties
      that._tempSelected = {};
      that._selected = {};

      // Constructor
      if (!inherit) {
          that.init(settings);
      }
  };

  // Extend defaults
  Scroller.prototype = {
      _hasDef: true,
      _hasTheme: true,
      _hasLang: true,
      _class: 'scroller',
      _presets: presets,
      _defaults: extend$1({}, Frame.prototype._defaults, {
          // Options
          minWidth: 80,
          height: 40,
          rows: 3,
          multiline: 1,
          delay: 300,
          readonly: false,
          showLabel: true,
          setOnTap: false,
          wheels: [],
          preset: '',
          speedUnit: 0.0012,
          timeUnit: 0.08,
          checkIcon: 'checkmark',
          validate: function validate() {},
          formatValue: function formatValue(d) {
              return d.join(' ');
          },
          parseValue: function parseValue(value, inst) {
              var val = [],
                  ret = [],
                  i = 0,
                  found,
                  data;

              if (value !== null && value !== undefined) {
                  val = (value + '').split(' ');
              }

              $$2.each(inst.settings.wheels, function (j, wg) {
                  $$2.each(wg, function (k, w) {
                      data = w.data;
                      // Default to first wheel value if not found
                      found = inst._getItemValue(data[0]);
                      $$2.each(data, function (l, item) {
                          // Don't do strict comparison
                          if (val[i] == inst._getItemValue(item)) {
                              found = inst._getItemValue(item);
                              return false;
                          }
                      });
                      ret.push(found);
                      i++;
                  });
              });
              return ret;
          }
      })
  };

  classes.Scroller = Scroller;

  var _extends$4 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
              }
          }
      }return target;
  };

  var MbscScroller = function (_MbscInputBase) {
      inherits(MbscScroller, _MbscInputBase);

      function MbscScroller(props) {
          classCallCheck(this, MbscScroller);

          var _this = possibleConstructorReturn(this, (MbscScroller.__proto__ || Object.getPrototypeOf(MbscScroller)).call(this, props));

          _this.mbscInit = {
              component: 'Scroller'
          };
          return _this;
      }

      return MbscScroller;
  }(MbscInputBase);

  MbscScroller.propTypes = _extends$4({}, MbscScroller.propTypes, ScrollerPropTypes);

  mobiscroll$3.Scroller = MbscScroller;

  // Arabic

  mobiscroll$3.i18n.ar = {
      // Core
      rtl: true, // Right to left mode
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: [' ', ' ', '', '', '', '', '', '', '', ' ', ' ', ''],
      monthNamesShort: [' ', ' ', '', '', '', '', '', '', '', ' ', ' ', ''],
      monthText: '',
      secText: '',
      amText: '',
      pmText: '',
      timeFormat: 'hh:ii A',
      yearText: '',
      nowText: '',
      // Calendar component
      firstDay: 0,
      dateText: '',
      timeText: '',
      closeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      // Event calendar
      eventText: '',
      eventsText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Numpad date
      delimiter: '/',
      // Numpad decimal
      decimalSeparator: '.',
      thousandsSeparator: ',',
      // Timer / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: ' ',
      lapText: '',
      hideText: '',
      // Forms
      offText: '',
      onText: '',
      // Listview
      backText: '',
      undoText: ''
  };

  // Bulgarian

  mobiscroll$3.i18n.bg = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Catal

  mobiscroll$3.i18n.ca = {
      // Core
      setText: 'Acceptar',
      cancelText: 'Cancellar',
      clearText: 'Esborrar',
      selectedText: '{count} seleccionat',
      selectedPluralText: '{count} seleccionats',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Diumenge', 'Dilluns', 'Dimarts', 'Dimecres', 'Dijous', 'Divendres', 'Dissabte'],
      dayNamesShort: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
      dayNamesMin: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
      dayText: 'Dia',
      hourText: 'Hores',
      minuteText: 'Minuts',
      monthNames: ['Gener', 'Febrer', 'Mar&ccedil;', 'Abril', 'Maig', 'Juny', 'Juliol', 'Agost', 'Setembre', 'Octubre', 'Novembre', 'Desembre'],
      monthNamesShort: ['Gen', 'Feb', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Oct', 'Nov', 'Des'],
      monthText: 'Mes',
      secText: 'Segons',
      timeFormat: 'HH:ii',
      yearText: 'Any',
      nowText: 'Ara',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Avui',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Temps',
      closeText: 'Tancar',
      // Daterange component
      fromText: 'Iniciar',
      toText: 'Final',
      // Measurement components
      wholeText: 'Sencer',
      fractionText: 'Fracci',
      unitText: 'Unitat',
      // Time / Timespan component
      labels: ['Anys', 'Mesos', 'Dies', 'Hores', 'Minuts', 'Segons', ''],
      labelsShort: ['Anys', 'Mesos', 'Dies', 'Hrs', 'Mins', 'Secs', ''],
      // Timer component
      startText: 'Iniciar',
      stopText: 'Aturar',
      resetText: 'Reiniciar',
      lapText: 'Volta',
      hideText: 'Amagar',
      // Listview
      backText: 'Enrere',
      undoText: 'Desfs',
      // Form
      offText: 'No',
      onText: 'Si'
  };

  // Cestina

  mobiscroll$3.i18n.cs = {
      // Core
      setText: 'Zadej',
      cancelText: 'Storno',
      clearText: 'Vymazat',
      selectedText: 'Oznaen: {count}',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Nedle', 'Pondl', 'ter', 'Steda', 'tvrtek', 'Ptek', 'Sobota'],
      dayNamesShort: ['Ne', 'Po', 't', 'St', 't', 'P', 'So'],
      dayNamesMin: ['N', 'P', '', 'S', '', 'P', 'S'],
      dayText: 'Den',
      hourText: 'Hodiny',
      minuteText: 'Minuty',
      monthNames: ['Leden', 'nor', 'Bezen', 'Duben', 'Kvten', 'erven', 'ervenec', 'Srpen', 'Z', 'jen', 'Listopad', 'Prosinec'],
      monthNamesShort: ['Led', 'no', 'Be', 'Dub', 'Kv', 'er', 'vc', 'Spr', 'Z', 'j', 'Lis', 'Pro'],
      monthText: 'Msc',
      secText: 'Sekundy',
      timeFormat: 'HH:ii',
      yearText: 'Rok',
      nowText: 'Te',
      amText: 'am',
      pmText: 'pm',
      todayText: 'Dnes',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'as',
      closeText: 'Zavt',
      // Daterange component
      fromText: 'Zatek',
      toText: 'Konec',
      // Measurement components
      wholeText: 'Cel',
      fractionText: 'st',
      unitText: 'Jednotka',
      // Time / Timespan component
      labels: ['Roky', 'Msce', 'Dny', 'Hodiny', 'Minuty', 'Sekundy', ''],
      labelsShort: ['Rok', 'Ms', 'Dny', 'Hod', 'Min', 'Sec', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Resetovat',
      lapText: 'Etapa',
      hideText: 'Schovat',
      // Listview
      backText: 'Zpt',
      undoText: 'Zpt',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Dansk
  /*
   * Translation by: Mikkel Bonde, Apacta A/S <mikbonde@gmail.com>
   */

  mobiscroll$3.i18n.da = {
      // Core
      setText: 'St',
      cancelText: 'Annuller',
      clearText: 'Ryd',
      selectedText: '{count} valgt',
      selectedPluralText: '{count} valgt',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
      dayNamesShort: ['Sn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lr'],
      dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
      dayText: 'Dag',
      hourText: 'Timer',
      minuteText: 'Minutter',
      monthNames: ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
      monthText: 'Mned',
      secText: 'Sekunder',
      amText: 'am',
      pmText: 'pm',
      timeFormat: 'HH.ii',
      yearText: 'r',
      nowText: 'Nu',
      todayText: 'I dag',
      // Calendar component
      firstDay: 1,
      dateText: 'Dato',
      timeText: 'Tid',
      closeText: 'Luk',
      // Daterange component
      fromText: 'Start',
      toText: 'Slut',
      // Measurement components
      wholeText: 'Hele',
      fractionText: 'Dele',
      unitText: 'Enhed',
      // Time / Timespan component
      labels: ['r', 'Mneder', 'Dage', 'Timer', 'Minutter', 'Sekunder', ''],
      labelsShort: ['r', 'Mdr', 'Dg', 'Timer', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Nulstil',
      lapText: 'Omgang',
      hideText: 'Skjul',
      // Forms
      offText: 'Fra',
      onText: 'Til',
      // Listview
      backText: 'Tilbage',
      undoText: 'Fortryd'
  };

  // Deutsch

  mobiscroll$3.i18n.de = {
      // Core
      setText: 'OK',
      cancelText: 'Abbrechen',
      clearText: 'Lschen',
      selectedText: '{count} ausgewhlt',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
      dayNamesShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      dayNamesMin: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
      dayText: 'Tag',
      delimiter: '.',
      hourText: 'Stunde',
      minuteText: 'Minuten',
      monthNames: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
      monthNamesShort: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
      monthText: 'Monat',
      secText: 'Sekunden',
      timeFormat: 'HH:ii',
      yearText: 'Jahr',
      nowText: 'Jetzt',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Heute',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'Zeit',
      closeText: 'Schlieen',
      // Daterange component
      fromText: 'Von',
      toText: 'Bis',
      // Measurement components
      wholeText: 'Ganze Zahl',
      fractionText: 'Bruchzahl',
      unitText: 'Maeinheit',
      // Time / Timespan component
      labels: ['Jahre', 'Monate', 'Tage', 'Stunden', 'Minuten', 'Sekunden', ''],
      labelsShort: ['Jahr.', 'Mon.', 'Tag.', 'Std.', 'Min.', 'Sek.', ''],
      // Timer component
      startText: 'Starten',
      stopText: 'Stoppen',
      resetText: 'Zurcksetzen',
      lapText: 'Lap',
      hideText: 'Ausblenden',
      // Listview
      backText: 'Zurck',
      undoText: 'Rckgngig machen',
      // Form
      offText: 'Aus',
      onText: 'Ein',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Greek

  mobiscroll$3.i18n.el = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '/',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // English (UK)

  mobiscroll$3.i18n['en-GB'] = mobiscroll$3.i18n['en-UK'] = {
      dateFormat: 'dd/mm/yy',
      timeFormat: 'HH:ii'
  };

  // Espaol

  mobiscroll$3.i18n.es = {
      // Core
      setText: 'Aceptar',
      cancelText: 'Cancelar',
      clearText: 'Borrar',
      selectedText: '{count} seleccionado',
      selectedPluralText: '{count} seleccionados',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Domingo', 'Lunes', 'Martes', 'Mi&#xE9;rcoles', 'Jueves', 'Viernes', 'S&#xE1;bado'],
      dayNamesShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'S&#xE1;'],
      dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
      dayText: 'D&#237;a',
      hourText: 'Horas',
      minuteText: 'Minutos',
      monthNames: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
      monthNamesShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
      monthText: 'Mes',
      secText: 'Segundos',
      timeFormat: 'HH:ii',
      yearText: 'A&ntilde;o',
      nowText: 'Ahora',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Hoy',
      // Calendar component
      firstDay: 1,
      dateText: 'Fecha',
      timeText: 'Tiempo',
      closeText: 'Cerrar',
      // Daterange component
      fromText: 'Iniciar',
      toText: 'Final',
      // Measurement components
      wholeText: 'Entero',
      fractionText: 'Fraccin',
      unitText: 'Unidad',
      // Time / Timespan component
      labels: ['Aos', 'Meses', 'Das', 'Horas', 'Minutos', 'Segundos', ''],
      labelsShort: ['Ao', 'Mes', 'Da', 'Hora', 'Min', 'Seg', ''],
      // Timer component
      startText: 'Iniciar',
      stopText: 'Detngase',
      resetText: 'Reinicializar',
      lapText: 'Lap',
      hideText: 'Esconder',
      // Listview
      backText: 'Atrs',
      undoText: 'Deshacer',
      // Form
      offText: 'No',
      onText: 'S',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // 

  var JalaliDate = {
      gDaysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
      jDaysInMonth: [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29]
  };

  JalaliDate.jalaliToGregorian = function (jY, jM, jD) {
      jY = parseInt(jY);
      jM = parseInt(jM);
      jD = parseInt(jD);

      var i;
      var jy = jY - 979;
      var jm = jM - 1;
      var jd = jD - 1;
      var jDayNo = 365 * jy + parseInt(jy / 33) * 8 + parseInt((jy % 33 + 3) / 4);

      for (i = 0; i < jm; ++i) {
          jDayNo += JalaliDate.jDaysInMonth[i];
      }

      jDayNo += jd;

      var gDayNo = jDayNo + 79;

      var gy = 1600 + 400 * parseInt(gDayNo / 146097);
      gDayNo = gDayNo % 146097;

      var leap = true;
      if (gDayNo >= 36525) {
          gDayNo--;
          gy += 100 * parseInt(gDayNo / 36524);
          gDayNo = gDayNo % 36524;

          if (gDayNo >= 365) {
              gDayNo++;
          } else {
              leap = false;
          }
      }

      gy += 4 * parseInt(gDayNo / 1461);
      gDayNo %= 1461;

      if (gDayNo >= 366) {
          leap = false;

          gDayNo--;
          gy += parseInt(gDayNo / 365);
          gDayNo = gDayNo % 365;
      }

      for (i = 0; gDayNo >= JalaliDate.gDaysInMonth[i] + (i == 1 && leap); i++) {
          gDayNo -= JalaliDate.gDaysInMonth[i] + (i == 1 && leap);
      }

      var gm = i + 1;
      var gd = gDayNo + 1;

      return [gy, gm, gd];
  };

  JalaliDate.checkDate = function (jY, jM, jD) {
      return !(jY < 0 || jY > 32767 || jM < 1 || jM > 12 || jD < 1 || jD > JalaliDate.jDaysInMonth[jM - 1] + (jM == 12 && (jY - 979) % 33 % 4 === 0));
  };

  JalaliDate.gregorianToJalali = function (gY, gM, gD) {
      gY = parseInt(gY);
      gM = parseInt(gM);
      gD = parseInt(gD);

      var i;
      var gy = gY - 1600;
      var gm = gM - 1;
      var gd = gD - 1;

      var gDayNo = 365 * gy + parseInt((gy + 3) / 4) - parseInt((gy + 99) / 100) + parseInt((gy + 399) / 400);

      for (i = 0; i < gm; ++i) {
          gDayNo += JalaliDate.gDaysInMonth[i];
      }

      if (gm > 1 && (gy % 4 === 0 && gy % 100 !== 0 || gy % 400 === 0)) {
          ++gDayNo;
      }

      gDayNo += gd;

      var jDayNo = gDayNo - 79;

      var jNp = parseInt(jDayNo / 12053);
      jDayNo %= 12053;

      var jy = 979 + 33 * jNp + 4 * parseInt(jDayNo / 1461);

      jDayNo %= 1461;

      if (jDayNo >= 366) {
          jy += parseInt((jDayNo - 1) / 365);
          jDayNo = (jDayNo - 1) % 365;
      }

      for (i = 0; i < 11 && jDayNo >= JalaliDate.jDaysInMonth[i]; ++i) {
          jDayNo -= JalaliDate.jDaysInMonth[i];
      }

      var jm = i + 1;
      var jd = jDayNo + 1;

      return [jy, jm, jd];
  };

  mobiscroll$3.i18n.fa = {
      // Core
      setText: '',
      cancelText: '',
      clearText: ' ',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'yy/mm/dd',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      timeWheels: 'iiHH', // Need this for correct RTL display
      yearText: '',
      nowText: '',
      amText: '',
      pmText: '',
      todayText: '',
      getYear: function getYear(date) {
          return JalaliDate.gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[0];
      },
      getMonth: function getMonth(date) {
          return --JalaliDate.gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[1];
      },
      getDay: function getDay(date) {
          return JalaliDate.gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[2];
      },
      getDate: function getDate(y, m, d, h, i, s, u) {
          if (m < 0) {
              y += Math.floor(m / 12);
              m = 12 + m % 12;
          }
          if (m > 11) {
              y += Math.floor(m / 12);
              m = m % 12;
          }
          var gregorianDate = JalaliDate.jalaliToGregorian(y, +m + 1, d);

          return new Date(gregorianDate[0], gregorianDate[1] - 1, gregorianDate[2], h || 0, i || 0, s || 0, u || 0);
      },
      getMaxDayOfMonth: function getMaxDayOfMonth(y, m) {
          var maxdays = 31;
          while (JalaliDate.checkDate(y, m + 1, maxdays) === false) {
              maxdays--;
          }
          return maxdays;
      },
      //getNumber: function (n) {
      //    var i,
      //        nums = ["", "", "", "", "", "", "", "", "", ""],
      //        res = '';

      //    n = n + '';
      //    for (i = 0; i < n.length; i++) {
      //        res += nums[+n[i]];
      //    }
      //    return res;
      //},
      // Calendar component
      firstDay: 6,
      rtl: true,
      dateText: ' ',
      timeText: ' ',
      closeText: '',
      // Daterange component
      fromText: ' ',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: ' ',
      lapText: 'Lap',
      hideText: ' ',
      // Listview
      backText: '',
      undoText: ''
  };

  // Suomi

  mobiscroll$3.i18n.fi = {
      // Core
      setText: 'Aseta',
      cancelText: 'Peruuta',
      clearText: 'Tyhjenn',
      selectedText: '{count} valita',
      // Datetime component
      dateFormat: 'd. MM yy',
      dayNames: ['Sunnuntai', 'Maanantai', 'Tiistai', 'Keskiviiko', 'Torstai', 'Perjantai', 'Lauantai'],
      dayNamesShort: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
      dayNamesMin: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
      dayText: 'Piv',
      delimiter: '.',
      hourText: 'Tuntia',
      minuteText: 'Minuutti',
      monthNames: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Keskuu', 'Heinkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
      monthNamesShort: ['Tam', 'Hel', 'Maa', 'Huh', 'Tou', 'Kes', 'Hei', 'Elo', 'Syy', 'Lok', 'Mar', 'Jou'],
      monthText: 'Kuukausi',
      secText: 'Sekunda',
      timeFormat: 'H:ii',
      yearText: 'Vuosi',
      nowText: 'Nyt',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: 'Pivys',
      timeText: 'Aika',
      todayText: 'Tnn',
      prevMonthText: 'Edellinen kuukausi',
      nextMonthText: 'Ensi kuussa',
      prevYearText: 'Edellinen vuosi',
      nextYearText: 'Ensi vuosi',
      closeText: 'Sulje',
      eventText: 'Tapahtumia',
      eventsText: 'Tapahtumia',
      // Daterange component
      fromText: 'Alkaa',
      toText: 'Pttyy',
      // Measurement components
      wholeText: 'Kokonainen',
      fractionText: 'Murtoluku',
      unitText: 'Yksikk',
      // Time / Timespan component
      labels: ['Vuosi', 'Kuukausi', 'Piv', 'Tunnin', 'Minuutti', 'sekuntia', ''],
      labelsShort: ['Vuo', 'Kuu', 'Pi', 'Tun', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Kynnistys',
      stopText: 'Seis',
      resetText: 'Aseta uudelleen',
      lapText: 'Kierros',
      hideText: 'Vuota',
      // Listview
      backText: 'Edellinen',
      undoText: 'Kumoa',
      // Form
      offText: 'Pois',
      onText: 'Pll',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Franais

  mobiscroll$3.i18n.fr = {
      // Core
      setText: 'Terminer',
      cancelText: 'Annuler',
      clearText: 'Effacer',
      selectedText: '{count} slectionn',
      selectedPluralText: '{count} slectionns',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['&#68;imanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
      dayNamesShort: ['&#68;im.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'],
      dayNamesMin: ['&#68;', 'L', 'M', 'M', 'J', 'V', 'S'],
      dayText: 'Jour',
      monthText: 'Mois',
      monthNames: ['Janvier', 'Fvrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Aot', 'Septembre', 'Octobre', 'Novembre', 'Dcembre'],
      monthNamesShort: ['Janv.', 'Fvr.', 'Mars', 'Avril', 'Mai', 'Juin', 'Juil.', 'Aot', 'Sept.', 'Oct.', 'Nov.', 'Dc.'],
      hourText: 'Heures',
      minuteText: 'Minutes',
      secText: 'Secondes',
      timeFormat: 'HH:ii',
      yearText: 'Anne',
      nowText: 'Maintenant',
      pmText: 'pm',
      amText: 'am',
      todayText: "Aujourd'hui",
      // Calendar component
      firstDay: 1,
      dateText: 'Date',
      timeText: 'Heure',
      closeText: 'Fermer',
      // Daterange component
      fromText: 'Dmarrer',
      toText: 'Fin',
      // Measurement components
      wholeText: 'Entier',
      fractionText: 'Fraction',
      unitText: 'Unit',
      // Time / Timespan component
      labels: ['Ans', 'Mois', 'Jours', 'Heures', 'Minutes', 'Secondes', ''],
      labelsShort: ['Ans', 'Mois', 'Jours', 'Hrs', 'Min', 'Sec', ''],
      // Timer component
      startText: 'Dmarrer',
      stopText: 'Arrter',
      resetText: 'Rinitialiser',
      lapText: 'Lap',
      hideText: 'Cachez',
      // Listview
      backText: 'Retour',
      undoText: 'Annuler',
      // Form
      offText: 'Non',
      onText: 'Oui',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Hebrew

  mobiscroll$3.i18n.he = {
      // Core
      rtl: true, // Right to left mode
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      selectedPluralText: '{count} ',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ["'", "'", "'", "'", "'", "'", "'"],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
      monthText: '',
      secText: '',
      amText: 'am',
      pmText: 'pm',
      timeFormat: 'HH:ii',
      timeWheels: 'iiHH', // Need this for correct RTL display
      yearText: '',
      nowText: '',
      // Calendar component
      firstDay: 0,
      dateText: '',
      timeText: '',
      closeText: '',
      todayText: '',
      // Event calendar
      eventText: '',
      eventsText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Forms
      offText: '',
      onText: '',
      // Listview
      backText: '',
      undoText: ' '
  };

  // Hindi

  mobiscroll$3.i18n.hi = {
      // Core
      setText: ' ',
      cancelText: ' ',
      clearText: ' ',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: [' ', '', '', '', '', '', '', ' ', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: ' ',
      lapText: '',
      hideText: '',
      // Listview
      backText: '', // check
      undoText: ' ',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Croatian

  mobiscroll$3.i18n.hr = {
      // Core
      setText: 'Postavi',
      cancelText: 'Izlaz',
      clearText: 'Izbrii',
      selectedText: '{count} odabran',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Nedjelja', 'Ponedjeljak', 'Utorak', 'Srijeda', 'etvrtak', 'Petak', 'Subota'],
      dayNamesShort: ['Ned', 'Pon', 'Uto', 'Sri', 'et', 'Pet', 'Sub'],
      dayNamesMin: ['Ne', 'Po', 'Ut', 'Sr', 'e', 'Pe', 'Su'],
      dayText: 'Dan',
      delimiter: '.',
      hourText: 'Sat',
      minuteText: 'Minuta',
      monthNames: ['Sijeanj', 'Veljaa', 'Oujak', 'Travanj', 'Svibanj', 'Lipanj', 'Srpanj', 'Kolovoz', 'Rujan', 'Listopad', 'Studeni', 'Prosinac'],
      monthNamesShort: ['Sij', 'Velj', 'Ou', 'Tra', 'Svi', 'Lip', 'Srp', 'Kol', 'Ruj', 'Lis', 'Stu', 'Pro'],
      monthText: 'Mjesec',
      secText: 'Sekunda',
      timeFormat: 'H:ii',
      yearText: 'Godina',
      nowText: 'Sada',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'Vrijeme',
      todayText: 'Danas',
      prevMonthText: 'Prethodni mjesec',
      nextMonthText: 'Sljedei mjesec',
      prevYearText: 'Prethodni godina',
      nextYearText: 'Slijedee godine',
      closeText: 'Zatvori',
      eventText: 'Dogaaj',
      eventsText: 'dogaaja',
      // Daterange component
      fromText: 'Poinje',
      toText: 'Zavrava',
      // Measurement components
      wholeText: 'Cjelina',
      fractionText: 'Frakcija',
      unitText: 'Jedinica',
      // Time / Timespan component
      labels: ['godina', 'mjesec', 'dan', 'sat', 'minuta', 'sekunda', ''],
      labelsShort: ['god', 'mje', 'dan', 'sat', 'min', 'sec', ''],
      // Timer component
      startText: 'Poetak',
      stopText: 'Prekid',
      resetText: 'Resetiraj',
      lapText: 'Ciklus',
      hideText: 'Sakriti',
      // Listview
      backText: 'Natrag',
      undoText: 'Ponitavanje',
      // Form
      offText: 'Uklj.',
      onText: 'Isklj.',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Magyar

  mobiscroll$3.i18n.hu = {
      // Core
      setText: 'OK',
      cancelText: 'Mgse',
      clearText: 'Trls',
      selectedText: '{count} kivlasztva',
      // Datetime component
      dateFormat: 'yy.mm.dd.',
      dayNames: ['Vasrnap', 'Htf', 'Kedd', 'Szerda', 'Cstrtk', 'Pntek', 'Szombat'],
      dayNamesShort: ['Va', 'H', 'Ke', 'Sze', 'Cs', 'P', 'Szo'],
      dayNamesMin: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
      dayText: 'Nap',
      delimiter: '.',
      hourText: 'ra',
      minuteText: 'Perc',
      monthNames: ['Janur', 'Februr', 'Mrcius', 'prilis', 'Mjus', 'Jnius', 'Jlius', 'Augusztus', 'Szeptember', 'Oktber', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mr', 'pr', 'Mj', 'Jn', 'Jl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
      monthText: 'Hnap',
      secText: 'Msodperc',
      timeFormat: 'H:ii',
      yearText: 'v',
      nowText: 'Most',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: 'Dtum',
      timeText: 'Id',
      todayText: 'Ma',
      prevMonthText: 'Elz hnap',
      nextMonthText: 'Kvetkez hnap',
      prevYearText: 'Elz v',
      nextYearText: 'Kvetkez v',
      closeText: 'Bezr',
      eventText: 'esemny',
      eventsText: 'esemny',
      // Daterange component
      fromText: 'Eleje',
      toText: 'Vge',
      // Measurement components
      wholeText: 'Egsz',
      fractionText: 'Trt',
      unitText: 'Egysg',
      // Time / Timespan component
      labels: ['v', 'Hnap', 'Nap', 'ra', 'Perc', 'Msodperc', ''],
      labelsShort: ['v', 'H.', 'Nap', 'ra', 'Perc', 'Mp.', ''],
      // Timer component
      startText: 'Indt',
      stopText: 'Megllt',
      resetText: 'Visszallt',
      lapText: 'Lap',
      hideText: 'Elrejt',
      // Listview
      backText: 'Vissza',
      undoText: 'Visszavon',
      // Form
      offText: 'Ki',
      onText: 'Be',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Italiano 

  mobiscroll$3.i18n.it = {
      // Core
      setText: 'OK',
      cancelText: 'Annulla',
      clearText: 'Chiarire',
      selectedText: '{count} selezionato',
      selectedPluralText: '{count} selezionati',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Domenica', 'Luned', 'Merted', 'Mercoled', 'Gioved', 'Venerd', 'Sabato'],
      dayNamesShort: ['Do', 'Lu', 'Ma', 'Me', 'Gi', 'Ve', 'Sa'],
      dayNamesMin: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
      dayText: 'Giorno',
      hourText: 'Ore',
      minuteText: 'Minuti',
      monthNames: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'],
      monthNamesShort: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'],
      monthText: 'Mese',
      secText: 'Secondi',
      timeFormat: 'HH:ii',
      yearText: 'Anno',
      nowText: 'Ora',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Oggi',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Volta',
      closeText: 'Chiudere',
      // Daterange component
      fromText: 'Inizio',
      toText: 'Fine',
      // Measurement components
      wholeText: 'Intero',
      fractionText: 'Frazione',
      unitText: 'Unit',
      // Time / Timespan component
      labels: ['Anni', 'Mesi', 'Giorni', 'Ore', 'Minuti', 'Secondi', ''],
      labelsShort: ['Anni', 'Mesi', 'Gio', 'Ore', 'Min', 'Sec', ''],
      // Timer component
      startText: 'Inizio',
      stopText: 'Arresto',
      resetText: 'Ripristina',
      lapText: 'Lap',
      hideText: 'Nascondi',
      // Listview
      backText: 'Indietro',
      undoText: 'Annulla',
      // Form
      offText: 'Via',
      onText: 'Su',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Japanese

  mobiscroll$3.i18n.ja = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'yymmdd',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      yearSuffix: '',
      monthSuffix: '',
      daySuffix: '',
      todayText: '',
      // Calendar component
      dateText: '',
      timeText: '',
      closeText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: ''
  };

  // Korean

  mobiscroll$3.i18n.ko = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'yy-mm-dd',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '-',
      hourText: '',
      minuteText: '',
      monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      // Calendar component
      firstDay: 0,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: ' ',
      resetText: '',
      lapText: '',
      hideText: ' ',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Lietuvi

  mobiscroll$3.i18n.lt = {
      // Core
      setText: 'OK',
      cancelText: 'Ataukti',
      clearText: 'Ivalyti',
      selectedText: 'Pasirinktas {count}',
      selectedPluralText: 'Pasirinkti {count}',
      // Datetime component
      dateFormat: 'yy-mm-dd',
      dayNames: ['Sekmadienis', 'Pirmadienis', 'Antradienis', 'Treiadienis', 'Ketvirtadienis', 'Penktadienis', 'etadienis'],
      dayNamesShort: ['S', 'Pr', 'A', 'T', 'K', 'Pn', ''],
      dayNamesMin: ['S', 'Pr', 'A', 'T', 'K', 'Pn', ''],
      dayText: 'Diena',
      hourText: 'Valanda',
      minuteText: 'Minutes',
      monthNames: ['Sausis', 'Vasaris', 'Kovas', 'Balandis', 'Gegu', 'Birelis', 'Liepa', 'Rugpjtis', 'Rugsjis', 'Spalis', 'Lapkritis', 'Gruodis'],
      monthNamesShort: ['Sau', 'Vas', 'Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rugp', 'Rugs', 'Spa', 'Lap', 'Gruo'],
      monthText: 'Mnuo',
      secText: 'Sekundes',
      amText: 'am',
      pmText: 'pm',
      timeFormat: 'HH:ii',
      yearText: 'Metai',
      nowText: 'Dabar',
      todayText: 'iandien',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Laikas',
      closeText: 'Udaryti',
      // Daterange component
      fromText: 'Nuo',
      toText: 'Iki',
      // Measurement components
      wholeText: 'Visas',
      fractionText: 'Frakcija',
      unitText: 'Vienetas',
      // Time / Timespan component
      labels: ['Metai', 'Mnesiai', 'Dienos', 'Valandos', 'Minutes', 'Sekundes', ''],
      labelsShort: ['m', 'mn.', 'd', 'h', 'min', 's', ''],
      // Timer component
      startText: 'Pradti',
      stopText: 'Sustabdyti',
      resetText: 'Inaujo',
      lapText: 'Ratas',
      hideText: 'Slpti',
      // Listview
      backText: 'Atgal',
      undoText: 'Anuliuoti',
      // Form
      offText: 'Ij.',
      onText: 'j.',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Nederlands

  mobiscroll$3.i18n.nl = {
      // Core
      setText: 'Instellen',
      cancelText: 'Annuleren',
      clearText: 'Leegmaken',
      selectedText: '{count} gekozen',
      // Datetime component
      dateFormat: 'dd-mm-yy',
      dayNames: ['zondag', 'maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrijdag', 'Zaterdag'],
      dayNamesShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
      dayNamesMin: ['z', 'm', 'd', 'w', 'd', 'v', 'z'],
      dayText: 'Dag',
      hourText: 'Uur',
      minuteText: 'Minuten',
      monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
      monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
      monthText: 'Maand',
      secText: 'Seconden',
      timeFormat: 'HH:ii',
      yearText: 'Jaar',
      nowText: 'Nu',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Vandaag',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'Tijd',
      closeText: 'Sluiten',
      // Daterange component
      fromText: 'Start',
      toText: 'Einde',
      // Measurement components
      wholeText: 'geheel',
      fractionText: 'fractie',
      unitText: 'eenheid',
      // Time / Timespan component
      labels: ['Jaren', 'Maanden', 'Dagen', 'Uren', 'Minuten', 'Seconden', ''],
      labelsShort: ['j', 'm', 'd', 'u', 'min', 'sec', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Reset',
      lapText: 'Ronde',
      hideText: 'Verbergen',
      // Listview
      backText: 'Terug',
      undoText: 'Onged. maken',
      // Form
      offText: 'Uit',
      onText: 'Aan',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Norsk

  mobiscroll$3.i18n.no = {
      // Core
      setText: 'OK',
      cancelText: 'Avbryt',
      clearText: 'Tmme',
      selectedText: '{count} valgt',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
      dayNamesShort: ['S', 'Ma', 'Ti', 'On', 'To', 'Fr', 'L'],
      dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
      dayText: 'Dag',
      delimiter: '.',
      hourText: 'Time',
      minuteText: 'Minutt',
      monthNames: ['Januar', 'Februar', 'Mars', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Desember'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
      monthText: 'Mned',
      secText: 'Sekund',
      timeFormat: 'HH:ii',
      yearText: 'r',
      nowText: 'N',
      pmText: 'pm',
      amText: 'am',
      todayText: 'I dag',
      // Calendar component
      firstDay: 1,
      dateText: 'Dato',
      timeText: 'Tid',
      closeText: 'Lukk',
      // Daterange component
      fromText: 'Start',
      toText: 'End',
      // Measurement components
      wholeText: 'Hele',
      fractionText: 'Fraksjon',
      unitText: 'Enhet',
      // Time / Timespan component
      labels: ['r', 'Mneder', 'Dager', 'Timer', 'Minutter', 'Sekunder', ''],
      labelsShort: ['r', 'Mn', 'Dag', 'Time', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stopp',
      resetText: 'Tilbakestille',
      lapText: 'Runde',
      hideText: 'Skjul',
      // Listview
      backText: 'Tilbake',
      undoText: 'Angre',
      // Form
      offText: 'Av',
      onText: 'P',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Polski

  mobiscroll$3.i18n.pl = {
      // Core
      setText: 'Zestaw',
      cancelText: 'Anuluj',
      clearText: 'Oczyci',
      selectedText: 'Wybr: {count}',
      // Datetime component
      dateFormat: 'yy-mm-dd',
      dayNames: ['Niedziela', 'Poniedziaek', 'Wtorek', 'roda', 'Czwartek', 'Pitek', 'Sobota'],
      dayNamesShort: ['Niedz.', 'Pon.', 'Wt.', 'r.', 'Czw.', 'Pt.', 'Sob.'],
      dayNamesMin: ['N', 'P', 'W', '', 'C', 'P', 'S'],
      dayText: 'Dzie',
      hourText: 'Godziny',
      minuteText: 'Minuty',
      monthNames: ['Stycze', 'Luty', 'Marzec', 'Kwiecie', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpie', 'Wrzesie', 'Padziernik', 'Listopad', 'Grudzie'],
      monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Pa', 'Lis', 'Gru'],
      monthText: 'Miesic',
      secText: 'Sekundy',
      timeFormat: 'HH:ii',
      yearText: 'Rok',
      nowText: 'Teraz',
      amText: 'am',
      pmText: 'pm',
      todayText: 'Dzisiaj',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Czas',
      closeText: 'Zakoczenie',
      // Daterange component
      fromText: 'Rozpoczcie',
      toText: 'Koniec',
      // Measurement components
      wholeText: 'Cay',
      fractionText: 'Uamek',
      unitText: 'Jednostka',
      // Time / Timespan component
      labels: ['Lata', 'Miesic', 'Dni', 'Godziny', 'Minuty', 'Sekundy', ''],
      labelsShort: ['R', 'M', 'Dz', 'Godz', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Rozpoczcie',
      stopText: 'Zatrzyma',
      resetText: 'Zresetowa',
      lapText: 'Zakadka',
      hideText: 'Ukry',
      // Listview
      backText: 'Wr',
      undoText: 'Cofnij',
      // Form
      offText: 'Wy',
      onText: 'W',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Portugus Brasileiro
  /*
   * Translation by: Ivan Gomes <contato@ivangomes.com.br>
   */

  mobiscroll$3.i18n['pt-BR'] = {
      // Core
      setText: 'Selecionar',
      cancelText: 'Cancelar',
      clearText: 'Claro',
      selectedText: '{count} selecionado',
      selectedPluralText: '{count} selecionados',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Domingo', 'Segunda-feira', 'Tera-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sbado'],
      dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
      dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
      dayText: 'Dia',
      hourText: 'Hora',
      minuteText: 'Minutos',
      monthNames: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
      monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
      monthText: 'Ms',
      secText: 'Segundo',
      timeFormat: 'HH:ii',
      yearText: 'Ano',
      nowText: 'Agora',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Hoje',
      // Calendar component
      dateText: 'Data',
      timeText: 'Tempo',
      closeText: 'Fechar',
      // Daterange component
      fromText: 'In&iacute;cio',
      toText: 'Fim',
      // Measurement components
      wholeText: 'Inteiro',
      fractionText: 'Frao',
      unitText: 'Unidade',
      // Time / Timespan component
      labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
      labelsShort: ['Ano', 'M&ecirc;s', 'Dia', 'Hora', 'Min', 'Seg', ''],
      // Timer component
      startText: 'Comear',
      stopText: 'Pare',
      resetText: 'Reinicializar',
      lapText: 'Lap',
      hideText: 'Esconder',
      // Listview
      backText: 'Anterior',
      undoText: 'Desfazer',
      // Form
      offText: 'Desl',
      onText: 'Lig',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Portugus Europeu
  /*
   * Translation by: Jorge Simoes <http://jorge.simoes.com>
   */

  mobiscroll$3.i18n['pt-PT'] = {
      // Core
      setText: 'Seleccionar',
      cancelText: 'Cancelar',
      clearText: 'Claro',
      selectedText: '{count} selecionado',
      selectedPluralText: '{count} selecionados',
      // Datetime component
      dateFormat: 'dd-mm-yy',
      dayNames: ['Domingo', 'Segunda-feira', 'Tera-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'S&aacute;bado'],
      dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'S&aacute;b'],
      dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
      dayText: 'Dia',
      hourText: 'Horas',
      minuteText: 'Minutos',
      monthNames: ['Janeiro', 'Fevereiro', 'Mar&ccedil;o', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
      monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
      monthText: 'M&ecirc;s',
      secText: 'Segundo',
      timeFormat: 'HH:ii',
      yearText: 'Ano',
      nowText: 'Actualizar',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Hoy',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Tempo',
      closeText: 'Fechar',
      // Daterange component
      fromText: 'In&iacute;cio',
      toText: 'Fim',
      // Measurement components
      wholeText: 'Inteiro',
      fractionText: 'Frac&ccedil;&atilde;o',
      unitText: 'Unidade',
      // Time / Timespan component
      labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
      labelsShort: ['Ano', 'M&ecirc;s', 'Dia', 'Hora', 'Min', 'Seg', ''],
      // Timer component
      startText: 'Come&ccedil;ar',
      stopText: 'Parar',
      resetText: 'Reinicializar',
      lapText: 'Lap',
      hideText: 'Esconder',
      // Listview
      backText: 'Anterior',
      undoText: 'Anular',
      // Form
      offText: 'Desl',
      onText: 'Lig',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Romn

  mobiscroll$3.i18n.ro = {
      // Core
      setText: 'Setare',
      cancelText: 'Anulare',
      clearText: 'tergere',
      selectedText: '{count} selectat',
      selectedPluralText: '{count} selectate',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Duminic', 'Luni', 'Mari', 'Miercuri', 'Joi', 'Vineri', 'Smbt'],
      dayNamesShort: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'S'],
      dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
      dayText: ' Ziua',
      delimiter: '.',
      hourText: ' Ore ',
      minuteText: 'Minute',
      monthNames: ['Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie', 'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'],
      monthNamesShort: ['Ian.', 'Feb.', 'Mar.', 'Apr.', 'Mai', 'Iun.', 'Iul.', 'Aug.', 'Sept.', 'Oct.', 'Nov.', 'Dec.'],
      monthText: 'Luna',
      secText: 'Secunde',
      timeFormat: 'HH:ii',
      yearText: 'Anul',
      nowText: 'Acum',
      amText: 'am',
      pmText: 'pm',
      todayText: 'Astzi',
      // Calendar component
      firstDay: 1,
      dateText: 'Data',
      timeText: 'Ora',
      closeText: 'nchidere',
      // Daterange component
      fromText: 'Start',
      toText: 'Final',
      // Measurement components
      wholeText: 'Complet',
      fractionText: 'Parial',
      unitText: 'Unitate',
      // Time / Timespan component
      labels: ['Ani', 'Luni', 'Zile', 'Ore', 'Minute', 'Secunde', ''],
      labelsShort: ['Ani', 'Luni', 'Zile', 'Ore', 'Min.', 'Sec.', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Resetare',
      lapText: 'Tur',
      hideText: 'Ascundere',
      // Listview
      backText: 'napoi',
      undoText: 'Anuleaz',
      // Form
      offText: 'Nu',
      onText: 'Da',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  //  (UA)

  mobiscroll$3.i18n['ru-UA'] = {
      // Core
      setText: '',
      cancelText: '',
      clearText: 'r',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['.', '.', '', '.', '', '', '', '.', '.', '.', '.', '.'],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      yearText: '',
      nowText: '',
      amText: 'am',
      pmText: 'pm',
      todayText: 'C',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      closeText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '  ', '  ', '  ', '  ', ' ', ''],
      labelsShort: ['', '.', '.', '.', '.', '.', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '  ',
      lapText: '  ',
      hideText: '  ',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // 

  mobiscroll$3.i18n['ru-RU'] = mobiscroll$3.i18n.ru = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      yearText: '',
      nowText: '',
      amText: 'am',
      pmText: 'pm',
      todayText: 'C',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      closeText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Slovencina

  mobiscroll$3.i18n.sk = {
      // Core
      setText: 'Zadaj',
      cancelText: 'Zrui',
      clearText: 'Vymaza',
      selectedText: 'Oznaen: {count}',
      // Datetime component
      dateFormat: 'd.m.yy',
      dayNames: ['Nedea', 'Pondelok', 'Utorok', 'Streda', 'tvrtok', 'Piatok', 'Sobota'],
      dayNamesShort: ['Ne', 'Po', 'Ut', 'St', 't', 'Pi', 'So'],
      dayNamesMin: ['N', 'P', 'U', 'S', '', 'P', 'S'],
      dayText: 'e',
      hourText: 'Hodiny',
      minuteText: 'Minty',
      monthNames: ['Janur', 'Februr', 'Marec', 'Aprl', 'Mj', 'Jn', 'Jl', 'August', 'September', 'Oktber', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mj', 'Jn', 'Jl', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
      monthText: 'Mesiac',
      secText: 'Sekundy',
      timeFormat: 'H:ii',
      yearText: 'Rok',
      nowText: 'Teraz',
      amText: 'am',
      pmText: 'pm',
      todayText: 'Dnes',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'as',
      closeText: 'Zavrie',
      // Daterange component
      fromText: 'Zaiatok',
      toText: 'Koniec',
      // Measurement components
      wholeText: 'Cel',
      fractionText: 'as',
      unitText: 'Jednotka',
      // Time / Timespan component
      labels: ['Roky', 'Mesiace', 'Dni', 'Hodiny', 'Minty', 'Sekundy', ''],
      labelsShort: ['Rok', 'Mes', 'Dni', 'Hod', 'Min', 'Sec', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stop',
      resetText: 'Resetova',
      lapText: 'Etapa',
      hideText: 'Schova',
      // Listview
      backText: 'Sp',
      undoText: 'Sp',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Serbian

  mobiscroll$3.i18n.sr = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      delimiter: '.',
      hourText: '',
      minuteText: '',
      monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'H:ii',
      yearText: '',
      nowText: '',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 1,
      dateText: '',
      timeText: '',
      todayText: '',
      prevMonthText: ' ',
      nextMonthText: ' ',
      prevYearText: ' ',
      nextYearText: ' ',
      closeText: '',
      eventText: '',
      eventsText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: 'e',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Svenska

  mobiscroll$3.i18n.sv = {
      // Core
      setText: 'OK',
      cancelText: 'Avbryt',
      clearText: 'Klara',
      selectedText: '{count} vald',
      // Datetime component
      dateFormat: 'yy-mm-dd',
      dayNames: ['Sndag', 'Mndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
      dayNamesShort: ['S', 'M', 'Ti', 'On', 'To', 'Fr', 'L'],
      dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
      dayText: 'Dag',
      hourText: 'Timme',
      minuteText: 'Minut',
      monthNames: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni', 'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
      monthText: 'Mnad',
      secText: 'Sekund',
      timeFormat: 'HH:ii',
      yearText: 'r',
      nowText: 'Nu',
      pmText: 'pm',
      amText: 'am',
      todayText: 'I dag',
      // Calendar component
      firstDay: 1,
      dateText: 'Datum',
      timeText: 'Tid',
      closeText: 'Stng',
      // Daterange component
      fromText: 'Start',
      toText: 'Slut',
      // Measurement components
      wholeText: 'Hela',
      fractionText: 'Brk',
      unitText: 'Enhet',
      // Time / Timespan component
      labels: ['r', 'Mnader', 'Dagar', 'Timmar', 'Minuter', 'Sekunder', ''],
      labelsShort: ['r', 'Mn', 'Dag', 'Tim', 'Min', 'Sek', ''],
      // Timer component
      startText: 'Start',
      stopText: 'Stopp',
      resetText: 'terstll',
      lapText: 'Varv',
      hideText: 'Dlj',
      // Listview
      backText: 'Tillbaka',
      undoText: 'ngra',
      // Form
      offText: 'Av',
      onText: 'P'
  };

  // Trke

  mobiscroll$3.i18n.tr = {
      // Core
      setText: 'Se',
      cancelText: 'ptal',
      clearText: 'Temizleyin',
      selectedText: '{count} seilmi',
      // Datetime component
      dateFormat: 'dd.mm.yy',
      dayNames: ['Pazar', 'Pazartesi', 'Sal', 'aramba', 'Perembe', 'Cuma', 'Cumartesi'],
      dayNamesShort: ['Paz', 'Pzt', 'Sal', 'ar', 'Per', 'Cum', 'Cmt'],
      dayNamesMin: ['P', 'P', 'S', '', 'P', 'C', 'C'],
      dayText: 'Gn',
      delimiter: '.',
      hourText: 'Saat',
      minuteText: 'Dakika',
      monthNames: ['Ocak', 'ubat', 'Mart', 'Nisan', 'Mays', 'Haziran', 'Temmuz', 'Austos', 'Eyll', 'Ekim', 'Kasm', 'Aralk'],
      monthNamesShort: ['Oca', 'ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Au', 'Eyl', 'Eki', 'Kas', 'Ara'],
      monthText: 'Ay',
      secText: 'Saniye',
      timeFormat: 'HH:ii',
      yearText: 'Yl',
      nowText: 'imdi',
      pmText: 'pm',
      amText: 'am',
      todayText: 'Bugn',
      // Calendar component
      firstDay: 1,
      dateText: 'Tarih',
      timeText: 'Zaman',
      closeText: 'Kapatmak',
      // Daterange component
      fromText: 'Bala',
      toText: 'Son',
      // Measurement components
      wholeText: 'Tam',
      fractionText: 'Kesir',
      unitText: 'Birim',
      // Time / Timespan component
      labels: ['Yl', 'Ay', 'Gn', 'Saat', 'Dakika', 'Saniye', ''],
      labelsShort: ['Yl', 'Ay', 'Gn', 'Sa', 'Dak', 'Sn', ''],
      // Timer component
      startText: 'Bala',
      stopText: 'Durdur',
      resetText: 'Sfrla',
      lapText: 'Tur',
      hideText: 'Gizle',
      // Listview
      backText: 'Geri',
      undoText: 'Geri Al',
      // Form
      offText: 'O',
      onText: 'I',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: '.'
  };

  // Vietnamese 

  mobiscroll$3.i18n.vi = {
      // Core
      setText: 't',
      cancelText: 'Hy b',
      clearText: 'Xa',
      selectedText: '{count} chn',
      // Datetime component
      dateFormat: 'dd/mm/yy',
      dayNames: ['Ch Nht', 'Th Hai', 'Th Ba', 'Th T', 'Th Nm', 'Th Su', 'Th By'],
      dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
      dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
      dayText: '',
      delimiter: '/',
      hourText: 'Gi',
      minuteText: 'Pht',
      monthNames: ['Thng Mt', 'Thng Hai', 'Thng Ba', 'Thng T', 'Thng Nm', 'Thng Su', 'Thng By', 'Thng Tm', 'Thng Chn', 'Thng Mi', 'Thng Mi Mt', 'Thng Mi Hai'],
      monthNamesShort: ['Thng 1', 'Thng 2', 'Thng 3', 'Thng 4', 'Thng 5', 'Thng 6', 'Thng 7', 'Thng 8', 'Thng 9', 'Thng 10', 'Thng 11', 'Thng 12'],
      monthText: 'Thng',
      secText: 'Giy',
      timeFormat: 'H:ii',
      yearText: 'Nm',
      nowText: 'By gi',
      pmText: 'pm',
      amText: 'am',
      // Calendar component
      firstDay: 0,
      dateText: 'Ngy',
      timeText: 'Hi',
      todayText: 'Hm nay',

      prevMonthText: 'Thng trc',
      nextMonthText: 'Thng ti',
      prevYearText: 'Mm trc',
      nextYearText: 'Nm ti',
      closeText: 'ng',
      eventText: 'S kin',
      eventsText: 'S kin',
      // Daterange component
      fromText: 'T',
      toText: 'Ti',
      // Measurement components
      wholeText: 'Ton th',
      fractionText: 'Phn s',
      unitText: 'n v',
      // Time / Timespan component
      labels: ['Nm', 'Thng', 'Ngy', 'Gi', 'Pht', 'Giy', ''],
      labelsShort: ['Nm', 'Thng', 'Ngy', 'Gi', 'Pht', 'Giy', ''],
      // Timer component
      startText: 'Bt u',
      stopText: 'Dng',
      resetText: 't li',
      lapText: 'Vng',
      hideText: 'Giu',
      // Listview
      backText: 'Quay li',
      undoText: 'Hon tc',
      // Form
      offText: 'Tt',
      onText: 'Bt',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  // Chinese

  mobiscroll$3.i18n.zh = {
      // Core
      setText: '',
      cancelText: '',
      clearText: '',
      selectedText: '{count} ',
      // Datetime component
      dateFormat: 'yy/mm/dd',
      dayNames: ['', '', '', '', '', '', ''],
      dayNamesShort: ['', '', '', '', '', '', ''],
      dayNamesMin: ['', '', '', '', '', '', ''],
      dayText: '',
      hourText: '',
      minuteText: '',
      monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
      monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
      monthText: '',
      secText: '',
      timeFormat: 'HH:ii',
      yearText: '',
      nowText: '',
      pmText: '',
      amText: '',
      todayText: '',
      // Calendar component
      dateText: '',
      timeText: '',
      closeText: '',
      // Daterange component
      fromText: '',
      toText: '',
      // Measurement components
      wholeText: '',
      fractionText: '',
      unitText: '',
      // Time / Timespan component
      labels: ['', '', '', '', '', '', ''],
      labelsShort: ['', '', '', '', '', '', ''],
      // Timer component
      startText: '',
      stopText: '',
      resetText: '',
      lapText: '',
      hideText: '',
      // Listview
      backText: '',
      undoText: '',
      // Form
      offText: '',
      onText: '',
      // Numpad
      decimalSeparator: ',',
      thousandsSeparator: ' '
  };

  var themes$1 = mobiscroll$3.themes;

  themes$1.frame.ios = {
      display: 'bottom', // frame
      headerText: false, // frame
      btnWidth: false, // frame
      deleteIcon: 'ios-backspace', // numpad
      scroll3d: true
  };

  themes$1.scroller.ios = extend$1({}, themes$1.frame.ios, {
      rows: 5, // scroller
      height: 34, // scroller
      minWidth: 55, // scroller
      selectedLineHeight: true, // scroller
      selectedLineBorder: 1, // scroller
      showLabel: false, // scroller
      useShortLabels: true, // timespan/timer
      btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5', // scroller
      btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5', // scroller
      checkIcon: 'ion-ios7-checkmark-empty', // select
      filterClearIcon: 'ion-close-circled', // select
      dateDisplay: 'MMdyy', // date
      btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5', // calendar
      btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar
  });

  themes$1.listview.ios = {
      leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',
      rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'
  };

  themes$1.form.ios = {};

  function _addRipple($control, ev) {
      var x = getCoord(ev, 'X', true),
          y = getCoord(ev, 'Y', true),
          rect = $control.offset(),
          left = x - rect.left,
          top = y - rect.top,
          width = Math.max(left, $control[0].offsetWidth - left),
          height = Math.max(top, $control[0].offsetHeight - top),
          size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

      _removeRipple($ripple);

      $ripple = $$2('<span class="mbsc-ripple"></span>').css({
          width: size,
          height: size,
          top: y - rect.top - size / 2,
          left: x - rect.left - size / 2
      }).appendTo($control);

      setTimeout(function () {
          $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');
      }, 10);
  }

  function _removeRipple($r) {
      setTimeout(function () {
          if ($r) {
              $r.removeClass('mbsc-ripple-visible');
              setTimeout(function () {
                  $r.remove();
              }, 2000);
          }
      }, 100);
  }

  function initRipple($markup, selector, disabled, nohl) {
      var startX, startY;

      $markup.off('.mbsc-ripple').on('touchstart.mbsc-ripple mousedown.mbsc-ripple', selector, function (ev) {
          if (testTouch(ev, this)) {
              startX = getCoord(ev, 'X');
              startY = getCoord(ev, 'Y');

              $active$1 = $$2(this);

              if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {
                  _addRipple($active$1, ev);
              } else {
                  $active$1 = null;
              }
          }
      }).on('touchmove.mbsc-ripple mousemove.mbsc-ripple', selector, function (ev) {
          if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {
              _removeRipple($ripple);
              $active$1 = null;
          }
      }).on('touchend.mbsc-ripple touchcancel.mbsc-ripple mouseleave.mbsc-ripple mouseup.mbsc-ripple', selector, function () {
          if ($active$1) {
              setTimeout(function () {
                  _removeRipple($ripple);
              }, 100);
              $active$1 = null;
          }
      });
  }

  var $active$1;
  var $ripple;
  var themes$2 = mobiscroll$3.themes;

  themes$2.frame.material = {
      headerText: false,
      btnWidth: false,
      deleteIcon: 'material-backspace',
      onMarkupReady: function onMarkupReady(ev) {
          initRipple($$2(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');
      }
  };

  themes$2.scroller.material = extend$1({}, themes$2.frame.material, {
      showLabel: false,
      selectedLineBorder: 2,
      weekDays: 'min',
      icon: {
          filled: 'material-star',
          empty: 'material-star-outline'
      },
      checkIcon: 'material-check',
      btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',
      btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',
      btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',
      btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right',
      onEventBubbleShow: function onEventBubbleShow(ev) {
          var $events = $$2(ev.eventList),
              bottom = $$2(ev.target).closest('.mbsc-cal-row').index() < 2,
              color = $$2('.mbsc-cal-event-color', $events).eq(bottom ? 0 : -1).css('background-color');

          $$2('.mbsc-cal-events-arr', $events).css('border-color', bottom ? 'transparent transparent ' + color + ' transparent' : color + 'transparent transparent transparent');
      }
  });

  themes$2.listview.material = {
      leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',
      rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',
      onItemActivate: function onItemActivate(ev) {
          _addRipple($$2(ev.target), ev.domEvent);
      },
      onItemDeactivate: function onItemDeactivate() {
          _removeRipple($ripple);
      },
      onSlideStart: function onSlideStart(ev) {
          $$2('.mbsc-ripple', ev.target).remove();
      },
      onSortStart: function onSortStart(ev) {
          $$2('.mbsc-ripple', ev.target).remove();
      }
  };

  themes$2.navigation.material = {
      onInit: function onInit() {
          initRipple($$2(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');
      },
      onMarkupInit: function onMarkupInit() {
          $$2('.mbsc-ripple', this).remove();
      },
      onDestroy: function onDestroy() {
          $$2(this).off('.mbsc-ripple');
      }
  };

  themes$2.form.material = {
      addRipple: function addRipple(elm, ev) {
          _addRipple(elm, ev);
      },
      removeRipple: function removeRipple() {
          _removeRipple($ripple);
      }
  };

  var themes$3 = mobiscroll$3.themes;

  themes$3.frame.windows = {
      headerText: false,
      deleteIcon: 'backspace4',
      //setIcon: 'material-check',
      //cancelIcon: 'material-close',
      //closeIcon: 'material-close',
      //clearIcon: 'material-close',
      //okIcon: 'material-check',
      //nowIcon: 'loop2',
      //startIcon: 'play3',
      //stopIcon: 'pause2',
      //resetIcon: 'stop2',
      //lapIcon: 'loop2',
      //btnWidth: false,
      btnReverse: true
  };

  themes$3.scroller.windows = extend$1({}, themes$3.frame.windows, {
      rows: 6, // scroller
      minWidth: 88,
      height: 44,
      btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
      btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
      checkIcon: 'material-check',
      dateDisplay: 'MMdyy', // date
      showLabel: false,
      showScrollArrows: true,
      btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5', // calendar
      btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5', // calendar
      dayNamesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      useShortLabels: true // timespan/timer
  });

  themes$3.form.windows = {};

  mobiscroll$3.customTheme('ios-dark', 'ios');

  mobiscroll$3.customTheme('material-dark', 'material');

  mobiscroll$3.customTheme('mobiscroll-dark', 'mobiscroll');

  mobiscroll$3.customTheme('windows-dark', 'windows');

  var themes$4 = mobiscroll$3.themes;

  var theme = void 0;

  if (os == 'android') {
      theme = 'material';
  } else if (os == 'ios') {
      theme = 'ios';
  } else if (os == 'wp') {
      theme = 'windows';
  }

  $$2.each(themes$4.frame, function (key, settings) {
      // Stop at the first custom theme with the OS base theme
      if (theme && settings.baseTheme == theme && key != 'material-dark' && key != 'windows-dark' && key != 'ios-dark') {
          mobiscroll$3.autoTheme = key;
          return false;
      } else if (key == theme) {
          mobiscroll$3.autoTheme = key;
      }
  });

  // Languages
  // Themes
  // Custom themes
  // Auto Theme

  // Components

  return mobiscroll$3;

})));

//# sourceMappingURL=mobiscroll.react.js.map